window["ccpwgl_int"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 64);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _num = __webpack_require__(30);

Object.keys(_num).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _num[key];
    }
  });
});

var _vec = __webpack_require__(66);

Object.keys(_vec).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _vec[key];
    }
  });
});

var _vec2 = __webpack_require__(34);

Object.keys(_vec2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _vec2[key];
    }
  });
});

var _vec3 = __webpack_require__(35);

Object.keys(_vec3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _vec3[key];
    }
  });
});

var _quat = __webpack_require__(72);

Object.keys(_quat).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _quat[key];
    }
  });
});

var _mat = __webpack_require__(73);

Object.keys(_mat).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _mat[key];
    }
  });
});

var _mat2 = __webpack_require__(74);

Object.keys(_mat2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _mat2[key];
    }
  });
});

var _noise = __webpack_require__(75);

Object.keys(_noise).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _noise[key];
    }
  });
});

var _curve = __webpack_require__(76);

Object.keys(_curve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _curve[key];
    }
  });
});

var _util = __webpack_require__(77);

Object.keys(_util).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _util[key];
    }
  });
});

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _batch = __webpack_require__(20);

Object.keys(_batch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _batch[key];
    }
  });
});

var _curve = __webpack_require__(86);

Object.keys(_curve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _curve[key];
    }
  });
});

var _data = __webpack_require__(96);

Object.keys(_data).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _data[key];
    }
  });
});

var _deprecated = __webpack_require__(98);

Object.keys(_deprecated).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _deprecated[key];
    }
  });
});

var _global = __webpack_require__(17);

Object.keys(_global).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _global[key];
    }
  });
});

var _geometry = __webpack_require__(46);

Object.keys(_geometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _geometry[key];
    }
  });
});

var _mesh = __webpack_require__(47);

Object.keys(_mesh).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _mesh[key];
    }
  });
});

var _model = __webpack_require__(131);

Object.keys(_model).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _model[key];
    }
  });
});

var _parameter = __webpack_require__(24);

Object.keys(_parameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _parameter[key];
    }
  });
});

var _post = __webpack_require__(137);

Object.keys(_post).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _post[key];
    }
  });
});

var _reader = __webpack_require__(29);

Object.keys(_reader).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _reader[key];
    }
  });
});

var _resource = __webpack_require__(28);

Object.keys(_resource).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _resource[key];
    }
  });
});

var _sampler = __webpack_require__(21);

Object.keys(_sampler).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _sampler[key];
    }
  });
});

var _vertex = __webpack_require__(9);

Object.keys(_vertex).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _vertex[key];
    }
  });
});

var _Tw2Float = __webpack_require__(139);

Object.keys(_Tw2Float).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Float[key];
    }
  });
});

var _Tw2Frustum = __webpack_require__(140);

Object.keys(_Tw2Frustum).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Frustum[key];
    }
  });
});

var _Tw2RenderTarget = __webpack_require__(56);

Object.keys(_Tw2RenderTarget).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RenderTarget[key];
    }
  });
});

var _Tw2EventEmitter = __webpack_require__(36);

Object.keys(_Tw2EventEmitter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2EventEmitter[key];
    }
  });
});

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.device = exports.Tw2Device = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Store = __webpack_require__(16);

var _Tw2Logger = __webpack_require__(4);

var _Tw2ResMan = __webpack_require__(6);

var _Tw2Effect = __webpack_require__(40);

var _vertex = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WebGLDebugUtil = __webpack_require__(81);

/**
 * Tw2Device
 *
 * @property {?WebGLRenderingContext|*} gl         - The device's gl context
 * @property {?number} glVersion                   - The device's gl version
 * @property {?VRDisplay} vrDisplay                - An optional VRDisplay context
 * @property {?{}} ext                             - An object containing compatibility extensions
 * @property {boolean} debugMode                   - Toggles debug mode
 * @property {number} dt                           - Clock delta time
 * @property {number} startTime                    - Clock start time
 * @property {number} currentTime                  - Clock current time
 * @property {?number} previousTime                - Clock previous time
 * @property {vec3} eyePosition                    - The device's current eye position
 * @property {vec4} targetResolution               - The device's current target resolution
 * @property {mat4} world                          - The device's current world matrix
 * @property {mat4} view                           - The device's current view matrix
 * @property {mat4} viewInverse                    - The device's current inverse view matrix
 * @property {mat4} viewTranspose                  - The device's current view matrix transposed
 * @property {mat4} projection                     - The device's current projection matrix
 * @property {mat4} projectionInverse              - The device's current inverse projection matrix
 * @property {mat4} projectionTranspose            - The device's current projection matrix transposed
 * @property {mat4} viewProjection                 - The device's current view projection matrix
 * @property {mat4} viewProjectionTranspose        - The device's current view projection matrix transposed
 * @property {?HTMLCanvasElement} canvas           - The html canvas the gl context was created from
 * @property {number} viewportWidth                - The canvas's current width
 * @property {number} viewportHeight               - The canvas's current height
 * @property {number} viewportAspect               - The canvas's current display aspect
 * @property {number} viewportPixelRatio           - The canvas's pixel ratio
 * @property {string} effectDir                    - The directory used to translate ccp effect file paths
 * @property {number} mipLevelSkipCount            - Controls what quality ccp texture resource to load (mutates paths)
 * @property {string} shaderModel                  - Controls what quality ccp effect resource to load (mutates paths)
 * @property {boolean} enableAnisotropicFiltering  - Enables anisotropic filtering
 * @property {boolean} alphaBlendBackBuffer        - Enables alpha blending (glParams.alpha)
 * @property {boolean} antialiasing                - Identifies if antialiasing is enabled
 * @property {number} msaaSamples                  - The amount of samples used for antialiasing
 * @property {number[]} wrapModes                  - texture wrap modes
 * @property {*} shadowHandles                     - unused
 * @property {Tw2PerObjectData} perObjectData      - The current frame's per object data
 * @property {?{}} _alphaBlendState                - Alpha states for blending
 * @property {?{}} _alphaTestState                 - Alpha test states
 * @property {?{}} _depthOffsetState               - Depth states
 * @property {?Array<number>} _blendTable          - Webgl blend enum table
 * @property {?Float32Array} _shadowStateBuffer    - unused
 * @property {Array<Function>} _scheduled          - Functions that are scheduled to be called per frame
 * @property {WebGLBuffer} _quadBuffer             - Webgl buffer for full screen quad
 * @property {Tw2VertexDeclaration} _quadDecl      - Quad vertex declarations
 * @property {WebGLBuffer} _cameraQuadBuffer       - Webgl buffer for camera space quad
 * @property {number} _currentRenderMode           - The device's current render mode
 * @property {WebGLTexture} _fallbackCube          - A fallback cube texture
 * @property {WebGLTexture} _fallbackTexture       - A fallback texture
 * @property {Tw2Effect} _blitEffect               - The blit effect used for rendering textures
 * @property {?Function} _onResize                 - An optional function which is called when the canvas resizes
 * @property {{}} utils                            - Webgl debug utils
 * @class
 */

var Tw2Device = exports.Tw2Device = function () {
    function Tw2Device() {
        _classCallCheck(this, Tw2Device);

        this.gl = null;
        this.glVersion = Tw2Device.WebglVersion.NONE;
        this.vrDisplay = null;
        this.ext = null;

        this.debugMode = false;

        this.dt = 0;
        this.frameCounter = 0;
        this.startTime = this.Now();
        this.currentTime = this.startTime;
        this.previousTime = null;

        this.eyePosition = _math.vec3.create();
        this.targetResolution = _math.vec4.create();
        this.world = _math.mat4.create();
        this.view = _math.mat4.create();
        this.viewInverse = _math.mat4.create();
        this.viewTranspose = _math.mat4.create();
        this.projection = _math.mat4.create();
        this.projectionInverse = _math.mat4.create();
        this.projectionTranspose = _math.mat4.create();
        this.viewProjection = _math.mat4.create();
        this.viewProjectionTranspose = _math.mat4.create();

        this.canvas = null;
        this.viewportWidth = 0;
        this.viewportHeight = 0;
        this.viewportAspect = 0;
        this.viewportPixelRatio = 'devicePixelRatio' in window ? window.devicePixelRatio : 1;

        this.effectDir = '/effect.gles2/';
        this.mipLevelSkipCount = 0;
        this.shaderModel = 'hi';
        this.enableAnisotropicFiltering = true;
        this.alphaBlendBackBuffer = true;

        this.antialiasing = true;
        this.msaaSamples = 0;
        this.wrapModes = [];
        this.shadowHandles = null;
        this.perObjectData = null;

        this._alphaBlendState = null;
        this._alphaTestState = null;
        this._depthOffsetState = null;
        this._blendTable = null;
        this._shadowStateBuffer = null;
        this._scheduled = [];
        this._quadBuffer = null;
        this._quadDecl = null;
        this._cameraQuadBuffer = null;
        this._currentRenderMode = this.RM_ANY;
        this._fallbackCube = null;
        this._fallbackTexture = null;
        this._blitEffect = null;
        this._onResize = null;

        this.utils = WebGLDebugUtil;
    }

    /**
     * Gets the current device time
     * @returns {number}
     */


    _createClass(Tw2Device, [{
        key: 'Now',
        value: function Now() {
            return this.constructor.Clock.now();
        }

        /**
         * Creates webgl Device
         * @param {HTMLCanvasElement} canvas - The html canvas to create a webgl rendering context from
         * @param {{}} [params]              - Optional gl parameters
         * @param {boolean} [params.webgl2]  - Optional flag to enable a webgl2 rendering context
         * @returns {number}                 - The webgl rendering context create (0 if failed)
         */

    }, {
        key: 'CreateDevice',
        value: function CreateDevice(canvas, params) {
            this.gl = null;
            this.glVersion = Tw2Device.WebglVersion.NONE;
            this.effectDir = '/effect.gles2/';

            // Try webgl2 if enabled
            if (params && params.webgl2) {
                this.gl = Tw2Device.CreateContext(canvas, params, Tw2Device.Webgl2ContextNames);
                if (this.gl) this.glVersion = Tw2Device.WebglVersion.WEBGL2;
            }
            // Fallback to webgl
            if (!this.gl) {
                this.gl = Tw2Device.CreateContext(canvas, params, Tw2Device.WebglContextNames);
                if (this.gl) this.glVersion = Tw2Device.WebglVersion.WEBGL;
            }

            this.ext = {
                drawElementsInstanced: function drawElementsInstanced() {
                    return false;
                },
                drawArraysInstanced: function drawArraysInstanced() {
                    return false;
                },
                vertexAttribDivisor: function vertexAttribDivisor() {
                    return false;
                },
                hasInstancedArrays: function hasInstancedArrays() {
                    return false;
                }
            };

            var gl = this.gl;

            switch (this.glVersion) {
                case Tw2Device.WebglVersion.WEBGL2:
                    this.ext = {
                        drawElementsInstanced: function drawElementsInstanced(mode, count, type, offset, instanceCount) {
                            gl.drawElementsInstanced(mode, count, type, offset, instanceCount);
                        },
                        drawArraysInstanced: function drawArraysInstanced(mode, first, count, instanceCount) {
                            gl.drawArraysInstanced(mode, first, count, instanceCount);
                        },
                        vertexAttribDivisor: function vertexAttribDivisor(location, divisor) {
                            gl.vertexAttribDivisor(location, divisor);
                        },
                        hasInstancedArrays: function hasInstancedArrays() {
                            return true;
                        }
                    };
                    break;

                case Tw2Device.WebglVersion.WEBGL:
                    this.GetExtension('OES_standard_derivatives');
                    this.GetExtension('OES_element_index_uint');
                    this.GetExtension('OES_texture_float');
                    this.GetExtension('EXT_shader_texture_lod');
                    var instancedArrays = this.GetExtension('ANGLE_instanced_arrays');
                    if (instancedArrays) {
                        this.ext = {
                            drawElementsInstanced: function drawElementsInstanced(mode, count, type, offset, instanceCount) {
                                instancedArrays['drawElementsInstancedANGLE'](mode, count, type, offset, instanceCount);
                            },
                            drawArraysInstanced: function drawArraysInstanced(mode, first, count, instanceCount) {
                                instancedArrays['drawArraysInstancedANGLE'](mode, first, count, instanceCount);
                            },
                            vertexAttribDivisor: function vertexAttribDivisor(location, divisor) {
                                instancedArrays['vertexAttribDivisorANGLE'](location, divisor);
                            },
                            hasInstancedArrays: function hasInstancedArrays() {
                                return true;
                            }
                        };
                    }
                    break;

                default:
                    return this.glVersion;
            }

            if (gl && this.debugMode) {
                this.gl = this.utils.makeDebugContext(gl);
            }

            _Tw2Logger.logger.log('webgl', {
                log: 'warn',
                type: 'Context created',
                value: this.glVersion
            });

            // Optional extensions
            this.ext.CompressedTexture = this.GetExtension('compressed_texture_s3tc');
            this.ext.AnisotropicFilter = this.GetExtension('EXT_texture_filter_anisotropic');
            if (this.ext.AnisotropicFilter) {
                this.ext.AnisotropicFilter.maxAnisotropy = gl.getParameter(this.ext.AnisotropicFilter['MAX_TEXTURE_MAX_ANISOTROPY_EXT']);
            }

            // CCP mobile shader binary (is this depreciated?)
            var shaderBinary = this.GetExtension('CCP_shader_binary');
            if (shaderBinary) {
                var renderer = gl.getParameter(this.gl.RENDERER),
                    maliVer = renderer.match(/Mali-(\w+).*/);

                if (maliVer) {
                    this.effectDir = '/effect.gles2.mali' + maliVer[1] + '/';
                    this.ext.ShaderBinary = shaderBinary;
                }
            }

            // Quality
            this.alphaBlendBackBuffer = !params || params['alpha'] === undefined || params['alpha'];
            this.msaaSamples = this.gl.getParameter(this.gl.SAMPLES);
            this.antialiasing = this.msaaSamples > 1;

            this.canvas = canvas;
            this.Resize();

            var vertices = [1.0, 1.0, 0.0, 1.0, 1.0, 1.0, -1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, 0.0, 0.0];

            this._quadBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this._quadBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            this._cameraQuadBuffer = gl.createBuffer();
            this._quadDecl = new _vertex.Tw2VertexDeclaration();
            this._quadDecl.elements.push(new _vertex.Tw2VertexElement(_vertex.Tw2VertexDeclaration.Type.POSITION, 0, gl.FLOAT, 4, 0));
            this._quadDecl.elements.push(new _vertex.Tw2VertexElement(_vertex.Tw2VertexDeclaration.Type.TEXCOORD, 0, gl.FLOAT, 2, 16));
            this._quadDecl.RebuildHash();

            this._alphaTestState = {};
            this._alphaTestState.states = {};
            this._alphaTestState.states[this.RS_ALPHATESTENABLE] = 0;
            this._alphaTestState.states[this.RS_ALPHAREF] = -1;
            this._alphaTestState.states[this.RS_ALPHAFUNC] = this.CMP_GREATER;
            this._alphaTestState.states[this.RS_CLIPPING] = 0;
            this._alphaTestState.states[this.RS_CLIPPLANEENABLE] = 0;
            this._alphaTestState.dirty = false;

            this._alphaBlendState = {};
            this._alphaBlendState.states = {};
            this._alphaBlendState.states[this.RS_SRCBLEND] = this.BLEND_SRCALPHA;
            this._alphaBlendState.states[this.RS_DESTBLEND] = this.BLEND_INVSRCALPHA;
            this._alphaBlendState.states[this.RS_BLENDOP] = this.BLENDOP_ADD;
            this._alphaBlendState.states[this.RS_SEPARATEALPHABLENDENABLE] = 0;
            this._alphaBlendState.states[this.RS_BLENDOPALPHA] = this.BLENDOP_ADD;
            this._alphaBlendState.states[this.RS_SRCBLENDALPHA] = this.BLEND_SRCALPHA;
            this._alphaBlendState.states[this.RS_DESTBLENDALPHA] = this.BLEND_INVSRCALPHA;
            this._alphaBlendState.dirty = false;

            this._depthOffsetState = {};
            this._depthOffsetState.states = {};
            this._depthOffsetState.states[this.RS_SLOPESCALEDEPTHBIAS] = 0;
            this._depthOffsetState.states[this.RS_DEPTHBIAS] = 0;
            this._depthOffsetState.dirty = false;

            this.wrapModes = [];
            this.wrapModes[0] = 0;
            this.wrapModes[1] = gl.REPEAT;
            this.wrapModes[2] = gl.MIRRORED_REPEAT;
            this.wrapModes[3] = gl.CLAMP_TO_EDGE;
            this.wrapModes[4] = gl.CLAMP_TO_EDGE;
            this.wrapModes[5] = gl.CLAMP_TO_EDGE;

            this._shadowStateBuffer = new Float32Array(24);

            // webgl to direct 3d blend table
            this._blendTable = [-1, // --
            gl.ZERO, // D3DBLEND_ZERO
            gl.ONE, // D3DBLEND_ONE
            gl.SRC_COLOR, // D3DBLEND_SRCCOLOR
            gl.ONE_MINUS_SRC_COLOR, // D3DBLEND_INVSRCCOLOR
            gl.SRC_ALPHA, // D3DBLEND_SRCALPHA
            gl.ONE_MINUS_SRC_ALPHA, // D3DBLEND_INVSRCALPHA
            gl.DST_ALPHA, // D3DBLEND_DESTALPHA
            gl.ONE_MINUS_DST_ALPHA, // D3DBLEND_INVDESTALPHA
            gl.DST_COLOR, // D3DBLEND_DESTCOLOR
            gl.ONE_MINUS_DST_COLOR, // D3DBLEND_INVDESTCOLOR
            gl.SRC_ALPHA_SATURATE, // D3DBLEND_SRCALPHASAT
            -1, // D3DBLEND_BOTHSRCALPHA
            -1, // D3DBLEND_BOTHINVSRCALPHA
            gl.CONSTANT_COLOR, // D3DBLEND_BLENDFACTOR
            gl.ONE_MINUS_CONSTANT_COLOR // D3DBLEND_INVBLENDFACTOR
            ];

            return this.glVersion;
        }

        /**
         * Schedules a function to be called per tick
         * @param {Function} func
         */

    }, {
        key: 'Schedule',
        value: function Schedule(func) {
            if (!this._scheduled.includes(func)) {
                this._scheduled.push(func);
            }
        }

        /**
         * Sets a callback which is fired on canvas resizing
         * @param {Function} func
         */

    }, {
        key: 'OnResize',
        value: function OnResize(func) {
            this._onResize = func;
        }

        /**
         * Handles resize events
         */

    }, {
        key: 'Resize',
        value: function Resize() {
            if (this.vrDisplay && this.vrDisplay['isPresenting']) {
                var leftEye = this.vrDisplay['getEyeParameters']('left'),
                    rightEye = this.vrDisplay['getEyeParameters']('right');

                this.canvas.width = Math.max(leftEye['renderWidth'], rightEye['renderWidth']) * 2;
                this.canvas.height = Math.max(rightEye['renderHeight'], rightEye['renderHeight']);
            } else {
                this.canvas.width = this.canvas.offsetWidth * this.viewportPixelRatio;
                this.canvas.height = this.canvas.offsetHeight * this.viewportPixelRatio;
            }

            this.viewportWidth = this.canvas.clientWidth;
            this.viewportHeight = this.canvas.clientHeight;
            this.viewportAspect = this.viewportWidth / this.viewportHeight;

            if (this._onResize) {
                this._onResize(this.viewportWidth, this.viewportHeight);
            }

            _Tw2Store.store.SetVariableValue('ViewportSize', [this.viewportWidth, this.viewportHeight, this.viewportWidth, this.viewportHeight]);
        }

        /**
         * Per frame Tick
         */

    }, {
        key: 'Tick',
        value: function Tick() {
            if (this.canvas.clientWidth !== this.viewportWidth || this.canvas.clientHeight !== this.viewportHeight) {
                this.Resize();
            }

            var previousTime = this.previousTime === null ? 0 : this.previousTime,
                now = this.Now();

            this.currentTime = (now - this.startTime) * 0.001;
            this.dt = this.previousTime === null ? 0 : (now - this.previousTime) * 0.001;
            this.previousTime = now;

            _Tw2Store.store.SetVariableValue('Time', [this.currentTime, this.currentTime - Math.floor(this.currentTime), this.frameCounter, previousTime]);

            _Tw2ResMan.resMan.PrepareLoop(this.dt);

            for (var i = 0; i < this._scheduled.length; ++i) {
                if (!this._scheduled[i](this.dt)) {
                    this._scheduled.splice(i, 1);
                    --i;
                }
            }

            this.frameCounter++;
        }

        /**
         * Requests an animation frame
         * @param {Function} func
         * @returns {number}
         */

    }, {
        key: 'RequestAnimationFrame',
        value: function RequestAnimationFrame(func) {
            return this.vrDisplay ? this.vrDisplay.requestAnimationFrame(func) : Tw2Device.RequestAnimationFrame(func);
        }

        /**
         * Sets World transform matrix
         * @param {mat4} matrix
         */

    }, {
        key: 'SetWorld',
        value: function SetWorld(matrix) {
            _math.mat4.copy(this.world, matrix);
            //mat4.inverse(this.worldInverse, this.world);
        }

        /**
         * Sets view matrix
         * @param {mat4} matrix
         */

    }, {
        key: 'SetView',
        value: function SetView(matrix) {
            _math.mat4.copy(this.view, matrix);
            _math.mat4.invert(this.viewInverse, this.view);
            _math.mat4.transpose(this.viewTranspose, this.view);
            _math.mat4.getTranslation(this.eyePosition, this.viewInverse);
            this.UpdateViewProjection();
        }

        /**
         * Sets projection matrix
         * @param {mat4} matrix
         * @param {boolean} [forceUpdateViewProjection]
         */

    }, {
        key: 'SetProjection',
        value: function SetProjection(matrix, forceUpdateViewProjection) {
            _math.mat4.copy(this.projection, matrix);
            _math.mat4.transpose(this.projectionTranspose, this.projection);
            _math.mat4.invert(this.projectionInverse, this.projection);
            this.GetTargetResolution(this.targetResolution);
            if (forceUpdateViewProjection) this.UpdateViewProjection();
        }

        /**
         * Updates view projection matrices
         */

    }, {
        key: 'UpdateViewProjection',
        value: function UpdateViewProjection() {
            _math.mat4.multiply(this.viewProjection, this.projection, this.view);
            _math.mat4.transpose(this.viewProjectionTranspose, this.viewProjection);
            _Tw2Store.store.SetVariableValue('ViewProjectionMat', this.viewProjection);
        }

        /**
         * Gets the device's target resolution
         * @param {vec4} out
         * @returns {vec4} out
         */

    }, {
        key: 'GetTargetResolution',
        value: function GetTargetResolution(out) {
            var aspectRatio = this.projection[0] ? this.projection[5] / this.projection[0] : 0.0;
            var aspectAdjustment = 1.0;
            if (aspectRatio > 1.6) aspectAdjustment = aspectRatio / 1.6;
            var fov = 2.0 * Math.atan(aspectAdjustment / this.projection[5]);
            out[0] = this.viewportWidth;
            out[1] = this.viewportHeight;
            out[2] = fov;
            out[3] = fov * aspectRatio;
            return out;
        }

        /**
         * GetEyePosition
         * @param {vec3} [out]
         * @return {vec3}
         */

    }, {
        key: 'GetEyePosition',
        value: function GetEyePosition(out) {
            return _math.vec3.copy(out, this.eyePosition);
        }

        /**
         * Returns whether or not Alpha Test is enabled
         * return {Boolean}
         */

    }, {
        key: 'IsAlphaTestEnabled',
        value: function IsAlphaTestEnabled() {
            return this._alphaTestState.states[this.RS_ALPHATESTENABLE];
        }

        /**
         * Checks if a frame buffer is complete
         *
         * @param frameBuffer
         * @returns {boolean}
         */

    }, {
        key: 'IsFrameBufferComplete',
        value: function IsFrameBufferComplete(frameBuffer) {
            return this.gl.checkFramebufferStatus(frameBuffer) === this.gl.FRAMEBUFFER_COMPLETE;
        }

        /**
         * Gets a gl extension
         * @param {string} extension - The gl extension name
         * @returns{*}
         */

    }, {
        key: 'GetExtension',
        value: function GetExtension(extension) {
            for (var prefix in Tw2Device.WebglVendorPrefixes) {
                if (Tw2Device.WebglVendorPrefixes.hasOwnProperty(prefix)) {
                    var ext = this.gl.getExtension(Tw2Device.WebglVendorPrefixes[prefix] + extension);
                    if (ext) return ext;
                }
            }

            return null;
        }

        /**
         * Gets a fallback texture
         * @returns {*}
         */

    }, {
        key: 'GetFallbackTexture',
        value: function GetFallbackTexture() {
            if (!this._fallbackTexture) {
                this._fallbackTexture = this.CreateSolidTexture();
            }
            return this._fallbackTexture;
        }

        /**
         * Gets a fallback cube map
         * @returns {*}
         */

    }, {
        key: 'GetFallbackCubeMap',
        value: function GetFallbackCubeMap() {
            if (!this._fallbackCube) {
                this._fallbackCube = this.CreateSolidCube();
            }
            return this._fallbackCube;
        }

        /**
         * Creates a solid colored texture
         * @param {vec4|Array} [rgba] - The colour to create, if omitted defaults to completely transparent
         * @returns {WebGLTexture}
         */

    }, {
        key: 'CreateSolidTexture',
        value: function CreateSolidTexture() {
            var rgba = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0, 0];

            var texture = this.gl.createTexture();
            this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array(rgba));
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
            this.gl.bindTexture(this.gl.TEXTURE_2D, null);
            return texture;
        }

        /**
         * Creates a solid coloured cube texture
         * @param {vec4|Array} rgba
         * @returns {WebGLTexture}
         */

    }, {
        key: 'CreateSolidCube',
        value: function CreateSolidCube() {
            var rgba = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0, 0];

            var texture = this.gl.createTexture();
            this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, texture);
            for (var j = 0; j < 6; ++j) {
                this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array(rgba));
            }
            this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
            this.gl.texParameteri(this.gl.TEXTURE_CUBE_MAP, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
            //this.gl.generateMipmap(this.gl.TEXTURE_CUBE_MAP);
            this.gl.bindTexture(this.gl.TEXTURE_CUBE_MAP, null);
            return texture;
        }

        /**
         * RenderFullScreenQuad
         * @param {Tw2Effect} effect
         * @param {string} technique - Technique name
         * @returns {boolean}
         */

    }, {
        key: 'RenderFullScreenQuad',
        value: function RenderFullScreenQuad(effect) {
            var technique = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Main';

            if (!effect || !effect.IsGood()) return false;

            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this._quadBuffer);
            for (var pass = 0; pass < effect.GetPassCount(technique); ++pass) {
                effect.ApplyPass(technique, pass);
                if (!this._quadDecl.SetDeclaration(effect.GetPassInput(technique, pass), 24)) return false;
                this.ApplyShadowState();
                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
            }
            return true;
        }

        /**
         * Renders a Texture to the screen
         * @param {WebGLTexture} texture
         * @returns {boolean}
         */

    }, {
        key: 'RenderTexture',
        value: function RenderTexture(texture) {
            if (this._blitEffect === null) {
                this._blitEffect = _Tw2Effect.Tw2Effect.create({
                    effectFilePath: 'res:/graphics/effect/managed/space/system/blit.fx',
                    textures: {
                        BlitSource: ''
                    }
                });
            }

            this._blitEffect.parameters['BlitSource'].textureRes = texture;
            return this.RenderFullScreenQuad(this._blitEffect);
        }

        /**
         * RenderCameraSpaceQuad
         * @param {Tw2Effect} effect
         * @param {string} technique - Technique name
         * @returns {boolean}
         */

    }, {
        key: 'RenderCameraSpaceQuad',
        value: function RenderCameraSpaceQuad(effect) {
            var technique = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Main';

            if (!effect || !effect.IsGood()) return false;

            var vertices = new Float32Array([1.0, 1.0, 0.0, 1.0, 1.0, 1.0, -1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, 0.0, 0.0]);

            var projInv = this.projectionInverse;
            for (var i = 0; i < 4; ++i) {
                var vec = vertices.subarray(i * 6, i * 6 + 4);
                _math.vec4.transformMat4(vec, vec, projInv);
                _math.vec3.scale(vec, vec, 1 / vec[3]);
                vec[3] = 1;
            }

            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this._cameraQuadBuffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
            for (var pass = 0; pass < effect.GetPassCount(technique); ++pass) {
                effect.ApplyPass(technique, pass);
                if (!this._quadDecl.SetDeclaration(effect.GetPassInput(technique, pass), 24)) return false;
                this.ApplyShadowState();
                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
            }
            return true;
        }

        /**
         * Set a render state
         * @param state
         * @param value
         */

    }, {
        key: 'SetRenderState',
        value: function SetRenderState(state, value) {
            this._currentRenderMode = this.RM_ANY;
            var gl = this.gl;

            switch (state) {
                case this.RS_ZENABLE:
                    if (value) {
                        gl.enable(gl.DEPTH_TEST);
                    } else {
                        gl.disable(gl.DEPTH_TEST);
                    }
                    return;

                case this.RS_ZWRITEENABLE:
                    gl.depthMask(!!value);
                    return;

                case this.RS_ALPHATESTENABLE:
                case this.RS_ALPHAREF:
                case this.RS_ALPHAFUNC:
                case this.RS_CLIPPING:
                case this.RS_CLIPPLANEENABLE:
                    if (this._alphaTestState[state] !== value) {
                        this._alphaTestState.states[state] = value;
                        this._alphaTestState.dirty = true;
                    }
                    return;

                case this.RS_SRCBLEND:
                case this.RS_DESTBLEND:
                case this.RS_BLENDOP:
                case this.RS_SEPARATEALPHABLENDENABLE:
                case this.RS_BLENDOPALPHA:
                case this.RS_SRCBLENDALPHA:
                case this.RS_DESTBLENDALPHA:
                    if (this._alphaBlendState[state] !== value) {
                        this._alphaBlendState.states[state] = value;
                        this._alphaBlendState.dirty = true;
                    }
                    return;

                case this.RS_CULLMODE:
                    switch (value) {
                        case this.CULL_NONE:
                            gl.disable(gl.CULL_FACE);
                            return;

                        case this.CULL_CW:
                            gl.enable(gl.CULL_FACE);
                            gl.cullFace(gl.FRONT);
                            return;

                        case this.CULL_CCW:
                            gl.enable(gl.CULL_FACE);
                            gl.cullFace(gl.BACK);
                            return;
                    }
                    return;

                case this.RS_ZFUNC:
                    gl.depthFunc(0x0200 + value - 1);
                    return;

                case this.RS_ALPHABLENDENABLE:
                    if (value) gl.enable(gl.BLEND);else gl.disable(gl.BLEND);
                    return;

                case this.RS_COLORWRITEENABLE:
                    gl.colorMask((value & 1) !== 0, (value & 2) !== 0, (value & 4) !== 0, (value & 8) !== 0);
                    return;

                case this.RS_SCISSORTESTENABLE:
                    if (value) gl.enable(gl.SCISSOR_TEST);else gl.disable(gl.SCISSOR_TEST);
                    return;

                case this.RS_SLOPESCALEDEPTHBIAS:
                case this.RS_DEPTHBIAS:
                    value = Tw2Device.DwordToFloat(value);
                    if (this._depthOffsetState[state] !== value) {
                        this._depthOffsetState.states[state] = value;
                        this._depthOffsetState.dirty = true;
                    }
                    return;
            }
        }

        /**
         * ApplyShadowState
         */

    }, {
        key: 'ApplyShadowState',
        value: function ApplyShadowState() {
            if (this._alphaBlendState.dirty) {
                var blendOp = this.gl.FUNC_ADD;
                if (this._alphaBlendState.states[this.RS_BLENDOP] === this.BLENDOP_SUBTRACT) {
                    blendOp = this.gl.FUNC_SUBTRACT;
                } else if (this._alphaBlendState.states[this.RS_BLENDOP] === this.BLENDOP_REVSUBTRACT) {
                    blendOp = this.gl.FUNC_REVERSE_SUBTRACT;
                }

                var srcBlend = this._blendTable[this._alphaBlendState.states[this.RS_SRCBLEND]],
                    destBlend = this._blendTable[this._alphaBlendState.states[this.RS_DESTBLEND]];

                if (this._alphaBlendState.states[this.RS_SEPARATEALPHABLENDENABLE]) {
                    var blendOpAlpha = this.gl.FUNC_ADD;
                    if (this._alphaBlendState.states[this.RS_BLENDOP] === this.BLENDOP_SUBTRACT) {
                        blendOpAlpha = this.gl.FUNC_SUBTRACT;
                    } else if (this._alphaBlendState.states[this.RS_BLENDOP] === this.BLENDOP_REVSUBTRACT) {
                        blendOpAlpha = this.gl.FUNC_REVERSE_SUBTRACT;
                    }

                    var srcBlendAlpha = this._blendTable[this._alphaBlendState.states[this.RS_SRCBLENDALPHA]],
                        destBlendAlpha = this._blendTable[this._alphaBlendState.states[this.RS_DESTBLENDALPHA]];

                    this.gl.blendEquationSeparate(blendOp, blendOpAlpha);
                    this.gl.blendFuncSeparate(srcBlend, destBlend, srcBlendAlpha, destBlendAlpha);
                } else {
                    this.gl.blendEquation(blendOp);
                    this.gl.blendFunc(srcBlend, destBlend);
                }
                this._alphaBlendState.dirty = false;
            }

            if (this._depthOffsetState.dirty) {
                this.gl.polygonOffset(this._depthOffsetState.states[this.RS_SLOPESCALEDEPTHBIAS], this._depthOffsetState.states[this.RS_DEPTHBIAS]);
                this._depthOffsetState.dirty = false;
            }

            var alphaTestFunc = void 0,
                invertedAlphaTest = void 0,
                alphaTestRef = void 0;

            if (this.shadowHandles && this._alphaTestState.states[this.RS_ALPHATESTENABLE]) {
                switch (this._alphaTestState.states[this.RS_ALPHAFUNC]) {
                    case this.CMP_NEVER:
                        alphaTestFunc = 0;
                        invertedAlphaTest = 1;
                        alphaTestRef = -256;
                        break;

                    case this.CMP_LESS:
                        alphaTestFunc = 0;
                        invertedAlphaTest = -1;
                        alphaTestRef = this._alphaTestState.states[this.RS_ALPHAREF] - 1;
                        break;

                    case this.CMP_EQUAL:
                        alphaTestFunc = 1;
                        invertedAlphaTest = 0;
                        alphaTestRef = this._alphaTestState.states[this.RS_ALPHAREF];
                        break;

                    case this.CMP_LEQUAL:
                        alphaTestFunc = 0;
                        invertedAlphaTest = -1;
                        alphaTestRef = this._alphaTestState.states[this.RS_ALPHAREF];
                        break;

                    case this.CMP_GREATER:
                        alphaTestFunc = 0;
                        invertedAlphaTest = 1;
                        alphaTestRef = -this._alphaTestState.states[this.RS_ALPHAREF] - 1;
                        break;

                    /*case this.CMP_NOTEQUAL:
                     var alphaTestFunc = 1;
                     var invertedAlphaTest = 1;
                     var alphaTestRef = this._alphaTestState.states[this.RS_ALPHAREF];
                     break;*/

                    case this.CMP_GREATEREQUAL:
                        alphaTestFunc = 0;
                        invertedAlphaTest = 1;
                        alphaTestRef = -this._alphaTestState.states[this.RS_ALPHAREF];
                        break;

                    default:
                        alphaTestFunc = 0;
                        invertedAlphaTest = 0;
                        alphaTestRef = 1;
                        break;
                }

                var clipPlaneEnable = 0;
                this.gl.uniform4f(this.shadowHandles.shadowStateInt, invertedAlphaTest, alphaTestRef, alphaTestFunc, clipPlaneEnable);
                //this._shadowStateBuffers
            }
        }

        /**
         * Sets a render mode
         * @param {number} renderMode
         */

    }, {
        key: 'SetStandardStates',
        value: function SetStandardStates(renderMode) {
            if (this._currentRenderMode === renderMode) return;

            this.gl.frontFace(this.gl.CW);
            switch (renderMode) {
                case this.RM_OPAQUE:
                case this.RM_PICKABLE:
                    this.SetRenderState(this.RS_ZENABLE, true);
                    this.SetRenderState(this.RS_ZWRITEENABLE, true);
                    this.SetRenderState(this.RS_ZFUNC, this.CMP_LEQUAL);
                    this.SetRenderState(this.RS_CULLMODE, this.CULL_CW);
                    this.SetRenderState(this.RS_ALPHABLENDENABLE, false);
                    this.SetRenderState(this.RS_ALPHATESTENABLE, false);
                    this.SetRenderState(this.RS_SEPARATEALPHABLENDENABLE, false);
                    this.SetRenderState(this.RS_SLOPESCALEDEPTHBIAS, 0);
                    this.SetRenderState(this.RS_DEPTHBIAS, 0);
                    this.SetRenderState(this.RS_COLORWRITEENABLE, 0xf);
                    break;

                case this.RM_DECAL:
                    this.SetRenderState(this.RS_ALPHABLENDENABLE, false);
                    this.SetRenderState(this.RS_ALPHATESTENABLE, true);
                    this.SetRenderState(this.RS_ALPHAFUNC, this.CMP_GREATER);
                    this.SetRenderState(this.RS_ALPHAREF, 127);
                    this.SetRenderState(this.RS_ZENABLE, true);
                    this.SetRenderState(this.RS_ZWRITEENABLE, true);
                    this.SetRenderState(this.RS_ZFUNC, this.CMP_LEQUAL);
                    this.SetRenderState(this.RS_CULLMODE, this.CULL_CW);
                    this.SetRenderState(this.RS_BLENDOP, this.BLENDOP_ADD);
                    this.SetRenderState(this.RS_SLOPESCALEDEPTHBIAS, 0);
                    this.SetRenderState(this.RS_DEPTHBIAS, 0);
                    this.SetRenderState(this.RS_SEPARATEALPHABLENDENABLE, false);
                    this.SetRenderState(this.RS_COLORWRITEENABLE, 0xf);
                    break;

                case this.RM_TRANSPARENT:
                    this.SetRenderState(this.RS_CULLMODE, this.CULL_CW);
                    this.SetRenderState(this.RS_ALPHABLENDENABLE, true);
                    this.SetRenderState(this.RS_SRCBLEND, this.BLEND_SRCALPHA);
                    this.SetRenderState(this.RS_DESTBLEND, this.BLEND_INVSRCALPHA);
                    this.SetRenderState(this.RS_BLENDOP, this.BLENDOP_ADD);
                    this.SetRenderState(this.RS_ZENABLE, true);
                    this.SetRenderState(this.RS_ZWRITEENABLE, false);
                    this.SetRenderState(this.RS_ZFUNC, this.CMP_LEQUAL);
                    this.SetRenderState(this.RS_ALPHATESTENABLE, false);
                    this.SetRenderState(this.RS_SLOPESCALEDEPTHBIAS, 0); // -1.0
                    this.SetRenderState(this.RS_DEPTHBIAS, 0);
                    this.SetRenderState(this.RS_SEPARATEALPHABLENDENABLE, false);
                    this.SetRenderState(this.RS_COLORWRITEENABLE, 0xf);
                    break;

                case this.RM_ADDITIVE:
                    this.SetRenderState(this.RS_CULLMODE, this.CULL_NONE);
                    this.SetRenderState(this.RS_ALPHABLENDENABLE, true);
                    this.SetRenderState(this.RS_SRCBLEND, this.BLEND_ONE);
                    this.SetRenderState(this.RS_DESTBLEND, this.BLEND_ONE);
                    this.SetRenderState(this.RS_BLENDOP, this.BLENDOP_ADD);
                    this.SetRenderState(this.RS_ZENABLE, true);
                    this.SetRenderState(this.RS_ZWRITEENABLE, false);
                    this.SetRenderState(this.RS_ZFUNC, this.CMP_LEQUAL);
                    this.SetRenderState(this.RS_ALPHATESTENABLE, false);
                    this.SetRenderState(this.RS_SLOPESCALEDEPTHBIAS, 0);
                    this.SetRenderState(this.RS_DEPTHBIAS, 0);
                    this.SetRenderState(this.RS_SEPARATEALPHABLENDENABLE, false);
                    this.SetRenderState(this.RS_COLORWRITEENABLE, 0xf);
                    break;

                case this.RM_FULLSCREEN:
                    this.SetRenderState(this.RS_ALPHABLENDENABLE, false);
                    this.SetRenderState(this.RS_ALPHATESTENABLE, false);
                    this.SetRenderState(this.RS_CULLMODE, this.CULL_NONE);
                    this.SetRenderState(this.RS_ZENABLE, false);
                    this.SetRenderState(this.RS_ZWRITEENABLE, false);
                    this.SetRenderState(this.RS_ZFUNC, this.CMP_ALWAYS);
                    this.SetRenderState(this.RS_SLOPESCALEDEPTHBIAS, 0);
                    this.SetRenderState(this.RS_DEPTHBIAS, 0);
                    this.SetRenderState(this.RS_SEPARATEALPHABLENDENABLE, false);
                    this.SetRenderState(this.RS_COLORWRITEENABLE, 0xf);
                    break;

                default:
                    return;
            }

            this._currentRenderMode = renderMode;
        }

        /**
         * Converts a Dword to Float
         * @param value
         * @return {Number}
         */

    }], [{
        key: 'DwordToFloat',
        value: function DwordToFloat(value) {
            var b4 = value & 0xff,
                b3 = (value & 0xff00) >> 8,
                b2 = (value & 0xff0000) >> 16,
                b1 = (value & 0xff000000) >> 24,
                sign = 1 - 2 * (b1 >> 7),
                // sign = bit 0
            exp = (b1 << 1 & 0xff | b2 >> 7) - 127,
                // exponent = bits 1..8
            sig = (b2 & 0x7f) << 16 | b3 << 8 | b4; // significand = bits 9..31

            if (sig === 0 && exp === -127) return 0.0;
            return sign * (1 + sig * Math.pow(2, -23)) * Math.pow(2, exp);
        }

        /**
         * Creates a gl context
         *
         * @param {HTMLCanvasElement} canvas
         * @param {*} [params]
         * @param {*} [contextNames]
         * @returns {*}
         */

    }, {
        key: 'CreateContext',
        value: function CreateContext(canvas, params, contextNames) {
            contextNames = Array.isArray(contextNames) ? contextNames : [contextNames];
            for (var i = 0; i < contextNames.length; i++) {
                try {
                    return canvas.getContext(contextNames[i], params);
                } catch (err) {
                    /* eslint-disable-line no-empty */
                }
            }
            return null;
        }
    }]);

    return Tw2Device;
}();

/**
 * The constructor used to generate the time
 * @type {DateConstructor}
 */


Tw2Device.Clock = Date;

var timeOuts = void 0;

/**
 * Requests and animation frame
 * @param {Function} callback
 * @returns {number} id
 */
Tw2Device.RequestAnimationFrame = function () {
    var requestFrame = window['requestAnimationFrame'] || window['webkitRequestAnimationFrame'] || window['mozRequestAnimationFrame'] || window['oRequestAnimationFrame'] || window['msRequestAnimationFrame'] || function (callback) {
        if (!timeOuts) timeOuts = [];
        timeOuts.push(window.setTimeout(callback, 1000 / 60));
        return timeOuts.length - 1;
    };

    return function RequestAnimationFrame(callback) {
        return requestFrame(callback);
    };
}();

/**
 * Cancels an animation frame by it's id
 * @param {number} id
 */
Tw2Device.CancelAnimationFrame = function () {
    var cancelFrame = window['cancelAnimationFrame'] || window['webkitRequestAnimationFrame'] || window['mozRequestAnimationFrame'] || window['oRequestAnimationFrame'] || window['msRequestAnimationFrame'] || function (id) {
        if (!timeOuts) timeOuts = [];
        if (timeOuts[id] !== undefined) {
            window.clearTimeout(timeOuts[id]);
            timeOuts[id] = undefined;
            return true;
        }
    };

    return function CancelAnimationFrame(id) {
        cancelFrame(id);
    };
}();

// Webgl details
Tw2Device.WebglVendorPrefixes = ['', 'MOZ_', 'WEBKIT_', 'WEBGL_'];
Tw2Device.WebglContextNames = ['webgl', 'experimental-webgl'];
Tw2Device.Webgl2ContextNames = ['webgl2', 'experimental-webgl2'];
Tw2Device.WebglVersion = {
    NONE: 0,
    WEBGL: 1,
    WEBGL2: 2
};

// Render Modes
Tw2Device.prototype.RM_ANY = -1;
Tw2Device.prototype.RM_OPAQUE = 0;
Tw2Device.prototype.RM_DECAL = 1;
Tw2Device.prototype.RM_TRANSPARENT = 2;
Tw2Device.prototype.RM_ADDITIVE = 3;
Tw2Device.prototype.RM_DEPTH = 4;
Tw2Device.prototype.RM_FULLSCREEN = 5;
Tw2Device.prototype.RM_PICKABLE = 6;

// Render States
Tw2Device.prototype.RS_ZENABLE = 7; // D3DZBUFFERTYPE (or TRUE/FALSE for legacy)
Tw2Device.prototype.RS_FILLMODE = 8; // D3DFILLMODE
Tw2Device.prototype.RS_SHADEMODE = 9; // D3DSHADEMODE
Tw2Device.prototype.RS_ZWRITEENABLE = 14; // TRUE to enable z writes
Tw2Device.prototype.RS_ALPHATESTENABLE = 15; // TRUE to enable alpha tests
Tw2Device.prototype.RS_LASTPIXEL = 16; // TRUE for last-pixel on lines
Tw2Device.prototype.RS_SRCBLEND = 19; // D3DBLEND
Tw2Device.prototype.RS_DESTBLEND = 20; // D3DBLEND
Tw2Device.prototype.RS_CULLMODE = 22; // D3DCULL
Tw2Device.prototype.RS_ZFUNC = 23; // D3DCMPFUNC
Tw2Device.prototype.RS_ALPHAREF = 24; // D3DFIXED
Tw2Device.prototype.RS_ALPHAFUNC = 25; // D3DCMPFUNC
Tw2Device.prototype.RS_DITHERENABLE = 26; // TRUE to enable dithering
Tw2Device.prototype.RS_ALPHABLENDENABLE = 27; // TRUE to enable alpha blending
Tw2Device.prototype.RS_FOGENABLE = 28; // TRUE to enable fog blending
Tw2Device.prototype.RS_SPECULARENABLE = 29; // TRUE to enable specular
Tw2Device.prototype.RS_FOGCOLOR = 34; // D3DCOLOR
Tw2Device.prototype.RS_FOGTABLEMODE = 35; // D3DFOGMODE
Tw2Device.prototype.RS_FOGSTART = 36; // Fog start (for both vertex and pixel fog)
Tw2Device.prototype.RS_FOGEND = 37; // Fog end
Tw2Device.prototype.RS_FOGDENSITY = 38; // Fog density
Tw2Device.prototype.RS_RANGEFOGENABLE = 48; // Enables range-based fog
Tw2Device.prototype.RS_STENCILENABLE = 52; // BOOL enable/disable stenciling
Tw2Device.prototype.RS_STENCILFAIL = 53; // D3DSTENCILOP to do if stencil test fails
Tw2Device.prototype.RS_STENCILZFAIL = 54; // D3DSTENCILOP to do if stencil test passes and Z test fails
Tw2Device.prototype.RS_STENCILPASS = 55; // D3DSTENCILOP to do if both stencil and Z tests pass
Tw2Device.prototype.RS_STENCILFUNC = 56; // D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true
Tw2Device.prototype.RS_STENCILREF = 57; // Reference value used in stencil test
Tw2Device.prototype.RS_STENCILMASK = 58; // Mask value used in stencil test
Tw2Device.prototype.RS_STENCILWRITEMASK = 59; // Write mask applied to values written to stencil buffer
Tw2Device.prototype.RS_TEXTUREFACTOR = 60; // D3DCOLOR used for multi-texture blend
Tw2Device.prototype.RS_WRAP0 = 128; // wrap for 1st texture coord. set
Tw2Device.prototype.RS_WRAP1 = 129; // wrap for 2nd texture coord. set
Tw2Device.prototype.RS_WRAP2 = 130; // wrap for 3rd texture coord. set
Tw2Device.prototype.RS_WRAP3 = 131; // wrap for 4th texture coord. set
Tw2Device.prototype.RS_WRAP4 = 132; // wrap for 5th texture coord. set
Tw2Device.prototype.RS_WRAP5 = 133; // wrap for 6th texture coord. set
Tw2Device.prototype.RS_WRAP6 = 134; // wrap for 7th texture coord. set
Tw2Device.prototype.RS_WRAP7 = 135; // wrap for 8th texture coord. set
Tw2Device.prototype.RS_CLIPPING = 136;
Tw2Device.prototype.RS_LIGHTING = 137;
Tw2Device.prototype.RS_AMBIENT = 139;
Tw2Device.prototype.RS_FOGVERTEXMODE = 140;
Tw2Device.prototype.RS_COLORVERTEX = 141;
Tw2Device.prototype.RS_LOCALVIEWER = 142;
Tw2Device.prototype.RS_NORMALIZENORMALS = 143;
Tw2Device.prototype.RS_DIFFUSEMATERIALSOURCE = 145;
Tw2Device.prototype.RS_SPECULARMATERIALSOURCE = 146;
Tw2Device.prototype.RS_AMBIENTMATERIALSOURCE = 147;
Tw2Device.prototype.RS_EMISSIVEMATERIALSOURCE = 148;
Tw2Device.prototype.RS_VERTEXBLEND = 151;
Tw2Device.prototype.RS_CLIPPLANEENABLE = 152;
Tw2Device.prototype.RS_POINTSIZE = 154; // float point size
Tw2Device.prototype.RS_POINTSIZE_MIN = 155; // float point size min threshold
Tw2Device.prototype.RS_POINTSPRITEENABLE = 156; // BOOL point texture coord control
Tw2Device.prototype.RS_POINTSCALEENABLE = 157; // BOOL point size scale enable
Tw2Device.prototype.RS_POINTSCALE_A = 158; // float point attenuation A value
Tw2Device.prototype.RS_POINTSCALE_B = 159; // float point attenuation B value
Tw2Device.prototype.RS_POINTSCALE_C = 160; // float point attenuation C value
Tw2Device.prototype.RS_MULTISAMPLEANTIALIAS = 161; // BOOL - set to do FSAA with multisample buffer
Tw2Device.prototype.RS_MULTISAMPLEMASK = 162; // DWORD - per-sample enable/disable
Tw2Device.prototype.RS_PATCHEDGESTYLE = 163; // Sets whether patch edges will use float style tessellation
Tw2Device.prototype.RS_DEBUGMONITORTOKEN = 165; // DEBUG ONLY - token to debug monitor
Tw2Device.prototype.RS_POINTSIZE_MAX = 166;
// float point size max threshold
Tw2Device.prototype.RS_INDEXEDVERTEXBLENDENABLE = 167;
Tw2Device.prototype.RS_COLORWRITEENABLE = 168; // per-channel write enable
Tw2Device.prototype.RS_TWEENFACTOR = 170; // float tween factor
Tw2Device.prototype.RS_BLENDOP = 171; // D3DBLENDOP setting
Tw2Device.prototype.RS_POSITIONDEGREE = 172; // NPatch position interpolation degree. D3DDEGREE_LINEAR or D3DDEGREE_CUBIC (default)
Tw2Device.prototype.RS_NORMALDEGREE = 173; // NPatch normal interpolation degree. D3DDEGREE_LINEAR (default) or D3DDEGREE_QUADRATIC
Tw2Device.prototype.RS_SCISSORTESTENABLE = 174;
Tw2Device.prototype.RS_SLOPESCALEDEPTHBIAS = 175;
Tw2Device.prototype.RS_ANTIALIASEDLINEENABLE = 176;
Tw2Device.prototype.RS_TWOSIDEDSTENCILMODE = 185; // BOOL enable/disable 2 sided stenciling
Tw2Device.prototype.RS_CCW_STENCILFAIL = 186; // D3DSTENCILOP to do if ccw stencil test fails
Tw2Device.prototype.RS_CCW_STENCILZFAIL = 187; // D3DSTENCILOP to do if ccw stencil test passes and Z test fails
Tw2Device.prototype.RS_CCW_STENCILPASS = 188; // D3DSTENCILOP to do if both ccw stencil and Z tests pass
Tw2Device.prototype.RS_CCW_STENCILFUNC = 189; // D3DCMPFUNC fn.  ccw Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true
Tw2Device.prototype.RS_COLORWRITEENABLE1 = 190; // Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS
Tw2Device.prototype.RS_COLORWRITEENABLE2 = 191; // Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS
Tw2Device.prototype.RS_COLORWRITEENABLE3 = 192; // Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS
Tw2Device.prototype.RS_BLENDFACTOR = 193; // D3DCOLOR used for a constant blend factor during alpha blending for devices that support D3DPBLENDCAPS_BLENDFACTOR
Tw2Device.prototype.RS_SRGBWRITEENABLE = 194; // Enable rendertarget writes to be DE-linearized to SRGB (for formats that expose D3DUSAGE_QUERY_SRGBWRITE)
Tw2Device.prototype.RS_DEPTHBIAS = 195;
Tw2Device.prototype.RS_SEPARATEALPHABLENDENABLE = 206; // TRUE to enable a separate blending function for the alpha channel
Tw2Device.prototype.RS_SRCBLENDALPHA = 207; // SRC blend factor for the alpha channel when RS_SEPARATEDESTALPHAENABLE is TRUE
Tw2Device.prototype.RS_DESTBLENDALPHA = 208; // DST blend factor for the alpha channel when RS_SEPARATEDESTALPHAENABLE is TRUE
Tw2Device.prototype.RS_BLENDOPALPHA = 209; // Blending operation for the alpha channel when RS_SEPARATEDESTALPHAENABLE is TRUE */// Cull Modes
Tw2Device.prototype.CULL_NONE = 1;
Tw2Device.prototype.CULL_CW = 2;
Tw2Device.prototype.CULL_CCW = 3;
// Compare
Tw2Device.prototype.CMP_NEVER = 1;
Tw2Device.prototype.CMP_LESS = 2;
Tw2Device.prototype.CMP_EQUAL = 3;
Tw2Device.prototype.CMP_LEQUAL = 4;
Tw2Device.prototype.CMP_GREATER = 5;
Tw2Device.prototype.CMP_NOTEQUAL = 6;
Tw2Device.prototype.CMP_GREATEREQUAL = 7;
Tw2Device.prototype.CMP_ALWAYS = 8;
// Blend
Tw2Device.prototype.BLEND_ZERO = 1;
Tw2Device.prototype.BLEND_ONE = 2;
Tw2Device.prototype.BLEND_SRCCOLOR = 3;
Tw2Device.prototype.BLEND_INVSRCCOLOR = 4;
Tw2Device.prototype.BLEND_SRCALPHA = 5;
Tw2Device.prototype.BLEND_INVSRCALPHA = 6;
Tw2Device.prototype.BLEND_DESTALPHA = 7;
Tw2Device.prototype.BLEND_INVDESTALPHA = 8;
Tw2Device.prototype.BLEND_DESTCOLOR = 9;
Tw2Device.prototype.BLEND_INVDESTCOLOR = 10;
Tw2Device.prototype.BLEND_SRCALPHASAT = 11;
Tw2Device.prototype.BLEND_BOTHSRCALPHA = 12;
Tw2Device.prototype.BLEND_BOTHINVSRCALPHA = 13;
Tw2Device.prototype.BLEND_BLENDFACTOR = 14;
Tw2Device.prototype.BLEND_INVBLENDFACTOR = 15;
// Blend Operations
Tw2Device.prototype.BLENDOP_ADD = 1;
Tw2Device.prototype.BLENDOP_SUBTRACT = 2;
Tw2Device.prototype.BLENDOP_REVSUBTRACT = 3;
Tw2Device.prototype.BLENDOP_MIN = 4;
Tw2Device.prototype.BLENDOP_MAX = 5;

var device = exports.device = new Tw2Device();

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2Curve = exports.Tw2CurveKey = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /* eslint no-unused-vars:0 */


/**
 * Tw2CurveKey base class
 *
 * @property {number|string} id
 * @property {string} name
 * @property {number} time
 * @class
 */
var Tw2CurveKey = exports.Tw2CurveKey = function Tw2CurveKey() {
  _classCallCheck(this, Tw2CurveKey);

  this._id = _math.util.generateID();
  this.name = '';
  this.time = 0;
};

/**
 * Tw2Curve base class
 *
 * @property {number|string} id
 * @property {string} name
 * @class
 */


var Tw2Curve = exports.Tw2Curve = function () {
  function Tw2Curve() {
    _classCallCheck(this, Tw2Curve);

    this._id = _math.util.generateID();
    this.name = '';
  }

  /**
   * Initializes the Curve
   */


  _createClass(Tw2Curve, [{
    key: 'Initialize',
    value: function Initialize() {
      this.Sort();
    }

    /**
     * Sorts the curve
     */

  }, {
    key: 'Sort',
    value: function Sort() {}

    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: 'GetLength',
    value: function GetLength() {
      return 0;
    }

    /**
     * Updates the current value at the given time
     * @param {number} time
     */

  }, {
    key: 'UpdateValue',
    value: function UpdateValue(time) {}

    /**
     * Compares curve keys
     * @param {Tw2CurveKey} a
     * @param {Tw2CurveKey} b
     * @returns {number}
     */

  }], [{
    key: 'Compare',
    value: function Compare(a, b) {
      if (a.time < b.time) return -1;
      if (a.time > b.time) return 1;
      return 0;
    }

    /**
     * Sorts legacy curve keys
     * @param {*} curve
     * @param {Array.<Tw2CurveKey>} [keys=curve.keys] - Optional keys override
     */

  }, {
    key: 'Sort',
    value: function Sort(curve) {
      var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : curve.keys;

      if (keys && keys.length) {
        keys.sort(Tw2Curve.Compare);
        curve.length = keys[keys.length - 1].time;
      }
    }

    /**
     * Sorts curve keys
     * @param {*} curve
     */

  }, {
    key: 'Sort2',
    value: function Sort2(curve) {
      if (curve.keys && curve.keys.length) {
        curve.keys.sort(Tw2Curve.Compare);
        var back = curve.keys[curve.keys.length - 1];

        if (back.time > curve.length) {
          var preLength = curve.length,
              endValue = curve.endValue,
              endTangent = curve.endTangent;

          curve.length = back.time;
          curve.endValue = back.value;
          curve.endTangent = back.leftTangent;

          if (preLength > 0) {
            back.time = preLength;
            back.value = endValue;
            back.leftTangent = endTangent;
          }
        }
      }
    }
  }]);

  return Tw2Curve;
}();

/**
 * The curve's key dimension
 * @type {?number}
 */


Tw2Curve.inputDimension = null;

/**
 * The curve's dimension
 * @type {?number}
 */
Tw2Curve.outputDimension = null;

/**
 * The curve's current value property
 * @type {?string}
 */
Tw2Curve.valueProperty = null;

/**
 * The curve's type
 * @type {?number}
 */
Tw2Curve.curveType = null;

/**
 * The curve's Key constructor
 * @type {?Tw2CurveKey}
 */
Tw2Curve.Key = null;

/**
 * Interpolation types
 * @type {?{ string: number}}
 */
Tw2Curve.Interpolation = null;

/**
 * Extrapolation types
 * @type {?{ string: number}}
 */
Tw2Curve.Extrapolation = null;

/**
 * Curve types
 * @type {{CURVE: number, CURVE2: number, CURVE_MAYA: number, SEQUENCER: number, SEQUENCER2: number}}
 */
Tw2Curve.Type = {
  CURVE: 1,
  CURVE2: 2,
  CURVE_MAYA: 3,
  CURVE_NO_KEYS: 4,
  SEQUENCER: 100,
  SEQUENCER2: 101
};

/**
 * Class globals
 * @type {*}
 */
Tw2Curve.global = {
  vec3_0: _math.vec3.create(),
  vec4_0: _math.vec4.create(),
  quat_0: _math.quat.create(),
  quat_1: _math.quat.create()
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.logger = exports.Tw2Logger = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2EventEmitter2 = __webpack_require__(36);

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Event log
 * @typedef {*} eventLog
 * @property {string} log       - Desired console output type
 * @property {string} msg       - A message to log
 * @property {string} path      - An optional resource path
 * @property {number} time      - An optional time
 * @property {string} type      - The type of log
 * @property {*} value          - An optional value
 * @property {*} data           - An optional values object
 * @property {Error} err        - An optional caught error
 * @property {boolean} hide     - True to skip console output
 * @property {boolean} logged   - Identifies if the log has been logged
 */

/**
 * Handles basic event logging
 *
 * @param {string} [name='']          - The logger's name
 * @property {string} name            - The name of the logger and it's prefix
 * @property {{}} visible             - Visibility options
 * @property {boolean} visible.log    - Toggles console log output
 * @property {boolean} visible.info   - Toggles console info output
 * @property {boolean} visible.debug  - Toggles console debug output
 * @property {boolean} visible.warn   - Toggles console warn output
 * @property {boolean} visible.error  - Toggles console error output
 * @property {number} maxLogs         - The maximum logs that will be stored
 * @property {boolean} display        - Enabled console logging
 * @property {Array} _logs            - Stored logs
 * @property {?Function} _onNewLog    - On new log
 */
var Tw2Logger = function (_Tw2EventEmitter) {
    _inherits(Tw2Logger, _Tw2EventEmitter);

    function Tw2Logger() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        _classCallCheck(this, Tw2Logger);

        var _this = _possibleConstructorReturn(this, (Tw2Logger.__proto__ || Object.getPrototypeOf(Tw2Logger)).call(this));

        _this.name = name;
        _this.display = true;
        _this.visible = {};
        _this.visible.log = true;
        _this.visible.info = true;
        _this.visible.debug = true;
        _this.visible.warn = true;
        _this.visible.error = true;
        _this.maxLogs = 100;
        _this._logs = [];
        return _this;
    }

    /**
     * Adds an event log and outputs it to the console
     * @param {string} eventName
     * @param {eventLog} log
     * @returns {eventLog} log
     */


    _createClass(Tw2Logger, [{
        key: 'log',
        value: function log(eventName, _log) {
            _log.log = Tw2Logger.Type[_log.log ? _log.log.toUpperCase() : 'LOG'] || 'log';

            if (!_log.hide && this.display && this.visible[_log.log]) {
                var header = this.name + ': {' + eventName + '}';
                var body = _log.msg || '';

                if (_log.path) {
                    body += ' \'' + _log.path + '\'';
                    if ('time' in _log) body += ' in ' + _log.time.toFixed(3) + ' secs';
                }

                if (_log.value !== undefined || _log.type) {
                    body += ' (';
                    if (_log.type) body += _log.type;
                    if (_log.type && _log.value !== undefined) body += ':';
                    if (_log.value !== undefined) body += _log.value;
                    body += ')';
                }

                if ('data' in _log || 'err' in _log) {
                    console.group(header);
                    console[_log.log](body);
                    if (_log.data) console.debug(_log.data);
                    if (_log.err) console.debug(_log.err.stack || _log.err.toString());
                    console.groupEnd();
                } else {
                    console[_log.log](header, body);
                }
            }

            if (this.maxLogs) {
                if (this._logs.length >= this.maxLogs) {
                    this._logs.splice(this.maxLogs, this._logs.length - 1);
                }
                this._logs.unshift(_log);
            } else {
                this._logs = [];
            }

            this.emit('log', _log);
            return _log;
        }

        /**
         * Gets an array of logs
         * @param {number} [count]
         * @returns {Array<eventLog>}
         */

    }, {
        key: 'GetLogs',
        value: function GetLogs(count) {
            return Object.assign([], count === undefined ? this._logs : this._logs.splice(0, count));
        }

        /**
         * Sets the logger's properties
         * @param {*} [opt={}]
         */

    }, {
        key: 'Set',
        value: function Set() {
            var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            _math.util.assignIfExists(this, opt, ['name', 'maxLogs', 'display']);
            _math.util.assignIfExists(this.visible, opt.visible, ['log', 'info', 'debug', 'warn', 'error']);
        }
    }]);

    return Tw2Logger;
}(_Tw2EventEmitter2.Tw2EventEmitter);

/**
 * Console outputs
 * @type {{THROW: string, ERROR: string, WARNING: string, WARN: string, INFO: string, LOG: string, DEBUG: string}}
 */


exports.Tw2Logger = Tw2Logger;
Tw2Logger.Type = {
    THROW: 'error',
    ERROR: 'error',
    WARNING: 'warn',
    WARN: 'warn',
    INFO: 'info',
    LOG: 'log',
    DEBUG: 'debug'
};

var logger = exports.logger = new Tw2Logger('CCPWGL');

/**
 * The default event logger logger
 * @type {Tw2Logger}
 */
_Tw2EventEmitter2.Tw2EventEmitter.logger = logger;

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (immutable) */ __webpack_exports__["setMatrixArrayType"] = setMatrixArrayType;
/* harmony export (immutable) */ __webpack_exports__["toRadian"] = toRadian;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
const EPSILON = 0.000001;
/* harmony export (immutable) */ __webpack_exports__["EPSILON"] = EPSILON;

let ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
const RANDOM = Math.random;
/* harmony export (immutable) */ __webpack_exports__["RANDOM"] = RANDOM;


/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}

const degree = Math.PI / 180;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resMan = exports.Tw2ResMan = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Logger = __webpack_require__(4);

var _Tw2Store = __webpack_require__(16);

var _Tw2MotherLode = __webpack_require__(78);

var _Tw2LoadingObject = __webpack_require__(37);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Resource Manager
 *
 * @property {Boolean} systemMirror - Toggles whether {@link Tw2GeometryRes} Index and Buffer data arrays are visible
 * @property {Tw2MotherLode} motherLode
 * @property {Number} maxPrepareTime
 * @property {Number} prepareBudget
 * @property {Boolean} autoPurgeResources=true - Sets whether resources should be purged automatically
 * @property {Number} purgeTime=30 = Sets how long resources can remain inactive before they are purged
 * @property {Number} activeFrame
 * @property {Array} _prepareQueue
 * @property {Number} _purgeTime
 * @property {Number} _purgeFrame
 * @property {Number} _purgeFrameLimit
 * @property {Number} _pendingLoads - a count of how many things are pending load
 * @property {Number} _noLoadFrames
 * @class
 */
var Tw2ResMan = exports.Tw2ResMan = function () {
    function Tw2ResMan() {
        _classCallCheck(this, Tw2ResMan);

        this.motherLode = new _Tw2MotherLode.Tw2MotherLode();
        this.systemMirror = false;
        this.maxPrepareTime = 0.05;
        this.prepareBudget = 0;
        this.autoPurgeResources = true;
        this.activeFrame = 0;
        this.purgeTime = 30;
        this._prepareQueue = [];
        this._purgeTime = 0;
        this._purgeFrame = 0;
        this._purgeFrameLimit = 1000;
        this._pendingLoads = 0;
        this._noLoadFrames = 0;
    }

    /**
     * IsLoading
     * @returns {Boolean}
     *
     */


    _createClass(Tw2ResMan, [{
        key: 'IsLoading',
        value: function IsLoading() {
            return this._noLoadFrames < 2;
        }

        /**
         * Clears the motherLode {@link Tw2MotherLode}
         */

    }, {
        key: 'Clear',
        value: function Clear() {
            this.motherLode.Clear();
        }

        /**
         * Unloads and Clears the motherLode {@link Tw2MotherLode}
         */

    }, {
        key: 'UnloadAndClear',
        value: function UnloadAndClear() {
            this.motherLode.UnloadAndClear();
        }

        /**
         * Internal update function. It is called every frame.
         * @param {Number} dt - deltaTime
         * @returns {Boolean}
         */

    }, {
        key: 'PrepareLoop',
        value: function PrepareLoop(dt) {
            if (this._prepareQueue.length === 0 && this._pendingLoads === 0) {
                if (this._noLoadFrames < 2) {
                    this._noLoadFrames++;
                }
            } else {
                this._noLoadFrames = 0;
            }

            this.prepareBudget = this.maxPrepareTime;

            var startTime = Date.now();
            while (this._prepareQueue.length) {
                var res = this._prepareQueue[0][0],
                    data = this._prepareQueue[0][1],
                    xml = this._prepareQueue[0][2];

                var handlesPrepareQueue = void 0;

                try {
                    handlesPrepareQueue = res.Prepare(data, xml);
                } catch (e) {
                    this._prepareQueue.shift();
                    throw e;
                }

                if (!handlesPrepareQueue) {
                    _Tw2Logger.logger.log('res.event', {
                        msg: 'Prepared  ',
                        path: res.path,
                        time: (Date.now() - startTime) * 0.001,
                        type: 'prepared'
                    });

                    this._prepareQueue.shift();
                }

                this.prepareBudget -= (Date.now() - startTime) * 0.001;
                if (this.prepareBudget < 0) break;
            }

            this._purgeTime += dt;

            if (this._purgeTime > 1) {
                this.activeFrame += 1;
                this._purgeTime -= Math.floor(this._purgeTime);
                this._purgeFrame += 1;

                if (this._purgeFrame >= 5) {
                    if (this.autoPurgeResources) {
                        this.motherLode.PurgeInactive(this._purgeFrame, this._purgeFrameLimit, this.purgeTime);
                    }
                }
            }

            return true;
        }

        /**
         * Gets a resource
         * @param {String} path
         * @returns {Tw2Resource} resource
         */

    }, {
        key: 'GetResource',
        value: function GetResource(path) {
            var res = void 0;
            path = Tw2ResMan.NormalizePath(path);

            // Check if already loaded
            res = this.motherLode.Find(path);
            if (res) {
                if (res.IsPurged()) res.Reload();
                return res;
            }

            var ext = Tw2ResMan.GetPathExt(path);
            if (ext === null) {
                _Tw2Logger.logger.log('res.error', {
                    log: 'error',
                    src: ['Tw2ResMan', 'ReloadResource'],
                    msg: 'Undefined extension',
                    type: 'extension.undefined',
                    path: path
                });
                return null;
            }

            var Extension = _Tw2Store.store.GetExtension(ext);
            if (!Extension) {
                _Tw2Logger.logger.log('res.error', {
                    log: 'error',
                    src: ['Tw2ResMan', 'ReloadResource'],
                    msg: 'Unregistered extension',
                    type: 'extension.unregistered',
                    path: path,
                    value: ext
                });
                return null;
            }

            res = new Extension();
            res.path = path;
            return Tw2ResMan.LoadResource(this, res);
        }

        /**
         * Gets a resource object
         * @param {string} path
         * @param {Function} callback
         */

    }, {
        key: 'GetObject',
        value: function GetObject(path, callback) {
            var obj = {};
            path = Tw2ResMan.NormalizePath(path);

            // Check if already loaded
            var res = this.motherLode.Find(path);
            if (res) {
                res.AddObject(obj, callback);
                return;
            }

            res = new _Tw2LoadingObject.Tw2LoadingObject();
            res.path = path;
            res.AddObject(obj, callback);
            Tw2ResMan.LoadResource(this, res);
        }

        /**
         * Reloads a resource
         * @param {Tw2Resource} resource
         * @returns {Tw2Resource} resource
         */

    }, {
        key: 'ReloadResource',
        value: function ReloadResource(resource) {
            var path = resource.path;

            // Check if already loaded and good
            var res = this.motherLode.Find(path);
            if (res && !res.IsPurged()) return res;

            _Tw2Logger.logger.log('res.event', {
                msg: 'Reloading ',
                path: path,
                type: 'reload'
            });

            return Tw2ResMan.LoadResource(this, resource);
        }

        /**
         * Builds a url from a resource path
         * @param {string} resPath
         * @returns {string}
         */

    }], [{
        key: 'BuildUrl',
        value: function BuildUrl(resPath) {
            var prefixIndex = resPath.indexOf(':/');
            if (prefixIndex === -1) {
                _Tw2Logger.logger.log('res.error', {
                    log: 'warn',
                    src: ['Tw2ResMan', 'BuildUrl'],
                    msg: 'Invalid path',
                    type: 'prefix.undefined',
                    path: resPath
                });
                return resPath;
            }

            var prefix = resPath.substr(0, prefixIndex),
                path = _Tw2Store.store.GetPath(prefix);

            if (!path) {
                _Tw2Logger.logger.log('res.error', {
                    log: 'warn',
                    src: ['Tw2ResMan', 'BuildUrl'],
                    msg: 'Unregistered path',
                    path: resPath,
                    type: 'prefix.unregistered',
                    value: prefix
                });
                return resPath;
            }

            return path + resPath.substr(prefixIndex + 2);
        }

        /**
         * Normalizes a file path by making it lower case and replaces all '\\' with '/'
         * @param {string} path
         * @returns {string}
         */

    }, {
        key: 'NormalizePath',
        value: function NormalizePath(path) {
            if (path.substr(0, 5) === 'str:/') return path;
            path = path.toLowerCase();
            path.replace('\\', '/');
            return path;
        }

        /**
         * Gets a path's extension
         * @param {string} path
         * @returns {?string}
         */

    }, {
        key: 'GetPathExt',
        value: function GetPathExt(path) {
            if (path.substr(0, 5) === 'str:/') {
                var slash = path.indexOf('/', 5);
                if (slash === -1) return null;
                return path.substr(5, slash - 5);
            } else {
                var dot = path.lastIndexOf('.');
                if (dot === -1) return null;
                return path.substr(dot + 1);
            }
        }

        /**
         * Returns a path suitable for logging by truncating really long file names
         * @param {string} path
         * @returns {string}
         */

    }, {
        key: 'LogPathString',
        value: function LogPathString(path) {
            if (path.substr(0, 5) === 'str:/' && path.length > 64) {
                return path.substr(0, 64) + '...';
            }
            return path;
        }

        /**
         * Loads a resource
         * @param {Tw2ResMan} resMan
         * @param {Tw2Resource} res
         * @returns {Tw2Resource}
         */

    }, {
        key: 'LoadResource',
        value: function LoadResource(resMan, res) {
            var path = res.path,
                url = Tw2ResMan.BuildUrl(path);

            res._isPurged = false;
            resMan.motherLode.Add(path, res);
            if (res.DoCustomLoad && res.DoCustomLoad(url)) return res;

            var httpRequest = Tw2ResMan.CreateHttpRequest(res.requestResponseType);
            if (httpRequest) {
                _Tw2Logger.logger.log('res.event', {
                    msg: 'Requesting',
                    path: path,
                    type: 'request'
                });

                httpRequest.onreadystatechange = Tw2ResMan.DoLoadResource(resMan, res);
                httpRequest.open('GET', url);
                res.LoadStarted();

                try {
                    httpRequest.send();
                    resMan._pendingLoads++;
                } catch (e) {
                    _Tw2Logger.logger.log('res.error', {
                        log: 'error',
                        src: ['Tw2ResMan', 'LoadResource'],
                        msg: 'Error sending object HTTP request',
                        path: path,
                        type: 'http.request',
                        err: e
                    });
                }
            }
            return res;
        }

        /**
         * Creates an onreadystatechange callback
         * @param {Tw2ResMan} resMan
         * @param {Tw2Resource} res
         */

    }, {
        key: 'DoLoadResource',
        value: function DoLoadResource(resMan, res) {
            return function () {
                var readyState = 0;

                try {
                    readyState = this.readyState;
                } catch (e) {
                    _Tw2Logger.logger.log('res.error', {
                        log: 'error',
                        src: ['Tw2ResMan', '_DoLoadResource'],
                        msg: 'Communication error loading',
                        path: res.path,
                        type: 'http.readystate',
                        value: readyState
                    });

                    res.LoadFinished(false);
                    resMan._pendingLoads--;
                    return;
                }

                if (readyState === 4) {
                    if (this.status === 200) {
                        var data = null,
                            xml = null;

                        try {
                            data = this.responseText;
                            xml = this.responseXML;
                        } catch (e) {
                            data = this.response;
                        }

                        res.LoadFinished(true);
                        resMan._prepareQueue.push([res, data, xml]);
                    } else {
                        _Tw2Logger.logger.log('res.error', {
                            log: 'error',
                            src: ['Tw2ResMan', '_DoLoadResource'],
                            msg: 'Communication error loading',
                            path: res.path,
                            type: 'http.status',
                            value: this.status
                        });
                        res.LoadFinished(false);
                        res.PrepareFinished(false);
                    }
                    resMan._pendingLoads--;
                }
            };
        }

        /**
         * Creates an HTTP request
         * @param {?string} [responseType]
         * @returns {XMLHttpRequest|ActiveXObject}
         */

    }, {
        key: 'CreateHttpRequest',
        value: function CreateHttpRequest(responseType) {
            var httpRequest = null;

            if (window.XMLHttpRequest) {
                // Mozilla, Safari, ...
                httpRequest = new XMLHttpRequest();
            } else if (window.ActiveXObject) {
                // IE
                try {
                    httpRequest = new window['ActiveXObject']('Msxml2.XMLHTTP');
                } catch (e) {
                    try {
                        httpRequest = new window['ActiveXObject']('Microsoft.XMLHTTP');
                    } catch (e) {
                        /*eslint-disable-line-no-empty*/
                    }
                }
            }

            if (!httpRequest) {
                _Tw2Logger.logger.log('res.error', {
                    log: 'error',
                    src: ['Tw2LoadingObject', 'Prepare'],
                    msg: 'Could not create an XMLHTTP instance',
                    type: 'http.instance'
                });
            } else if (responseType) {
                httpRequest.responseType = responseType;
            }

            return httpRequest;
        }
    }]);

    return Tw2ResMan;
}();

// Global instance of Tw2ResMan


var resMan = exports.resMan = new Tw2ResMan();

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2VectorParameter = exports.Tw2Parameter = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-unused-vars:0 */


var _math = __webpack_require__(0);

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2Parameter base class
 *
 * @param {string} [name='']
 * @property {string|number} _id
 * @property {string} name
 * @property {Array<Function>} _onModified
 */
var Tw2Parameter = exports.Tw2Parameter = function () {
    function Tw2Parameter() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        _classCallCheck(this, Tw2Parameter);

        this._id = _math.util.generateID();
        this.name = name;
        this._onModified = [];
    }

    /**
     * Gets the parameter's constant buffer size
     * @returns {number} 0 if invalid
     */


    _createClass(Tw2Parameter, [{
        key: 'OnValueChanged',


        /**
         * Fire on value changes
         * @property {*} [controller]        - An optional object which changed the parameter's value
         * @property {string[]} [properties] - An optional array for tracking the parameters that were updated
         */
        value: function OnValueChanged(controller, properties) {
            for (var i = 0; i < this._onModified.length; i++) {
                this._onModified[i](this, controller, properties);
            }
        }

        /**
         * Adds a callback which is fired when the parameter's OnValueChanged method is called
         * @param {function} func
         * @returns {boolean} true if successful
         */

    }, {
        key: 'AddCallback',
        value: function AddCallback(func) {
            if (!this._onModified.includes(func)) {
                this._onModified.push(func);
            }
            return true;
        }

        /**
         * Removes a callback
         * @param {Function} func
         */

    }, {
        key: 'RemoveCallback',
        value: function RemoveCallback(func) {
            var index = this._onModified.indexOf(func);
            if (index !== -1) {
                this._onModified.splice(index, 1);
            }
        }

        /**
         * Gets the parameter's value
         * @param {boolean} [serialize] - forces serialized result
         * @returns {null}
         */

    }, {
        key: 'GetValue',
        value: function GetValue(serialize) {
            return null;
        }

        /**
         * Binds the parameter
         * @param {*} a
         * @param {*} b
         * @param {*} c
         * @returns {boolean} false if not bound
         */

    }, {
        key: 'Bind',
        value: function Bind(a, b, c) {
            return false;
        }

        /**
         * Unbinds the parameter
         */

    }, {
        key: 'UnBind',
        value: function UnBind() {}

        /**
         * Applies the parameter to a constant buffer
         * @param {*} a
         * @param {*} b
         * @param {*} c
         */

    }, {
        key: 'Apply',
        value: function Apply(a, b, c) {}

        /**
         * Copies another parameter's value
         * @param {*} parameter
         */

    }, {
        key: 'Copy',
        value: function Copy(parameter) {}

        /**
         * Clones the parameter
         * @returns {Tw2Parameter}
         */

    }, {
        key: 'Clone',
        value: function Clone() {
            var parameter = new this.constructor();
            parameter.Copy(this, true);
            return parameter;
        }
    }, {
        key: 'size',
        get: function get() {
            return this.constructor.constantBufferSize;
        }
    }]);

    return Tw2Parameter;
}();

/**
 * The parameter's constant buffer size
 * @type {number}
 */


Tw2Parameter.constantBufferSize = 0;

/**
 * Tw2VectorParameter base class
 *
 * @property {Float32Array} value
 * @property {?Float32Array} constantBuffer
 * @property {?number} offset
 * @class
 */

var Tw2VectorParameter = exports.Tw2VectorParameter = function (_Tw2Parameter) {
    _inherits(Tw2VectorParameter, _Tw2Parameter);

    function Tw2VectorParameter(name, value) {
        _classCallCheck(this, Tw2VectorParameter);

        var _this = _possibleConstructorReturn(this, (Tw2VectorParameter.__proto__ || Object.getPrototypeOf(Tw2VectorParameter)).call(this, name));

        _this.value = new Float32Array(_this.size);
        _this.constantBuffer = null;
        _this.offset = null;
        if (value) _this.value.set(value);
        return _this;
    }

    /**
     * Sets the parameter's value
     * @param {Float32Array} value
     */


    _createClass(Tw2VectorParameter, [{
        key: 'SetValue',
        value: function SetValue(value) {
            this.value.set(value);
            this.OnValueChanged();
        }

        /**
         * Sets a parameter's value at a given index
         * @param {number} index   - the parameter's value index to change
         * @param {number} value   - the value to set
         * @throw Index Error
         */

    }, {
        key: 'SetIndexValue',
        value: function SetIndexValue(index, value) {
            if (this.value[index] !== undefined) {
                if (this.value[index] !== value) {
                    this.value[index] = value;
                    this.OnValueChanged();
                }
                return;
            }

            throw new Error('Index Error');
        }

        /**
         * Gets the parameter's value
         * @param {boolean} [serialize] - An optional parameter to force a serialized result
         * @returns {Array|Float32Array}
         */

    }, {
        key: 'GetValue',
        value: function GetValue(serialize) {
            var value = this.constantBuffer ? this.constantBuffer.subarray(this.offset, this.offset + this.size) : this.value;
            return serialize ? Array.from(value) : new Float32Array(value);
        }

        /**
         * Gets a parameter's value at a given index
         * @param index
         * @returns {number}
         * @throw Index Error
         */

    }, {
        key: 'GetIndexValue',
        value: function GetIndexValue(index) {
            if (this.value[index] !== undefined) {
                return this.value[index];
            }
            throw new Error('Index Error');
        }

        /**
         * Fire on value changes
         * @param {*} [controller]        - An optional parameter for tracking the object that called the function
         * @param {string[]} [properties] - An optional array for tracking the parameters that were updated
         */

    }, {
        key: 'OnValueChanged',
        value: function OnValueChanged(controller, properties) {
            if (this.constantBuffer) {
                this.Apply(this.constantBuffer, this.offset);
            }

            _get(Tw2VectorParameter.prototype.__proto__ || Object.getPrototypeOf(Tw2VectorParameter.prototype), 'OnValueChanged', this).call(this, controller, properties);
        }

        /**
         * Binds the parameter to a constant buffer
         * @param {Float32Array} constantBuffer
         * @param {number} offset
         * @param {number} size
         * @returns {boolean} true if bound
         */

    }, {
        key: 'Bind',
        value: function Bind(constantBuffer, offset, size) {
            if (!this.constantBuffer && size >= this.size) {
                this.constantBuffer = constantBuffer;
                this.offset = offset;
                this.Apply(constantBuffer, offset, size);
                return true;
            }
            return false;
        }

        /**
         * Unbinds the parameter from a constant buffer
         */

    }, {
        key: 'Unbind',
        value: function Unbind() {
            this.constantBuffer = null;
        }

        /**
         * Applies the parameter's value to it's constant buffer
         * @param {Float32Array} constantBuffer
         * @param {number} offset
         * @param {number} [size]
         */

    }, {
        key: 'Apply',
        value: function Apply(constantBuffer, offset, size) {
            constantBuffer.set(this.value, offset);
        }

        /**
         * Checks if a value equals the parameter's value
         * - Assumes the correct length array or typed array is passed
         * @param {Array|Float32Array} value
         * @returns {boolean}
         */

    }, {
        key: 'EqualsValue',
        value: function EqualsValue(value) {
            for (var i = 0; i < this.size; i++) {
                if (this.value[i] !== value[i]) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Copies another parameter's value
         * @param {Tw2VectorParameter|*} parameter
         * @param {boolean} [includeName]
         */

    }, {
        key: 'Copy',
        value: function Copy(parameter, includeName) {
            if (includeName) this.name = parameter.name;
            this.SetValue(parameter.GetValue());
        }

        /**
         * Checks if a value is a valid parameter input
         * @param {Float32Array|Array} value
         * @returns {boolean}
         */

    }], [{
        key: 'is',
        value: function is(value) {
            return _math.util.isArrayLike(value) && value.length === this.constantBufferSize;
        }
    }]);

    return Tw2VectorParameter;
}(Tw2Parameter);

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2CurveSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _curves = __webpack_require__(19);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2CurveSequencer base class
 *
 * @class
 */
var Tw2CurveSequencer = exports.Tw2CurveSequencer = function (_Tw2Curve) {
    _inherits(Tw2CurveSequencer, _Tw2Curve);

    function Tw2CurveSequencer() {
        _classCallCheck(this, Tw2CurveSequencer);

        return _possibleConstructorReturn(this, (Tw2CurveSequencer.__proto__ || Object.getPrototypeOf(Tw2CurveSequencer)).call(this));
    }

    /**
     * Legacy sequencer sorting
     * @param {Tw2CurveSequencer} sequencer
     */


    _createClass(Tw2CurveSequencer, null, [{
        key: 'Sort',
        value: function Sort(sequencer) {
            var curves = sequencer['functions'];
            if (curves && curves.length) {
                for (var i = 0; i < curves.length; i++) {
                    if (curves[i] && 'Sort' in curves[i]) curves[i].Sort();
                }
            }
        }

        /**
         * Standard sequencer sorting
         * @param {Tw2CurveSequencer} sequencer
         */

    }, {
        key: 'Sort2',
        value: function Sort2(sequencer) {
            var names = sequencer.constructor.childProperties;
            if (names) {
                for (var i = 0; i < names.length; i++) {
                    var curve = sequencer[names[i]];
                    if (curve && 'Sort' in curve) curve.Sort();
                }
            }
        }
    }]);

    return Tw2CurveSequencer;
}(_curves.Tw2Curve);

/**
 * The sequencer's curve property names
 * @type {?Array.<string>}
 */


Tw2CurveSequencer.childProperties = null;

/**
 * The sequencer's curve array
 * @type {?string}
 */
Tw2CurveSequencer.childArray = null;

/**
 * Operator types
 * @type {null}
 */
Tw2CurveSequencer.Operator = null;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2VertexDeclaration = __webpack_require__(80);

Object.keys(_Tw2VertexDeclaration).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2VertexDeclaration[key];
    }
  });
});

var _Tw2VertexElement = __webpack_require__(43);

Object.keys(_Tw2VertexElement).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2VertexElement[key];
    }
  });
});

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveObjectSet = exports.EveObjectSetItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-unused-vars:0 */


var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EveObjectSetItem base class
 *
 * @property {string|number} _id     - The set item's id
 * @property {string} name           - The set item's name
 * @property {boolean} display       - Toggles the set item's visibility
 * @property {?Function} _onModified - A callback which is fired on value changes
 */
var EveObjectSetItem = exports.EveObjectSetItem = function () {
    function EveObjectSetItem() {
        _classCallCheck(this, EveObjectSetItem);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this._rebuildPending = true;
        this._onModified = null;
    }

    /**
     * Fire on value changes
     */


    _createClass(EveObjectSetItem, [{
        key: 'OnValueChanged',
        value: function OnValueChanged() {
            this._rebuildPending = true;
            if (this._onModified) this._onModified(this);
        }
    }]);

    return EveObjectSetItem;
}();

/**
 * EveObjectSet base class
 *
 * @property {number|String} _id                     - The set's id
 * @property {string} name                           - The set's name
 * @property {boolean} display                       - Toggles set visibility
 * @property {Array<EveObjectSetItem>} items         - The set's items
 * @property {Array<EveObjectSetItem>} _visibleItems - The set's items that will be rendered when the set is visible
 * @property {boolean} _rebuildPending               - Identifies if the set requires rebuilding
 * @class
 */


var EveObjectSet = exports.EveObjectSet = function () {
    function EveObjectSet() {
        var _this = this;

        _classCallCheck(this, EveObjectSet);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.items = [];
        this._visibleItems = [];
        this._rebuildPending = false;
        this._onChildModified = function (item) {
            return _this.OnValueChanged(item);
        };
    }

    /**
     * Initializes the set
     */


    _createClass(EveObjectSet, [{
        key: 'Initialize',
        value: function Initialize() {
            this.Rebuild();
        }

        /**
         * Fires on value changes
         */

    }, {
        key: 'OnValueChanged',
        value: function OnValueChanged() {
            this._rebuildPending = true;
        }

        /**
         * Creates an item from an options object and then adds it to the set
         * @param {*} [opt={}]
         * @returns {?EveObjectSetItem|*}
         */

    }, {
        key: 'CreateItem',
        value: function CreateItem() {
            var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var Item = this.constructor.Item;
            if (Item && 'create' in Item) {
                var item = Item.create(opt);
                this.AddItem(item);
                return item;
            }
            return null;
        }

        /**
         * Adds a set item
         * @param {EveObjectSetItem|*} item
         */

    }, {
        key: 'AddItem',
        value: function AddItem(item) {
            if (!this.items.includes(item)) {
                item._onModified = this._onChildModified;
                this.items.push(item);
                this.OnValueChanged();
            }
        }

        /**
         * Removes a set item
         * @param {EveObjectSetItem|*} item
         */

    }, {
        key: 'RemoveItem',
        value: function RemoveItem(item) {
            var index = this.items.indexOf(item);
            if (index !== -1) {
                item._onModified = null;
                this.items.splice(index, 1);
                this.OnValueChanged();
            }
        }

        /**
         * Clears all set items
         */

    }, {
        key: 'ClearItems',
        value: function ClearItems() {
            for (var i = 0; i < this.items.length; i++) {
                this.items[i]._onModified = null;
            }
            this.items = [];
            this.OnValueChanged();
        }

        /**
         * Finds an item by it's id
         * @param {?number} [id=null]
         * @returns {?EveObjectSetItem|*}
         */

    }, {
        key: 'FindItemByID',
        value: function FindItemByID() {
            var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            if (id !== null) {
                for (var i = 0; i < this.items.length; i++) {
                    if (this.items[i]._id === id) {
                        return this.items[i];
                    }
                }
            }
            return null;
        }

        /**
         * Gets the set's resources
         * @param {Array} [out=[]]
         * @returns {Array<Tw2Resource>}
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            return out;
        }

        /**
         * Per frame update
         * @param {number} dt
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            if (this._rebuildPending) {
                this.Rebuild();
            }
        }

        /**
         * Unloads the set's buffers
         */

    }, {
        key: 'Unload',
        value: function Unload() {}

        /**
         * Rebuilds the set
         */

    }, {
        key: 'Rebuild',
        value: function Rebuild() {
            this.constructor.RebuildItems(this);
            this._rebuildPending = false;
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData|Tw2BasicPerObjectData} perObjectData
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {}

        /**
         * Renders the set
         */

    }, {
        key: 'Render',
        value: function Render() {}

        /**
         * Rebuilds the set's items
         *
         * @param {EveObjectSet|*} eveSet
         */

    }], [{
        key: 'RebuildItems',
        value: function RebuildItems(eveSet) {
            eveSet._visibleItems = [];
            for (var i = 0; i < eveSet.items.length; i++) {
                var item = eveSet.items[i];
                item._onModified = eveSet._onChildModified;

                if (item.display) {
                    eveSet._visibleItems.push(item);
                    item._rebuildPending = false;
                }
            }
        }
    }]);

    return EveObjectSet;
}();

/**
 * The object set's item
 * @type {?Function}
 */


EveObjectSet.Item = null;

/**
 * Class global and scratch variables
 * @type {{vec3_0, vec3_1, vec3_2}}
 */
EveObjectSet.global = {
    vec3_0: _math.vec3.create(),
    vec3_1: _math.vec3.create(),
    vec3_2: _math.vec3.create(),
    vec4_0: _math.vec4.create(),
    vec4_1: _math.vec4.create(),
    mat4_0: _math.mat4.create()
};

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__gl_matrix_vec2__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec3__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec4__ = __webpack_require__(33);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return __WEBPACK_IMPORTED_MODULE_6__gl_matrix_vec2__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec3__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec4__; });
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.4.0
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER













/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Resource = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2ResMan = __webpack_require__(6);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2Resource base class
 *
 * @property {string} path
 * @property {boolean} _isLoading
 * @property {boolean} _isGood
 * @property {boolean} _isPurged
 * @property {Array} _notifications
 * @property {number} activeFrame
 * @property {number} doNotPurge
 * @class
 */
var Tw2Resource = exports.Tw2Resource = function () {
    function Tw2Resource() {
        _classCallCheck(this, Tw2Resource);

        this.path = '';
        this._isLoading = false;
        this._isGood = false;
        this._isPurged = false;
        this._notifications = [];
        this.activeFrame = 0;
        this.doNotPurge = 0;
    }

    /**
     * Checks to see if the resource is loading
     * @returns {boolean}
     */


    _createClass(Tw2Resource, [{
        key: 'IsLoading',
        value: function IsLoading() {
            this.KeepAlive();
            return this._isLoading;
        }

        /**
         * Checks to see if the resource is good
         * @returns {boolean}
         */

    }, {
        key: 'IsGood',
        value: function IsGood() {
            this.KeepAlive();
            return this._isGood;
        }

        /**
         * Checks to see if the resource is purged
         * @returns {boolean}
         * @prototype
         */

    }, {
        key: 'IsPurged',
        value: function IsPurged() {
            return this._isPurged;
        }

        /**
         * LoadStarted
         */

    }, {
        key: 'LoadStarted',
        value: function LoadStarted() {
            this._isLoading = true;
            this.UpdateNotifications('ReleaseCachedData');
        }

        /**
         * LoadFinished
         * @param {boolean} success
         */

    }, {
        key: 'LoadFinished',
        value: function LoadFinished(success) {
            this._isLoading = false;
            if (!success) this._isGood = false;
        }

        /**
         * PrepareFinished
         * @param {boolean} success
         */

    }, {
        key: 'PrepareFinished',
        value: function PrepareFinished(success) {
            this._isLoading = false;
            this._isGood = success;
            this.UpdateNotifications('RebuildCachedData');
        }

        /**
         * Sets resource's isGood property
         * @param {boolean} success
         */

    }, {
        key: 'SetIsGood',
        value: function SetIsGood(success) {
            this._isGood = success;
        }

        /**
         * Unloads the resource
         */

    }, {
        key: 'Unload',
        value: function Unload() {}

        /**
         * Reloads the resource
         */

    }, {
        key: 'Reload',
        value: function Reload() {
            this.Unload();
            _Tw2ResMan.resMan.ReloadResource(this);
        }

        /**
         * Keeps the resource from being purged
         */

    }, {
        key: 'KeepAlive',
        value: function KeepAlive() {
            this.activeFrame = _Tw2ResMan.resMan.activeFrame;
            if (this._isPurged) this.Reload();
        }

        /**
         * Registers a notification
         * @param {*} notification
         */

    }, {
        key: 'RegisterNotification',
        value: function RegisterNotification(notification) {
            if (!this._notifications.includes(notification)) {
                this._notifications.push(notification);
                if (this._isGood && 'RebuildCachedData' in notification) {
                    notification.RebuildCachedData(this);
                }
            }
        }

        /**
         * Deregisters a notification
         * @param {*} notification
         */

    }, {
        key: 'UnregisterNotification',
        value: function UnregisterNotification(notification) {
            this._notifications.splice(this._notifications.indexOf(notification), 1);
        }

        /**
         * Updates a notification
         * @param {string} funcName - The function name to call
         */

    }, {
        key: 'UpdateNotifications',
        value: function UpdateNotifications(funcName) {
            for (var i = 0; i < this._notifications.length; i++) {
                if (funcName in this._notifications[i]) {
                    this._notifications[i][funcName](this);
                }
            }
        }
    }]);

    return Tw2Resource;
}();

/**
 * An optional function for when the resource handles it's own loading
 * -  If the method returns false then the resource manager will handle the http request
 * @type {?Function}
 * @returns {boolean}
 */


Tw2Resource.prototype.DoCustomLoad = null;

/**
 * HTTP request response type
 * @type {null}
 */
Tw2Resource.prototype.requestResponseType = null;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2ParticleForce = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-unused-vars:0 */


var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2ParticleForce base class
 *
 * @property {number|string} id
 * @property {string} name
 * @class
 */
var Tw2ParticleForce = exports.Tw2ParticleForce = function () {
  function Tw2ParticleForce() {
    _classCallCheck(this, Tw2ParticleForce);

    this._id = _math.util.generateID();
    this.name = '';
  }

  /**
   * Applies forces
   * @param {Tw2ParticleElement} position
   * @param {Tw2ParticleElement} velocity
   * @param {Tw2ParticleElement} force
   * @param {number} dt
   * @param {number} mass
   */


  _createClass(Tw2ParticleForce, [{
    key: 'ApplyForce',
    value: function ApplyForce(position, velocity, force, dt, mass) {}

    /**
     * Per frame update (Called before ApplyForce)
     * @param {number} dt - delta time
     */

  }, {
    key: 'Update',
    value: function Update(dt) {}
  }]);

  return Tw2ParticleForce;
}();

/**
 * Class globals
 * @type {*}
 */


Tw2ParticleForce.global = {
  vec3_0: _math.vec3.create(),
  vec3_1: _math.vec3.create(),
  vec4_0: _math.vec4.create()
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveChild = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-unused-vars:0 */


var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EveChild base class
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {boolean} display
 * @property {boolean} useSRT
 * @property {number} lowestLodVisible
 * @property {boolean} staticTransform
 * @property {quat} rotation
 * @property {vec3} translation
 * @property {vec3} scaling
 * @property {mat4} localTransform
 * @property {mat4} worldTransform
 * @property {mat4} worldTransformLast
 * @property {?|Tw2BasicPerObjectData|Tw2PerObjectData} _perObjectData
 * @class
 */
var EveChild = exports.EveChild = function () {
    function EveChild() {
        _classCallCheck(this, EveChild);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.useSRT = true;
        this.lowestLodVisible = 2;
        this.staticTransform = false;
        this.rotation = _math.quat.create();
        this.translation = _math.vec3.create();
        this.scaling = _math.vec3.fromValues(1, 1, 1);
        this.localTransform = _math.mat4.create();
        this.worldTransform = _math.mat4.create();
        this.worldTransformLast = _math.mat4.create();
        this._perObjectData = null;
        this.isEffectChild = true;
    }

    /**
     * Gets the child's resources
     * @param {Array} [out=[]]
     * @returns {Array<Tw2Resource>} out
     */


    _createClass(EveChild, [{
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            return out;
        }

        /**
         * Per frame update
         * @param {number} dt
         * @param {mat4} parentTransform
         */

    }, {
        key: 'Update',
        value: function Update(dt, parentTransform) {
            if (this.useSRT) {
                _math.quat.normalize(this.rotation, this.rotation);
                _math.mat4.fromRotationTranslationScale(this.localTransform, this.rotation, this.translation, this.scaling);
            }

            _math.mat4.copy(this.worldTransformLast, this.worldTransform);
            _math.mat4.multiply(this.worldTransform, parentTransform, this.localTransform);
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {}
    }]);

    return EveChild;
}();

/**
 * Class globals and scratch variables
 * @type {Object}
 */


EveChild.global = {
    mat4_0: _math.mat4.create(),
    vec3_0: _math.vec3.create()
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EveObject = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-unused-vars:0 */


var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EveObject base class
 *
 * @property {number} _id
 * @property {string} name
 * @property {boolean} display
 * @class
 */
var EveObject = exports.EveObject = function () {
  function EveObject() {
    _classCallCheck(this, EveObject);

    this._id = _math.util.generateID();
    this.name = '';
    this.display = true;
  }

  /**
   * Initializes the object
   */


  _createClass(EveObject, [{
    key: 'Initialize',
    value: function Initialize() {}

    /**
     * Gets object resources
     * @param {Array} [out=[]]
     * @returns {Array<Tw2Resource>} out
     */

  }, {
    key: 'GetResources',
    value: function GetResources() {
      var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      return out;
    }

    /**
     * Per frame update
     * @param {number} dt - delta time
     */

  }, {
    key: 'Update',
    value: function Update(dt) {}

    /**
     * Accumulates batches
     * @param {number} mode
     * @param {Tw2BatchAccumulator} accumulator
     */

  }, {
    key: 'GetBatches',
    value: function GetBatches(mode, accumulator) {}
  }]);

  return EveObject;
}();

/**
 * Class global and scratch variables
 * @type {{string:*}}
 */


EveObject.global = {
  vec3_0: _math.vec3.create(),
  vec3_1: _math.vec3.create(),
  vec3_2: _math.vec3.create(),
  vec3_3: _math.vec3.create(),
  vec3_4: _math.vec3.create(),
  vec3_5: _math.vec3.create(),
  vec3_6: _math.vec3.create(),
  vec3_7: _math.vec3.create(),
  mat4_0: _math.mat4.create(),
  mat4_1: _math.mat4.create(),
  mat4_2: _math.mat4.create()
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.store = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Logger = __webpack_require__(4);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Stores engine data
 *
 * @property {Object.< string, string>} _paths
 * @property {Object.< string, Array<string>>} _dynamicPaths
 * @property {Object.< string, Tw2Parameter>} _variables
 * @property {Object.< string, Function>} _types
 * @property {Object.< string, Function>} _extensions
 * @property {Object.< string, Function>} _constructors
 * @property {Object.< string, Array<string>>} _missing
 * @class
 */
var Tw2Store = function () {
    function Tw2Store() {
        _classCallCheck(this, Tw2Store);

        this._types = {};
        this._paths = {};
        this._variables = {};
        this._extensions = {};
        this._constructors = {};
        this._dynamicPaths = {};
        this._missing = {};
    }

    /**
     * Checks if a resource path exists
     * @param {string} prefix
     * @returns {boolean}
     */


    _createClass(Tw2Store, [{
        key: 'HasPath',
        value: function HasPath(prefix) {
            return prefix && prefix in this._paths;
        }

        /**
         * Gets a path by it's prefix
         * @param {string} prefix
         * @returns {?string}
         */

    }, {
        key: 'GetPath',
        value: function GetPath(prefix) {
            return Tw2Store.GetStoreItem(this, 'paths', prefix);
        }

        /**
         * Registers a resource path
         * @param {string} prefix
         * @param {string} path
         * @returns {boolean}
         */

    }, {
        key: 'RegisterPath',
        value: function RegisterPath(prefix, path) {
            return !!Tw2Store.SetStoreItem(this, 'paths', prefix, path);
        }

        /**
         * Registers resource paths from an object or an array of objects
         * @param {{string:string}|Array<{string:string}>} obj
         * @returns {boolean}
         */

    }, {
        key: 'RegisterPaths',
        value: function RegisterPaths(obj) {
            return Tw2Store.RegisterFromObject(this, 'RegisterPath', obj);
        }

        /**
         * Checks if a dynamic path exists
         * @param {string} prefix
         * @returns {boolean}
         */

    }, {
        key: 'HasDynamicPath',
        value: function HasDynamicPath(prefix) {
            return prefix && prefix in this._dynamicPaths;
        }

        /**
         * Gets a dynamic path by it's prefix
         * @param {string} prefix
         * @returns {?Array<string>}
         */

    }, {
        key: 'GetDynamicPath',
        value: function GetDynamicPath(prefix) {
            return Tw2Store.GetStoreItem(this, 'dynamicPaths', prefix);
        }

        /**
         * Registers a dynamic path
         * @param {string} prefix
         * @param {string[]} paths
         * @returns {boolean}
         */

    }, {
        key: 'RegisterDynamicPath',
        value: function RegisterDynamicPath(prefix, paths) {
            return !!Tw2Store.SetStoreItem(this, 'dynamicPaths', prefix, paths);
        }

        /**
         * Registers dynamic paths from an object or array of objects
         * @param {{string:string[]}|Array<{string:string[]}>} obj
         * @returns {boolean}
         */

    }, {
        key: 'RegisterDynamicPaths',
        value: function RegisterDynamicPaths(obj) {
            return Tw2Store.RegisterFromObject(this, 'RegisterDynamicPath', obj);
        }

        /**
         * Checks if an extension exists
         * @param {string} ext
         * @returns {boolean}
         */

    }, {
        key: 'HasExtension',
        value: function HasExtension(ext) {
            return ext && ext in this._extensions;
        }

        /**
         * Gets a resource extension by name
         * @param {string} ext
         * @returns {?Function}
         */

    }, {
        key: 'GetExtension',
        value: function GetExtension(ext) {
            return Tw2Store.GetStoreItem(this, 'extensions', ext);
        }

        /**
         * Registers a resource extension
         * @param {name} ext
         * @param {Function} Constructor
         * @returns {boolean}
         */

    }, {
        key: 'RegisterExtension',
        value: function RegisterExtension(ext, Constructor) {
            if (typeof Constructor === 'function') {
                return !!Tw2Store.SetStoreItem(this, 'extensions', ext, Constructor);
            }
            return false;
        }

        /**
         * Registers resource extensions from an object or array of objects
         * @param {{string:Function}|Array<{string:Function}>} obj
         * @returns {boolean}
         */

    }, {
        key: 'RegisterExtensions',
        value: function RegisterExtensions(obj) {
            return Tw2Store.RegisterFromObject(this, 'RegisterExtension', obj);
        }

        /**
         * Checks if a constructor exists
         * @param {string} name
         * @returns {boolean}
         */

    }, {
        key: 'HasConstructor',
        value: function HasConstructor(name) {
            return name && name in this._constructors;
        }

        /**
         * Gets a library constructor by name
         * @param {string} name
         * @returns {?Function}
         */

    }, {
        key: 'GetConstructor',
        value: function GetConstructor(name) {
            return Tw2Store.GetStoreItem(this, 'constructors', name);
        }

        /**
         * Registers library constructors
         * @param {string} name
         * @param {Function} Constructor
         * @returns {boolean}
         */

    }, {
        key: 'RegisterConstructor',
        value: function RegisterConstructor(name, Constructor) {
            if (typeof Constructor === 'function') {
                return !!Tw2Store.SetStoreItem(this, 'constructors', name, Constructor);
            }
            return false;
        }

        /**
         * Registers library constructors from an object or array of objects
         * @param {{string:Function}|Array<{string:Function}>} obj
         * @returns {boolean}
         */

    }, {
        key: 'RegisterConstructors',
        value: function RegisterConstructors(obj) {
            return Tw2Store.RegisterFromObject(this, 'RegisterConstructor', obj);
        }

        /**
         * Checks if a variable exists
         * @param {string} name
         * @returns {boolean}
         */

    }, {
        key: 'HasVariable',
        value: function HasVariable(name) {
            return name && name in this._variables;
        }

        /**
         * Gets a variable by name
         * @param {string} name
         * @returns {?*}
         */

    }, {
        key: 'GetVariable',
        value: function GetVariable(name) {
            return Tw2Store.GetStoreItem(this, 'variables', name);
        }

        /**
         * Gets a variable's value
         * @param {string} name
         * @param {boolean} [serialize]
         * @returns {?*} null if the variable doesn't exist or it does but it has no GetValue method
         */

    }, {
        key: 'GetVariableValue',
        value: function GetVariableValue(name, serialize) {
            var variable = this.GetVariable(name);
            return variable && variable.GetValue ? variable.GetValue(serialize) : null;
        }

        /**
         * Sets a variable's value
         * @param {string} name
         * @param {*} value
         * @returns {?boolean} null if the variable doesn't exist or it does but has no SetValue method
         */

    }, {
        key: 'SetVariableValue',
        value: function SetVariableValue(name, value) {
            var variable = this.GetVariable(name);
            if (variable && variable.SetValue) {
                variable.SetValue(value);
                return true;
            }
            return null;
        }

        /**
         * Registers a variable
         * @param {string} name
         * @param {*|{value:*, type: string|Function}} [value]
         * @param {string|Function} [Type]
         * @returns {?*}
         */

    }, {
        key: 'RegisterVariable',
        value: function RegisterVariable(name, value, Type) {
            var variable = this.CreateType(name, value, Type);
            return Tw2Store.SetStoreItem(this, 'variables', name, variable);
        }

        /**
         * Registers variables from an object or array of objects
         * @param {{string:*|{value:*,type:string|Function}|Array<{string:*|{value:*,type:string|Function}>}} obj
         */

    }, {
        key: 'RegisterVariables',
        value: function RegisterVariables(obj) {
            return Tw2Store.RegisterFromObject(this, 'RegisterVariable', obj);
        }

        /**
         * Gets a parameter constructor by it's short name
         * @param {string} name
         * @returns {?Function}
         */

    }, {
        key: 'GetType',
        value: function GetType(name) {
            return Tw2Store.GetStoreItem(this, 'types', name);
        }

        /**
         * Checks if a type exists
         * @param {string} name
         * @returns {boolean}
         */

    }, {
        key: 'HasType',
        value: function HasType(name) {
            return name && name in this._types;
        }

        /**
         * Gets a type by value
         * @param {*} value
         * @returns {?Function}
         */

    }, {
        key: 'GetTypeByValue',
        value: function GetTypeByValue(value) {
            for (var type in this._types) {
                if (this._types.hasOwnProperty(type) && 'is' in this._types[type]) {
                    if (this._types[type]['is'](value)) return this._types[type];
                }
            }
            return null;
        }

        /**
         * Creates a type by value and/or type name or function
         * @param {string} name
         * @param {?*} [value]
         * @param {?|string|Function} [Type]
         * @returns {?*} new parameter
         */

    }, {
        key: 'CreateType',
        value: function CreateType(name, value, Type) {
            if (value && value.constructor.name === 'Object') {
                Type = value['Type'] || value['type'];
                value = value['value'];
            }

            if (!Type) {
                Type = this.GetTypeByValue(value);
            } else if (typeof Type === 'string') {
                Type = this.GetType(Type);
            }

            if (typeof Type === 'function') {
                return new Type(name, value);
            }

            return null;
        }

        /**
         * Registers a parameter type
         * @param {string} name
         * @param {Function} Constructor
         * @returns {boolean}
         */

    }, {
        key: 'RegisterType',
        value: function RegisterType(name, Constructor) {
            if (typeof Constructor === 'function') {
                return !!Tw2Store.SetStoreItem(this, 'types', name, Constructor);
            }
            return false;
        }

        /**
         * Registers parameter types from an object or array of objects
         * @param {{string: Function}|[{string:Function}]} obj
         * @returns {boolean}
         */

    }, {
        key: 'RegisterTypes',
        value: function RegisterTypes(obj) {
            return Tw2Store.RegisterFromObject(this, 'RegisterType', obj);
        }

        /**
         * Registers store values
         * @param {{}} [opt={}]
         * @param {boolean} [opt.uuid]
         * @param {*} opt.paths
         * @param {*} opt.dynamicPaths
         * @param {*} opt.types
         * @param {*} opt.constructors
         * @param {*} opt.extensions
         * @param {*} opt.variables
         */

    }, {
        key: 'Register',
        value: function Register() {
            var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if ('uuid' in opt) _math.util.enableUUID(opt.uuid);
            this.RegisterPaths(opt.paths);
            this.RegisterDynamicPaths(opt.dynamicPaths);
            this.RegisterTypes(opt.types);
            this.RegisterConstructors(opt.constructors);
            this.RegisterExtensions(opt.extensions);
            this.RegisterVariables(opt.variables);
        }

        /**
         * Gets a value from a store
         * - Records missing keys for debugging
         * @param {Tw2Store} store
         * @param {string} type
         * @param {string} key
         * @returns {?*}
         */

    }], [{
        key: 'GetStoreItem',
        value: function GetStoreItem(store, type, key) {
            if (typeof key === 'string') {
                var storeSet = store['_' + type],
                    singular = type.substring(0, type.length - 1);

                if (storeSet) {
                    if (key in storeSet) {
                        return storeSet[key];
                    }

                    if (!store._missing[type]) {
                        store._missing[type] = [];
                    }

                    if (!store._missing[type].includes(key)) {
                        store._missing[type].push(key);

                        _Tw2Logger.logger.log('store.warning', {
                            log: 'warning',
                            msg: 'Missing ' + singular + ': \'' + key + '\''
                        });
                    }
                }
            }

            return null;
        }

        /**
         * Sets a store value
         * @param {Tw2Store} store
         * @param {string} type
         * @param {string} key
         * @param {*} value
         */

    }, {
        key: 'SetStoreItem',
        value: function SetStoreItem(store, type) {
            var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
            var value = arguments[3];

            if (typeof key === 'string' && value !== undefined) {
                var storeSet = store['_' + type];
                if (storeSet) {
                    var existing = storeSet[key],
                        singular = type.substring(0, type.length - 1);

                    storeSet[key] = value;

                    if (!existing) {
                        _Tw2Logger.logger.log('store.registered', {
                            log: 'debug',
                            msg: 'Registered ' + singular + ': \'' + key + '\'',
                            hide: true
                        });
                    } else {
                        _Tw2Logger.logger.log('store.registered', {
                            log: 'debug',
                            msg: 'Re-registered ' + singular + ': \'' + key + '\'',
                            data: {
                                old_value: existing,
                                new_value: value
                            }
                        });
                    }

                    return value;
                }
            }
            return false;
        }

        /**
         * Converts an object or array of objects into single function calls
         * @param {Tw2Store} store
         * @param {string} funcName
         * @param {Array|Object} obj
         * @returns {boolean}
         */

    }, {
        key: 'RegisterFromObject',
        value: function RegisterFromObject(store, funcName, obj) {
            if (obj && funcName in store) {
                obj = Array.isArray(obj) ? obj : [obj];
                for (var i = 0; i < obj.length; i++) {
                    for (var key in obj[i]) {
                        if (obj[i].hasOwnProperty(key)) {
                            store[funcName](key, obj[i][key]);
                        }
                    }
                }
                return true;
            }
            return false;
        }
    }]);

    return Tw2Store;
}();

var store = exports.store = new Tw2Store();

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2Device = __webpack_require__(2);

Object.keys(_Tw2Device).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Device[key];
    }
  });
});

var _Tw2ResMan = __webpack_require__(6);

Object.keys(_Tw2ResMan).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ResMan[key];
    }
  });
});

var _Tw2Store = __webpack_require__(16);

Object.keys(_Tw2Store).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Store[key];
    }
  });
});

var _Tw2Logger = __webpack_require__(4);

Object.keys(_Tw2Logger).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Logger[key];
    }
  });
});

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleElementDeclaration = exports.Tw2ParticleElement = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2ParticleElement
 *
 * @param {Tw2ParticleElementDeclaration} decl
 * @property {number} elementType
 * @property {string} customName
 * @property {number} dimension
 * @property {number} usageIndex
 * @property {boolean} usedByGPU
 * @property buffer
 * @property {number} startOffset
 * @property {number} offset
 * @property {number} instanceStride
 * @property {number} vertexStride
 * @property {boolean} dirty
 * @class
 */
var Tw2ParticleElement = exports.Tw2ParticleElement = function Tw2ParticleElement(decl) {
    _classCallCheck(this, Tw2ParticleElement);

    this.elementType = decl.elementType;
    this.customName = decl.customName;
    this.dimension = decl.GetDimension();
    this.usageIndex = decl.usageIndex;
    this.usedByGPU = decl.usedByGPU;
    this.buffer = null;
    this.startOffset = 0;
    this.offset = 0;
    this.instanceStride = 0;
    this.vertexStride = 0;
    this.dirty = false;
};

/**
 * Tw2ParticleElementDeclaration
 *
 * @property {number} elementType=4
 * @property {string} customName
 * @property {number} dimension=1
 * @property {number} usageIndex
 * @property {boolean} usedByGPU
 * @class
 */


var Tw2ParticleElementDeclaration = exports.Tw2ParticleElementDeclaration = function () {
    function Tw2ParticleElementDeclaration() {
        _classCallCheck(this, Tw2ParticleElementDeclaration);

        this.elementType = 4;
        this.customName = '';
        this.dimension = 1;
        this.usageIndex = 0;
        this.usedByGPU = true;
    }

    /**
     * Gets the dimension of an element type
     * @returns {number}
     */


    _createClass(Tw2ParticleElementDeclaration, [{
        key: 'GetDimension',
        value: function GetDimension() {
            switch (this.elementType) {
                case Tw2ParticleElementDeclaration.Type.LIFETIME:
                    return 2;

                case Tw2ParticleElementDeclaration.Type.POSITION:
                    return 3;

                case Tw2ParticleElementDeclaration.Type.VELOCITY:
                    return 3;

                case Tw2ParticleElementDeclaration.Type.MASS:
                    return 1;
            }
            return this.dimension;
        }

        /**
         * GetDeclaration
         * @returns {Tw2VertexElement}
         */

    }, {
        key: 'GetDeclaration',
        value: function GetDeclaration() {
            var usage = void 0;
            switch (this.elementType) {
                case Tw2ParticleElementDeclaration.Type.LIFETIME:
                    usage = _core.Tw2VertexDeclaration.Type.TANGENT;
                    break;

                case Tw2ParticleElementDeclaration.Type.POSITION:
                    usage = _core.Tw2VertexDeclaration.Type.POSITION;
                    break;

                case Tw2ParticleElementDeclaration.Type.VELOCITY:
                    usage = _core.Tw2VertexDeclaration.Type.NORMAL;
                    break;

                case Tw2ParticleElementDeclaration.Type.MASS:
                    usage = _core.Tw2VertexDeclaration.Type.BINORMAL;
                    break;

                default:
                    usage = _core.Tw2VertexDeclaration.Type.TEXCOORD;
            }

            return new _core.Tw2VertexElement(usage, this.usageIndex, _core.device.gl.FLOAT, this.GetDimension());
        }
    }]);

    return Tw2ParticleElementDeclaration;
}();

/**
 * Particle element declaration types
 * @type {{LIFETIME: number, POSITION: number, VELOCITY: number, MASS: number, CUSTOM: number}}
 */


Tw2ParticleElementDeclaration.Type = {
    LIFETIME: 0,
    POSITION: 1,
    VELOCITY: 2,
    MASS: 3,
    CUSTOM: 4
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2Curve = __webpack_require__(3);

Object.keys(_Tw2Curve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Curve[key];
    }
  });
});

var _Tw2ColorCurve = __webpack_require__(141);

Object.keys(_Tw2ColorCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ColorCurve[key];
    }
  });
});

var _Tw2ColorCurve2 = __webpack_require__(142);

Object.keys(_Tw2ColorCurve2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ColorCurve2[key];
    }
  });
});

var _Tw2EventCurve = __webpack_require__(143);

Object.keys(_Tw2EventCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2EventCurve[key];
    }
  });
});

var _Tw2PerlinCurve = __webpack_require__(144);

Object.keys(_Tw2PerlinCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2PerlinCurve[key];
    }
  });
});

var _Tw2QuaternionCurve = __webpack_require__(145);

Object.keys(_Tw2QuaternionCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2QuaternionCurve[key];
    }
  });
});

var _Tw2RandomConstantCurve = __webpack_require__(146);

Object.keys(_Tw2RandomConstantCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RandomConstantCurve[key];
    }
  });
});

var _Tw2RigidOrientation = __webpack_require__(147);

Object.keys(_Tw2RigidOrientation).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RigidOrientation[key];
    }
  });
});

var _Tw2RotationCurve = __webpack_require__(148);

Object.keys(_Tw2RotationCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RotationCurve[key];
    }
  });
});

var _Tw2ScalarCurve = __webpack_require__(149);

Object.keys(_Tw2ScalarCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ScalarCurve[key];
    }
  });
});

var _Tw2ScalarCurve2 = __webpack_require__(150);

Object.keys(_Tw2ScalarCurve2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ScalarCurve2[key];
    }
  });
});

var _Tw2SineCurve = __webpack_require__(151);

Object.keys(_Tw2SineCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2SineCurve[key];
    }
  });
});

var _Tw2Vector2Curve = __webpack_require__(152);

Object.keys(_Tw2Vector2Curve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Vector2Curve[key];
    }
  });
});

var _Tw2Vector3Curve = __webpack_require__(153);

Object.keys(_Tw2Vector3Curve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Vector3Curve[key];
    }
  });
});

var _Tw2VectorCurve = __webpack_require__(154);

Object.keys(_Tw2VectorCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2VectorCurve[key];
    }
  });
});

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2BatchAccumulator = __webpack_require__(65);

Object.keys(_Tw2BatchAccumulator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2BatchAccumulator[key];
    }
  });
});

var _Tw2ForwardingRenderBatch = __webpack_require__(83);

Object.keys(_Tw2ForwardingRenderBatch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ForwardingRenderBatch[key];
    }
  });
});

var _Tw2GeometryBatch = __webpack_require__(23);

Object.keys(_Tw2GeometryBatch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2GeometryBatch[key];
    }
  });
});

var _Tw2GeometryLineBatch = __webpack_require__(84);

Object.keys(_Tw2GeometryLineBatch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2GeometryLineBatch[key];
    }
  });
});

var _Tw2RenderBatch = __webpack_require__(22);

Object.keys(_Tw2RenderBatch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RenderBatch[key];
    }
  });
});

var _Tw2InstancedMeshBatch = __webpack_require__(85);

Object.keys(_Tw2InstancedMeshBatch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2InstancedMeshBatch[key];
    }
  });
});

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2SamplerState = __webpack_require__(42);

Object.keys(_Tw2SamplerState).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2SamplerState[key];
    }
  });
});

var _Tw2SamplerOverride = __webpack_require__(79);

Object.keys(_Tw2SamplerOverride).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2SamplerOverride[key];
    }
  });
});

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2RenderBatch = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*eslint no-unused-vars:0*/


var _global = __webpack_require__(17);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2RenderBatch base class
 *
 * @property {number} renderMode
 * @property {Tw2PerObjectData} perObjectData
 * @class
 */
var Tw2RenderBatch = exports.Tw2RenderBatch = function () {
  function Tw2RenderBatch() {
    _classCallCheck(this, Tw2RenderBatch);

    this.renderMode = _global.device.RM_ANY;
    this.perObjectData = null;
  }

  /**
   * Commits the batch
   * @param {string} technique - technique name
   */


  _createClass(Tw2RenderBatch, [{
    key: 'Commit',
    value: function Commit(technique) {}
  }]);

  return Tw2RenderBatch;
}();

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2GeometryBatch = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2RenderBatch2 = __webpack_require__(22);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A render batch for geometry
 *
 * @property {Tw2GeometryRes} geometryRes
 * @property {Number} meshIx
 * @property {Number} start
 * @property {Number} count
 * @property {Tw2Effect} effect
 * @property {string} technique
 * @class
 */
var Tw2GeometryBatch = exports.Tw2GeometryBatch = function (_Tw2RenderBatch) {
    _inherits(Tw2GeometryBatch, _Tw2RenderBatch);

    function Tw2GeometryBatch() {
        _classCallCheck(this, Tw2GeometryBatch);

        var _this = _possibleConstructorReturn(this, (Tw2GeometryBatch.__proto__ || Object.getPrototypeOf(Tw2GeometryBatch)).call(this));

        _this.geometryRes = null;
        _this.meshIx = 0;
        _this.start = 0;
        _this.count = 1;
        _this.effect = null;
        return _this;
    }

    /**
     * Commits the Tw2InstancedMeshBatch for rendering
     * @param {string} technique - technique name
     */


    _createClass(Tw2GeometryBatch, [{
        key: 'Commit',
        value: function Commit(technique) {
            if (this.geometryRes && this.effect) {
                this.geometryRes.RenderAreas(this.meshIx, this.start, this.count, this.effect, technique);
            }
        }
    }]);

    return Tw2GeometryBatch;
}(_Tw2RenderBatch2.Tw2RenderBatch);

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2Parameter = __webpack_require__(7);

Object.keys(_Tw2Parameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Parameter[key];
    }
  });
});

var _Tw2FloatParameter = __webpack_require__(89);

Object.keys(_Tw2FloatParameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2FloatParameter[key];
    }
  });
});

var _Tw2MatrixParameter = __webpack_require__(90);

Object.keys(_Tw2MatrixParameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2MatrixParameter[key];
    }
  });
});

var _Tw2TransformParameter = __webpack_require__(91);

Object.keys(_Tw2TransformParameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2TransformParameter[key];
    }
  });
});

var _Tw2VariableParameter = __webpack_require__(92);

Object.keys(_Tw2VariableParameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2VariableParameter[key];
    }
  });
});

var _Tw2Vector2Parameter = __webpack_require__(93);

Object.keys(_Tw2Vector2Parameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Vector2Parameter[key];
    }
  });
});

var _Tw2Vector3Parameter = __webpack_require__(94);

Object.keys(_Tw2Vector3Parameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Vector3Parameter[key];
    }
  });
});

var _Tw2Vector4Parameter = __webpack_require__(95);

Object.keys(_Tw2Vector4Parameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Vector4Parameter[key];
    }
  });
});

var _Tw2TextureParameter = __webpack_require__(41);

Object.keys(_Tw2TextureParameter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2TextureParameter[key];
    }
  });
});

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2RawData = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Stores raw data for {@link Tw2PerObjectData}
 *
 * @param {{string:Float32Array|Array|number}} [declarations] An optional object containing raw data declarations
 * @property {number} nextOffset
 * @property {Float32Array} data
 * @property {*} elements
 * @class
 */
var Tw2RawData = exports.Tw2RawData = function () {
    function Tw2RawData(declarations) {
        _classCallCheck(this, Tw2RawData);

        this.nextOffset = 0;
        this.data = null;
        this.elements = {};

        if (declarations) {
            this.DeclareFromObject(declarations);
        }
    }

    /**
     * Sets a element value
     * @param {string} name
     * @param {Float32Array|Array} value
     */


    _createClass(Tw2RawData, [{
        key: 'Set',
        value: function Set(name, value) {
            var el = this.elements[name];
            this.data.set(value.length > el.size ? value.subarray(0, el.size) : value, el.offset);
        }

        /**
         * Gets an element's array value
         * @param {string} name
         * @return {Float32Array}
         */

    }, {
        key: 'Get',
        value: function Get(name) {
            return this.elements[name].array;
        }

        /**
         * Gets an element's array value from the share data array
         * @param {string} name
         * @return {Float32Array}
         */

    }, {
        key: 'GetData',
        value: function GetData(name) {
            return this.data.subarray(this.elements[name].offset, this.elements[name].offset + this.elements[name].array.length);
        }

        /**
         * Creates the raw data element arrays
         */

    }, {
        key: 'Create',
        value: function Create() {
            this.data = new Float32Array(this.nextOffset);
            for (var name in this.elements) {
                if (this.elements.hasOwnProperty(name)) {
                    var el = this.elements[name];
                    el.array = this.data.subarray(el.offset, el.offset + el.size);

                    if (el.value !== null) {
                        if (el.size === 1) {
                            el.array[0] = el.value;
                        } else {
                            for (var i = 0; i < el.size; i++) {
                                el.array[i] = el.value[i];
                            }
                        }
                        el.value = null;
                    }
                }
            }
        }

        /**
         * Declares a raw data element
         * @param {String} name
         * @param {number} size
         * @param {!|number|Array|Float32Array} [value=null] optional value to set on raw data creation
         */

    }, {
        key: 'Declare',
        value: function Declare(name, size) {
            var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

            this.elements[name] = {
                offset: this.nextOffset,
                size: size,
                array: null,
                value: value
            };

            this.nextOffset += size;
        }

        /**
         * Declares raw data from an object and then creates the elements
         * @param {{string:Float32Array|Array|number}} declarations
         */

    }, {
        key: 'DeclareFromObject',
        value: function DeclareFromObject() {
            var declarations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            for (var name in declarations) {
                if (declarations.hasOwnProperty(name)) {
                    var value = declarations[name];

                    if (typeof value === 'number') {
                        this.Declare(name, 1, value);
                    } else if (_math.util.isArrayLike(value)) {
                        if (value.length === 1) {
                            this.Declare(name, value.length, value);
                        }
                    } else {
                        throw new Error('Invalid declaration type: ' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)));
                    }
                }
            }

            this.Create();
        }
    }]);

    return Tw2RawData;
}();

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2ParticleEmitter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-unused-vars:0 */


var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Particle Emitter base class
 *
 * @property {number|string} id
 * @property {string} name
 * @property {Tw2ParticleSystem} particleSystem
 * @class
 */
var Tw2ParticleEmitter = exports.Tw2ParticleEmitter = function () {
  function Tw2ParticleEmitter() {
    _classCallCheck(this, Tw2ParticleEmitter);

    this._id = _math.util.generateID();
    this.name = '';
    this.particleSystem = null;
  }

  /**
   * Initializes the particle emitter
   */


  _createClass(Tw2ParticleEmitter, [{
    key: 'Initialize',
    value: function Initialize() {}

    /**
     * Per frame update
     * @param {number} dt - delta time
     */

  }, {
    key: 'Update',
    value: function Update(dt) {}
  }]);

  return Tw2ParticleEmitter;
}();

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleAttributeGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint no-unused-vars:0 */


var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2ParticleAttributeGenerator base class
 *
 * @property {number|string} id
 * @property {string} name
 * @class
 */
var Tw2ParticleAttributeGenerator = exports.Tw2ParticleAttributeGenerator = function () {
    function Tw2ParticleAttributeGenerator() {
        _classCallCheck(this, Tw2ParticleAttributeGenerator);

        this._id = _math.util.generateID();
        this.name = '';
    }

    /**
     * Binds a particle system element to the generator
     * @param {Tw2ParticleSystem} ps
     * @returns {boolean} True if successfully bound
     */


    _createClass(Tw2ParticleAttributeGenerator, [{
        key: 'Bind',
        value: function Bind(ps) {
            return false;
        }

        /**
         * Generates the attributes
         * @param {Tw2ParticleElement} position
         * @param {Tw2ParticleElement} velocity
         * @param {number} index
         */

    }, {
        key: 'Generate',
        value: function Generate(position, velocity, index) {}
    }]);

    return Tw2ParticleAttributeGenerator;
}();

Tw2ParticleAttributeGenerator.global = {
    vec3_0: _math.vec3.create()
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2EffectRes = __webpack_require__(133);

Object.keys(_Tw2EffectRes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2EffectRes[key];
    }
  });
});

var _Tw2GeometryRes = __webpack_require__(135);

Object.keys(_Tw2GeometryRes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2GeometryRes[key];
    }
  });
});

var _Tw2LoadingObject = __webpack_require__(37);

Object.keys(_Tw2LoadingObject).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2LoadingObject[key];
    }
  });
});

var _Tw2Resource = __webpack_require__(12);

Object.keys(_Tw2Resource).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Resource[key];
    }
  });
});

var _Tw2TextureRes = __webpack_require__(51);

Object.keys(_Tw2TextureRes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2TextureRes[key];
    }
  });
});

var _Tw2VideoRes = __webpack_require__(136);

Object.keys(_Tw2VideoRes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2VideoRes[key];
    }
  });
});

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2BinaryReader = __webpack_require__(39);

Object.keys(_Tw2BinaryReader).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2BinaryReader[key];
    }
  });
});

var _Tw2ObjectReader = __webpack_require__(38);

Object.keys(_Tw2ObjectReader).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ObjectReader[key];
    }
  });
});

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var num = exports.num = {};

/**
 * biCumulative
 *
 * @param {number} t
 * @param {number} order
 * @returns {number}
 */
num.biCumulative = function (t, order) {
    if (order === 1) {
        var some = 1.0 - t;
        return 1.0 - some * some * some;
    } else if (order === 2) {
        return 3.0 * t * t - 2.0 * t * t * t;
    } else {
        return t * t * t;
    }
};

/**
 * Exponential decay
 * 
 * @param {number} omega0
 * @param {number} torque
 * @param {number} I - inertia
 * @param {number} d - drag
 * @param {number} time - time
 * @returns {number}
 */
num.exponentialDecay = function (omega0, torque, I, d, time) {
    return torque * time / d + I * (omega0 * d - torque) / (d * d) * (1.0 - Math.pow(Math.E, -d * time / I));
};

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["fromMat4"] = fromMat4;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromMat2d"] = fromMat2d;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["normalFromMat4"] = normalFromMat4;
/* harmony export (immutable) */ __webpack_exports__["projection"] = projection;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b01 = a22 * a11 - a12 * a21;
  let b11 = -a22 * a10 + a12 * a20;
  let b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  let det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  out[0] = (a11 * a22 - a12 * a21);
  out[1] = (a02 * a21 - a01 * a22);
  out[2] = (a01 * a12 - a02 * a11);
  out[3] = (a12 * a20 - a10 * a22);
  out[4] = (a00 * a22 - a02 * a20);
  out[5] = (a02 * a10 - a00 * a12);
  out[6] = (a10 * a21 - a11 * a20);
  out[7] = (a01 * a20 - a00 * a21);
  out[8] = (a00 * a11 - a01 * a10);
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b00 = b[0], b01 = b[1], b02 = b[2];
  let b10 = b[3], b11 = b[4], b12 = b[5];
  let b20 = b[6], b21 = b[7], b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],
    x = v[0], y = v[1];

  out[0] = a00;
  out[1] = a01;
  out[2] = a02;

  out[3] = a10;
  out[4] = a11;
  out[5] = a12;

  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],

    s = Math.sin(rad),
    c = Math.cos(rad);

  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;

  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;

  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function scale(out, a, v) {
  let x = v[0], y = v[1];

  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];

  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];

  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad), c = Math.cos(rad);

  out[0] = c;
  out[1] = s;
  out[2] = 0;

  out[3] = -s;
  out[4] = c;
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;

  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;

  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;

  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
          a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
          a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}



/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] &&
         a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
         a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat3.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["hermite"] = hermite;
/* harmony export (immutable) */ __webpack_exports__["bezier"] = bezier;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["angle"] = angle;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return x*x + y*y + z*z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return x*x + y*y + z*z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let len = x*x + y*y + z*z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2];
  let bx = b[0], by = b[1], bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  let factorTimes2 = t * t;
  let factor1 = factorTimes2 * (2 * t - 3) + 1;
  let factor2 = factorTimes2 * (t - 2) + t;
  let factor3 = factorTimes2 * (t - 1);
  let factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  let inverseFactor = 1 - t;
  let inverseFactorTimesTwo = inverseFactor * inverseFactor;
  let factorTimes2 = t * t;
  let factor1 = inverseFactorTimesTwo * inverseFactor;
  let factor2 = 3 * t * inverseFactorTimesTwo;
  let factor3 = 3 * factorTimes2 * inverseFactor;
  let factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  let r = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0 * Math.PI;
  let z = (__WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0) - 1.0;
  let zScale = Math.sqrt(1.0-z*z) * scale;

  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  let w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

  let x = a[0], y = a[1], z = a[2];
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  r[1] = p[1];
  r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  let tempA = fromValues(a[0], a[1], a[2]);
  let tempB = fromValues(b[0], b[1], b[2]);

  normalize(tempA, tempA);
  normalize(tempB, tempB);

  let cosine = dot(tempA, tempB);

  if(cosine > 1.0) {
    return 0;
  }
  else if(cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2];
  let b0 = b[0], b1 = b[1], b2 = b[2];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec3.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec3.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec3.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec3.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 3;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function fromValues(x, y, z, w) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  let len = x*x + y*y + z*z + w*w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  let aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
function random(out, vectorScale) {
  vectorScale = vectorScale || 1.0;

  //TODO: This is a pretty awful way of doing this. Find something better.
  out[0] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[1] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[2] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[3] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  normalize(out, out);
  scale(out, out, vectorScale);
  return out;
}

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
function transformQuat(out, a, q) {
  let x = a[0], y = a[1], z = a[2];
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
}

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec4.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec4.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec4.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec4.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 4;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.vec3 = undefined;

var _glMatrix = __webpack_require__(11);

var _num = __webpack_require__(30);

exports.vec3 = _glMatrix.vec3;

/**
 * Sets a vec3 with cartesian coordinates from spherical coordinates and an optional center point
 * @param {vec3} out       - receiving vec3
 * @param {vec3} spherical - source vec3 with spherical coordinates (phi, theta, radius)
 * @param {vec3} [center]  - Optional center
 * @returns {vec3} out     - receiving vec3
 */

_glMatrix.vec3.fromSpherical = function (out, spherical, center) {
    var phi = spherical[0],
        theta = spherical[1],
        radius = spherical[2];

    out[0] = radius * Math.sin(phi) * Math.sin(theta);
    out[1] = radius * Math.cos(theta);
    out[2] = radius * Math.cos(phi) * Math.sin(theta);

    if (center) {
        out[0] += center[0];
        out[1] += center[1];
        out[2] += center[2];
    }

    return out;
};

/**
 * Gets spherical coordinates from a vector
 * @param {vec3} out
 * @param {vec3} a
 * @returns {vec3} out
 */
_glMatrix.vec3.getSpherical = function (out, a) {
    var phi = 0,
        theta = 0,
        radius = _glMatrix.vec3.length(a);

    if (radius !== 0) {
        phi = Math.acos(Math.max(a[1] / radius, Math.min(-1, 1)));
        theta = Math.atan2(a[0], a[2]);
    }

    out[0] = phi;
    out[1] = theta;
    out[2] = radius;
    return out;
};

/**
 * Exponential decay
 *
 * @param {vec3} out
 * @param {vec3} omega0
 * @param {vec3} torque
 * @param {number} I
 * @param {number} drag
 * @param {number} time
 * @returns {vec3} out
 */
_glMatrix.vec3.exponentialDecay = function (out, omega0, torque, I, drag, time) {
    out[0] = _num.num.exponentialDecay(omega0[0], torque[0], I, drag, time);
    out[1] = _num.num.exponentialDecay(omega0[1], torque[1], I, drag, time);
    out[2] = _num.num.exponentialDecay(omega0[2], torque[2], I, drag, time);
    return out;
};

/**
 * Projects a local vec3 to screen space with viewport settings
 * @param {vec3} out           - receiving vec3
 * @param {vec3} a             - local vec3
 * @param {mat4} m             - model view projection matrix
 * @param {vec4} viewport      - view port settings (x, y, width, height)
 * @returns {vec3} out         - receiving vec3 (x, y, perspectiveDivide)
 */
_glMatrix.vec3.project = function (out, a, m, viewport) {
    var x = a[0],
        y = a[1],
        z = a[2];

    var outX = m[0] * x + m[4] * y + m[8] * z + m[12],
        outY = m[1] * x + m[5] * y + m[9] * z + m[13],
        perD = m[3] * x + m[7] * y + m[11] * z + m[15];

    var projectionX = (outX / perD + 1) / 2;
    var projectionY = 1 - (outY / perD + 1) / 2;

    out[0] = projectionX * viewport[2] + viewport[0];
    out[1] = projectionY * viewport[3] + viewport[1];
    out[2] = perD;
    return out;
};

/**
 * Unprojects a vec3 with canvas coordinates to world space
 * @param {vec3} out            - receiving vec3
 * @param {vec3} a              - vec3 to unproject
 * @param {mat4} invViewProj    - inverse view projection matrix
 * @param {vec4|Array} viewport - [ x, y, width, height ]
 * @returns {vec3} out
 * @throw On perspective divide error
 */
_glMatrix.vec3.unproject = function () {
    var vec4_0 = void 0;

    return function unProject(out, a, invViewProj, viewport) {
        if (!vec4_0) vec4_0 = _glMatrix.vec4.create();

        var x = a[0],
            y = a[1],
            z = a[2];

        vec4_0[0] = (x - viewport[0]) * 2.0 / viewport[2] - 1.0;
        vec4_0[1] = (y - viewport[1]) * 2.0 / viewport[3] - 1.0;
        vec4_0[2] = 2.0 * z - 1.0;
        vec4_0[3] = 1.0;

        _glMatrix.vec4.transformMat4(vec4_0, vec4_0, invViewProj);

        if (vec4_0[3] === 0.0) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            throw new Error('Perspective divide error');
        }

        out[0] = vec4_0[0] / vec4_0[3];
        out[1] = vec4_0[1] / vec4_0[3];
        out[2] = vec4_0[2] / vec4_0[3];
        return out;
    };
}();

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec4 = undefined;

var _glMatrix = __webpack_require__(11);

exports.vec4 = _glMatrix.vec4;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Emitter privates
 * @type {WeakMap<object, *>}
 */
var PRIVATE = new WeakMap();

/**
 * Tw2EventEmitter
 * @class
 */

var Tw2EventEmitter = exports.Tw2EventEmitter = function () {
    function Tw2EventEmitter() {
        _classCallCheck(this, Tw2EventEmitter);

        PRIVATE.set(this, { events: {} });
    }

    /**
     * Emits an event
     * @param {string} eventName
     * @param {*} [e={}]
     * @returns {Tw2EventEmitter}
     * @emit event_added { eventName: string} - the first time an event is emitted
     */


    _createClass(Tw2EventEmitter, [{
        key: 'emit',
        value: function emit(eventName, e) {
            eventName = eventName.toLowerCase();

            // Short cut to creating a log output
            if (e && e['__log']) {
                e.log = this.log(eventName, e['__log']);
                delete e['__log'];
            }

            var events = PRIVATE.get(this).events;
            if (eventName in events) {
                events[eventName].forEach(function (value, key) {
                    key.call(value.context, e);
                    if (value.once) events[eventName].delete(key);
                });
            } else {
                events[eventName] = new Set();
                this.emit('event_added', { eventName: eventName });
            }

            return this;
        }

        /**
         * Adds a listener to an event
         * @param {Array|string} eventName
         * @param {Function} listener
         * @param {*} [context=undefined]
         * @param {boolean} [once=false]
         * @returns {Tw2EventEmitter}
         */

    }, {
        key: 'on',
        value: function on(eventName, listener) {
            var _this = this;

            var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
            var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

            var events = PRIVATE.get(this).events;
            eventName = eventName.toLowerCase();
            if (!events[eventName]) {
                events[eventName] = new Set();
                events[eventName].add(function () {
                    return _this.emit('event_added', { eventName: eventName });
                }, { once: true });
            }
            events[eventName].add(listener, { context: context, once: once });
            return this;
        }

        /**
         * Adds a listener to an event, and clears it after it's first emit
         * @param {string} eventName
         * @param {Function} listener
         * @param {*} [context]
         * @returns {Tw2EventEmitter}
         */

    }, {
        key: 'once',
        value: function once(eventName, listener, context) {
            return this.on(eventName, listener, context, true);
        }

        /**
         * Removes a listener from a specific event or from all by passing '*' as the eventName
         * @param {string} eventName
         * @param {Function} listener
         * @returns {Tw2EventEmitter}
         */

    }, {
        key: 'off',
        value: function off(eventName, listener) {
            var events = PRIVATE.get(this).events;
            eventName = eventName.toLowerCase();
            if (eventName in events) events[eventName].delete(listener);
            return this;
        }

        /**
         * Deletes an event and it's listeners
         * @param {string} eventName
         * @returns {Tw2EventEmitter}
         * @emit event_removed { eventName: String }
         */

    }, {
        key: 'del',
        value: function del(eventName) {
            var events = PRIVATE.get(this).events;
            eventName = eventName.toLowerCase();
            if (eventName in events) {
                this.emit('event_removed', { eventName: eventName });
                delete events[eventName];
            }
            return this;
        }

        /**
         * Clears a listener from all events
         * @param {Function} listener
         * @returns {Tw2EventEmitter}
         */

    }, {
        key: 'clr',
        value: function clr(listener) {
            var events = PRIVATE.get(this).events;
            for (var eventName in events) {
                if (events.hasOwnProperty(eventName) && events[eventName].has(listener)) {
                    events[eventName].delete(listener);
                }
            }
            return this;
        }

        /**
         * Kills all events and listeners from the emitter
         * @returns {Tw2EventEmitter}
         * @emit event_kill
         */

    }, {
        key: 'kill',
        value: function kill() {
            this.emit('event_kill');
            PRIVATE.get(this).events = {};
            return this;
        }

        /**
         * Logs an event log
         * @param {string} eventName
         * @param {eventLog} eventLog
         * @returns {eventLog}
         */

    }, {
        key: 'log',
        value: function log(eventName, eventLog) {
            if (this.constructor.logger) {
                this.constructor.logger.log(eventName, eventLog);
            }
            return eventLog;
        }
    }]);

    return Tw2EventEmitter;
}();

/**
 * Global logger
 * @type {*}
 */


Tw2EventEmitter.logger = null;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2LoadingObject = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2ResMan = __webpack_require__(6);

var _Tw2Logger = __webpack_require__(4);

var _Tw2Resource2 = __webpack_require__(12);

var _Tw2ObjectReader = __webpack_require__(38);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2LoadingObject
 *
 * @property {string} _redContents          - object's .red file xml contents
 * @property {Number} _inPrepare            - the amount of child objects to prepare
 * @property {Array.<Object>} _objects      - the child objects to prepare
 * @property {Tw2ObjectReader} _constructor - A function for constructing child objects
 * @class
 */
var Tw2LoadingObject = exports.Tw2LoadingObject = function (_Tw2Resource) {
    _inherits(Tw2LoadingObject, _Tw2Resource);

    function Tw2LoadingObject() {
        _classCallCheck(this, Tw2LoadingObject);

        var _this = _possibleConstructorReturn(this, (Tw2LoadingObject.__proto__ || Object.getPrototypeOf(Tw2LoadingObject)).call(this));

        _this._redContents = null;
        _this._inPrepare = null;
        _this._objects = [];
        _this._constructor = null;
        return _this;
    }

    /**
     * Adds a child object
     * @param {Object} object
     * @param {Function} callback
     * @returns {Object}
     */


    _createClass(Tw2LoadingObject, [{
        key: 'AddObject',
        value: function AddObject(object, callback) {
            object._loadCallback = callback;
            this._objects.push(object);
            return object;
        }

        /**
         * Prepare
         * @param text
         */

    }, {
        key: 'Prepare',
        value: function Prepare(text) {
            if (!_Tw2ObjectReader.Tw2ObjectReader.IsValidXML(text)) {
                _Tw2Logger.logger.log('res.error', {
                    log: 'error',
                    src: ['Tw2LoadingObject', 'Prepare'],
                    msg: 'Invalid XML',
                    path: this.path,
                    type: 'xml.invalid'
                });
                this.PrepareFinished(false);
                return;
            }

            if (this._inPrepare === null) {
                this._redContents = text;
                this._constructor = new _Tw2ObjectReader.Tw2ObjectReader(this._redContents);
                this._inPrepare = 0;
            }

            while (this._inPrepare < this._objects.length) {
                try {
                    this._objects[this._inPrepare]._loadCallback(this._constructor.Construct());
                } catch (e) {
                    _Tw2Logger.logger.log('res.error', {
                        log: 'error',
                        src: ['Tw2LoadingObject', 'Prepare'],
                        msg: 'Error preparing resource',
                        path: this.path,
                        type: 'prepare',
                        err: e
                    });
                }

                this._inPrepare++;
            }

            _Tw2ResMan.resMan.motherLode.Remove(this.path);
            this.PrepareFinished(true);
        }
    }]);

    return Tw2LoadingObject;
}(_Tw2Resource2.Tw2Resource);

/**
 * HTTP request response type
 * @type {string}
 */


Tw2LoadingObject.prototype.requestResponseType = 'arraybuffer';

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ObjectReader = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Logger = __webpack_require__(4);

var _Tw2Store = __webpack_require__(16);

var _Tw2BinaryReader = __webpack_require__(39);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2ObjectReader
 *
 * @param {string} xmlNode
 * @property {string} xmlNode
 * @property {?Array} _inputStack
 * @property {?Array} _initializeObjects
 * @property {?Object} _ids
 * @property {Tw2BinaryReader} _reader
 * @property {?Array} _stringTable
 * @property {?number} _start
 * @class
 */
var Tw2ObjectReader = exports.Tw2ObjectReader = function () {
    function Tw2ObjectReader(xmlNode) {
        _classCallCheck(this, Tw2ObjectReader);

        this.xmlNode = xmlNode;
        this._inputStack = null;
        this._initializeObjects = null;
        this._ids = {};
        this._reader = null;
        this._stringTable = null;
        this._start = null;

        if (xmlNode) this.Initialize();
    }

    /**
     * Initializes the object reader
     */


    _createClass(Tw2ObjectReader, [{
        key: 'Initialize',
        value: function Initialize() {
            if (!Tw2ObjectReader.IsValidXML(this.xmlNode)) {
                _Tw2Logger.logger.log('res.error', {
                    log: 'error',
                    src: ['Tw2ObjectReader', 'constructor'],
                    msg: 'Invalid Binary',
                    type: 'redbin.invalid',
                    data: this.xmlNode
                });
                return;
            }

            this._reader = new _Tw2BinaryReader.Tw2BinaryReader(new Uint8Array(this.xmlNode));
            this._reader.cursor += 6;
            this._stringTable = [];

            var count = this._reader.ReadUInt32();
            for (var i = 0; i < count; ++i) {
                var len = this._reader.ReadUInt16();
                this._stringTable.push(String.fromCharCode.apply(null, this._reader.data.subarray(this._reader.cursor, this._reader.cursor + len)));
                this._reader.cursor += len;
            }

            this._start = this._reader.cursor;
        }

        /**
         * Constructs the loaded xml
         * @returns {*}
         */

    }, {
        key: 'Construct',
        value: function Construct() {
            this._reader.cursor = this._start;
            return Tw2ObjectReader.ReadElement(this);
        }

        /**
         * Checks that the passed xml is valid
         * @param {*} xmlNode
         * @returns {boolean}
         */

    }], [{
        key: 'IsValidXML',
        value: function IsValidXML(xmlNode) {
            return xmlNode && String.fromCharCode.apply(null, new Uint8Array(xmlNode).subarray(0, 6)) === 'binred';
        }

        /**
         * Constructs an object
         * @param {*} data
         * @returns {*}
         */

    }, {
        key: 'ConstructObject',
        value: function ConstructObject(data) {
            if (data.type === 'json') {
                return data;
            }

            var object = void 0;

            var Constructor = _Tw2Store.store.GetConstructor(data.type);
            if (!Constructor) {
                _Tw2Logger.logger.log('res.error', {
                    log: 'throw',
                    src: ['Tw2ObjectReader', 'Tw2ObjectReader.ConstructObject'],
                    msg: 'Object with undefined type',
                    type: 'xml.type',
                    value: data.type
                });

                throw new Error('YAML: object with undefined type \'' + data.type + '\'');
            }

            try {
                object = new Constructor();
            } catch (e) {
                _Tw2Logger.logger.log('res.error', {
                    log: 'throw',
                    src: ['Tw2ObjectReader', 'Tw2ObjectReader.ConstructObject'],
                    msg: 'Error instantiating constructor',
                    type: 'xml.type.constructor',
                    value: data.type,
                    err: e
                });

                throw e;
            }

            for (var k in data) {
                if (data.hasOwnProperty(k) && k !== 'type') {
                    if (object[k] === undefined && this.DEBUG_ENABLED) {
                        object[k] = null;
                    }

                    if (object[k] && data[k].constructor === Object) {
                        for (var key in data[k]) {
                            if (data[k].hasOwnProperty(key)) {
                                object[k][key] = data[k][key];
                            }
                        }
                    } else {
                        object[k] = data[k];
                    }
                }
            }

            if ('Initialize' in object) {
                object.Initialize();
            }

            return object;
        }

        /**
         * Reads a Uint
         * @param {Tw2ObjectReader} objReader
         * @param {number} type
         * @returns {*}
         */

    }, {
        key: 'ReadUint',
        value: function ReadUint(objReader, type) {
            switch (type & 0x30) {
                case this.ElementSize.SMALL:
                    return objReader._reader.ReadUInt8();

                case this.ElementSize.MEDIUM:
                    return objReader._reader.ReadUInt16();

                default:
                    return objReader._reader.ReadUInt32();
            }
        }

        /**
         * Reads element data
         * @param {Tw2ObjectReader} objReader
         * @param {number} type
         * @returns {*}
         */

    }, {
        key: 'ReadElementData',
        value: function ReadElementData(objReader, type) {
            var offset = void 0,
                i = void 0,
                result = void 0,
                count = void 0,
                elementType = void 0;
            switch (type & 0xf) {
                case this.ElementRawType.NULL:
                    return null;

                case this.ElementRawType.BOOL:
                    switch (type & 0x30) {
                        case this.ElementSize.SMALL:
                            return objReader._reader.ReadUInt8() !== 0;

                        case this.ElementSize.MEDIUM:
                            return false;

                        default:
                            return true;
                    }

                case this.ElementRawType.INT:
                    switch (type & 0x30) {
                        case this.ElementSize.SMALL:
                            return objReader._reader.ReadInt8();

                        case this.ElementSize.MEDIUM:
                            return objReader._reader.ReadInt16();

                        default:
                            return objReader._reader.ReadInt32();
                    }

                case this.ElementRawType.UINT:
                    return this.ReadUint(objReader, type);

                case this.ElementRawType.FLOAT:
                    switch (type & 0x30) {
                        case this.ElementSize.SMALL:
                            return objReader._reader.ReadFloat16();

                        case this.ElementSize.MEDIUM:
                            return objReader._reader.ReadFloat32();

                        default:
                            throw Error('float64 values are not yet supported');
                    }

                case this.ElementRawType.STRING:
                    offset = this.ReadUint(objReader, type);
                    return objReader._stringTable[offset];

                case this.ElementRawType.ARRAY:
                    count = this.ReadUint(objReader, type);
                    result = [];
                    for (i = 0; i < count; ++i) {
                        result.push(this.ReadElement(objReader));
                    }
                    return result;

                case this.ElementRawType.MAPPING:
                    count = this.ReadUint(objReader, type);
                    result = {};
                    for (i = 0; i < count; ++i) {
                        result[objReader._stringTable[this.ReadUint(objReader, type)]] = this.ReadElement(objReader);
                    }
                    return result;

                case this.ElementRawType.OBJECT:
                    count = this.ReadUint(objReader, type);
                    result = {};
                    for (i = 0; i < count; ++i) {
                        result[objReader._stringTable[this.ReadUint(objReader, type)]] = this.ReadElement(objReader);
                    }
                    return this.ConstructObject(result);

                case this.ElementRawType.TYPED_ARRAY:
                    count = this.ReadUint(objReader, type);
                    elementType = objReader._reader.ReadUInt8();
                    result = [];
                    for (i = 0; i < count; ++i) {
                        result.push(this.ReadElementData(objReader, elementType));
                    }

                    if (elementType in this.TypedArrays) {
                        result = new this.TypedArrays[elementType](result);
                    }
                    return result;

                case this.ElementRawType.TYPED_MAPPING:
                    count = this.ReadUint(objReader, type);
                    elementType = objReader._reader.ReadUInt8();
                    result = {};
                    for (i = 0; i < count; ++i) {
                        result[objReader._stringTable[this.ReadUint(objReader, type)]] = this.ReadElementData(objReader, elementType);
                    }
                    return result;
            }
        }

        /**
         * Reads an element
         * @property {Tw2ObjectReader} objReader
         * @returns {*}
         */

    }, {
        key: 'ReadElement',
        value: function ReadElement(objReader) {
            var type = objReader._reader.ReadUInt8();
            if (type === this.REFERENCE_BIT) {
                return objReader._ids[objReader._reader.ReadUInt16()];
            }

            var id = void 0;
            if ((type & this.ID_BIT) !== 0) {
                id = objReader._reader.ReadUInt16();
            }

            var result = this.ReadElementData(objReader, type & 0x3F);
            if ((type & this.ID_BIT) !== 0) {
                objReader._ids[id] = result;
            }
            return result;
        }
    }]);

    return Tw2ObjectReader;
}();

/**
 * ID Bit
 * @type {number}
 */


Tw2ObjectReader.ID_BIT = 1 << 6;

/**
 * Reference Bit
 * @type {number}
 */
Tw2ObjectReader.REFERENCE_BIT = 1 << 7;

/**
 * Raw element types
 * @type {{}}
 */
Tw2ObjectReader.ElementRawType = {
    'NULL': 0,
    'BOOL': 1,
    'INT': 2,
    'UINT': 3,
    'FLOAT': 4,
    'STRING': 5,
    'ARRAY': 6,
    'MAPPING': 7,
    'OBJECT': 8,
    'TYPED_ARRAY': 9,
    'TYPED_MAPPING': 10
};

/**
 * Element sizes
 * @type {{SMALL: number, MEDIUM: number, LARGE: number}}
 */
Tw2ObjectReader.ElementSize = {
    'SMALL': 0,
    'MEDIUM': 1 << 4,
    'LARGE': 2 << 4
};

/**
 * Element types
 * @type {{}}
 */
Tw2ObjectReader.ElementTypes = {
    'NULL': Tw2ObjectReader.ElementRawType.NULL | Tw2ObjectReader.ElementSize.SMALL,

    'BOOL': Tw2ObjectReader.ElementRawType.BOOL | Tw2ObjectReader.ElementSize.SMALL,
    'FALSE': Tw2ObjectReader.ElementRawType.BOOL | Tw2ObjectReader.ElementSize.MEDIUM,
    'TRUE': Tw2ObjectReader.ElementRawType.BOOL | Tw2ObjectReader.ElementSize.LARGE,

    'INT8': Tw2ObjectReader.ElementRawType.INT | Tw2ObjectReader.ElementSize.SMALL,
    'UINT8': Tw2ObjectReader.ElementRawType.UINT | Tw2ObjectReader.ElementSize.SMALL,
    'INT16': Tw2ObjectReader.ElementRawType.INT | Tw2ObjectReader.ElementSize.MEDIUM,
    'UINT16': Tw2ObjectReader.ElementRawType.UINT | Tw2ObjectReader.ElementSize.MEDIUM,
    'INT32': Tw2ObjectReader.ElementRawType.INT | Tw2ObjectReader.ElementSize.LARGE,
    'UINT32': Tw2ObjectReader.ElementRawType.UINT | Tw2ObjectReader.ElementSize.LARGE,

    'FLOAT16': Tw2ObjectReader.ElementRawType.FLOAT | Tw2ObjectReader.ElementSize.SMALL,
    'FLOAT32': Tw2ObjectReader.ElementRawType.FLOAT | Tw2ObjectReader.ElementSize.MEDIUM,
    'FLOAT64': Tw2ObjectReader.ElementRawType.FLOAT | Tw2ObjectReader.ElementSize.LARGE,

    'SHORT_STRING': Tw2ObjectReader.ElementRawType.STRING | Tw2ObjectReader.ElementSize.SMALL,
    'MEDIUM_STRING': Tw2ObjectReader.ElementRawType.STRING | Tw2ObjectReader.ElementSize.MEDIUM,
    'LARGE_STRING': Tw2ObjectReader.ElementRawType.STRING | Tw2ObjectReader.ElementSize.LARGE,

    'SHORT_ARRAY': Tw2ObjectReader.ElementRawType.ARRAY | Tw2ObjectReader.ElementSize.SMALL,
    'MEDIUM_ARRAY': Tw2ObjectReader.ElementRawType.ARRAY | Tw2ObjectReader.ElementSize.MEDIUM,
    'LARGE_ARRAY': Tw2ObjectReader.ElementRawType.ARRAY | Tw2ObjectReader.ElementSize.LARGE,

    'SHORT_MAPPING': Tw2ObjectReader.ElementRawType.MAPPING | Tw2ObjectReader.ElementSize.SMALL,
    'MEDIUM_MAPPING': Tw2ObjectReader.ElementRawType.MAPPING | Tw2ObjectReader.ElementSize.MEDIUM,
    'LARGE_MAPPING': Tw2ObjectReader.ElementRawType.MAPPING | Tw2ObjectReader.ElementSize.LARGE,

    'SHORT_OBJECT': Tw2ObjectReader.ElementRawType.OBJECT | Tw2ObjectReader.ElementSize.SMALL,
    'MEDIUM_OBJECT': Tw2ObjectReader.ElementRawType.OBJECT | Tw2ObjectReader.ElementSize.MEDIUM,
    'LARGE_OBJECT': Tw2ObjectReader.ElementRawType.OBJECT | Tw2ObjectReader.ElementSize.LARGE,

    'SHORT_TYPED_ARRAY': Tw2ObjectReader.ElementRawType.TYPED_ARRAY | Tw2ObjectReader.ElementSize.SMALL,
    'MEDIUM_TYPED_ARRAY': Tw2ObjectReader.ElementRawType.TYPED_ARRAY | Tw2ObjectReader.ElementSize.MEDIUM,
    'LARGE_TYPED_ARRAY': Tw2ObjectReader.ElementRawType.TYPED_ARRAY | Tw2ObjectReader.ElementSize.LARGE,

    'SHORT_TYPED_MAPPING': Tw2ObjectReader.ElementRawType.TYPED_MAPPING | Tw2ObjectReader.ElementSize.SMALL,
    'MEDIUM_TYPED_MAPPING': Tw2ObjectReader.ElementRawType.TYPED_MAPPING | Tw2ObjectReader.ElementSize.MEDIUM,
    'LARGE_TYPED_MAPPING': Tw2ObjectReader.ElementRawType.TYPED_MAPPING | Tw2ObjectReader.ElementSize.LARGE
};

/**
 * Typed array types
 * @type {{number:Function}}
 */
Tw2ObjectReader.TypedArrays = {
    2: Int8Array,
    3: Uint8Array,
    18: Int16Array,
    19: Uint16Array,
    34: Int32Array,
    35: Uint32Array,
    4: Float32Array,
    20: Float32Array,
    36: Float64Array
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2BinaryReader
 *
 * @param {*} data
 */
var Tw2BinaryReader = exports.Tw2BinaryReader = function () {
    function Tw2BinaryReader(data) {
        _classCallCheck(this, Tw2BinaryReader);

        this.data = data;
        this.cursor = 0;
    }

    /**
     * ReadUInt8
     * @returns {*}
     */


    _createClass(Tw2BinaryReader, [{
        key: 'ReadUInt8',
        value: function ReadUInt8() {
            return this.data[this.cursor++];
        }

        /**
         * ReadInt8
         * @returns {*}
         */

    }, {
        key: 'ReadInt8',
        value: function ReadInt8() {
            var val = this.data[this.cursor++];
            if (val > 0x7F) val = val - 0xff - 1;
            return val;
        }

        /**
         * ReadUInt16
         * @returns {*}
         */

    }, {
        key: 'ReadUInt16',
        value: function ReadUInt16() {
            return this.data[this.cursor++] + (this.data[this.cursor++] << 8);
        }

        /**
         * ReadInt16
         * @returns {*}
         */

    }, {
        key: 'ReadInt16',
        value: function ReadInt16() {
            var val = this.data[this.cursor++] + (this.data[this.cursor++] << 8);
            if (val > 0x7FFF) val = val - 0xffff - 1;
            return val;
        }

        /**
         * ReadUInt32
         * @returns {*}
         */

    }, {
        key: 'ReadUInt32',
        value: function ReadUInt32() {
            return this.data[this.cursor++] + (this.data[this.cursor++] << 8) + (this.data[this.cursor++] << 16) + (this.data[this.cursor++] << 24 >>> 0);
        }

        /**
         * ReadInt32
         * @returns {*}
         */

    }, {
        key: 'ReadInt32',
        value: function ReadInt32() {
            var val = this.data[this.cursor++] + (this.data[this.cursor++] << 8) + (this.data[this.cursor++] << 16) + (this.data[this.cursor++] << 24 >>> 0);
            if (val > 0x7FFFFFFF) val = val - 0xffffffff - 1;
            return val;
        }

        /**
         * ReadFloat16
         * @returns {number}
         */

    }, {
        key: 'ReadFloat16',
        value: function ReadFloat16() {
            var b2 = this.data[this.cursor++],
                b1 = this.data[this.cursor++];

            var sign = 1 - 2 * (b1 >> 7); // sign = bit 0
            var exp = (b1 >> 2 & 0x1f) - 15; // exponent = bits 1..5
            var sig = (b1 & 3) << 8 | b2; // significand = bits 6..15

            if (sig === 0 && exp === -15) return 0.0;
            return sign * (1 + sig * Math.pow(2, -10)) * Math.pow(2, exp);
        }

        /**
         * ReadFloat32
         * @returns {number}
         */

    }, {
        key: 'ReadFloat32',
        value: function ReadFloat32() {
            var b4 = this.data[this.cursor++],
                b3 = this.data[this.cursor++],
                b2 = this.data[this.cursor++],
                b1 = this.data[this.cursor++];

            var sign = 1 - 2 * (b1 >> 7); // sign = bit 0
            var exp = (b1 << 1 & 0xff | b2 >> 7) - 127; // exponent = bits 1..8
            var sig = (b2 & 0x7f) << 16 | b3 << 8 | b4; // significand = bits 9..31

            if (sig === 0 && exp === -127) return 0.0;
            return sign * (1 + sig * Math.pow(2, -23)) * Math.pow(2, exp);
        }

        /**
         * ReadString
         * @returns {string}
         */

    }, {
        key: 'ReadString',
        value: function ReadString() {
            var length = this.data[this.cursor++];
            var str = '';
            for (var i = 0; i < length; ++i) {
                str += String.fromCharCode(this.data[this.cursor++]);
            }
            return str;
        }
    }]);

    return Tw2BinaryReader;
}();

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Effect = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _global = __webpack_require__(17);

var _Tw2TextureParameter = __webpack_require__(41);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2Effect
 *
 * @property {string|number} _id
 * @property {string} name
 * @property {string} effectFilePath
 * @property {Tw2EffectRes|null} effectRes
 * @property {Object.<string, Tw2Parameter>} parameters
 * @property {Object.<string, Array>} techniques
 * @property {Object.<string, string>} options
 * @property {Tw2Shader|null} shader
 * @property {Array} samplerOverrides
 * @property {boolean} autoParameter
 * @class
 */
var Tw2Effect = exports.Tw2Effect = function () {
    function Tw2Effect() {
        _classCallCheck(this, Tw2Effect);

        this._id = _math.util.generateID();
        this.name = '';
        this.effectFilePath = '';
        this.effectRes = null;
        this.parameters = {};
        this.techniques = [];
        this.samplerOverrides = [];
        this.autoParameter = false;
        this.options = {};
        this.shader = null;
    }

    /**
     * Initializes the Tw2Effect
     */


    _createClass(Tw2Effect, [{
        key: 'Initialize',
        value: function Initialize() {
            if (this.effectFilePath !== '') {
                this.effectFilePath = this.effectFilePath.toLowerCase();
                var path = Tw2Effect.ToEffectResPath(this.effectFilePath);
                this.effectRes = _global.resMan.GetResource(path);
                this.effectRes.RegisterNotification(this);
            }
        }

        /**
         * Checks if the effect's resource is good
         * @returns {boolean}
         */

    }, {
        key: 'IsGood',
        value: function IsGood() {
            return this.shader !== null;
        }

        /**
         * Gets effect resources
         * @param {Array} [out=[]] - Optional receiving array
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.effectRes && !out.includes(this.effectRes)) {
                out.push(this.effectRes);
            }

            for (var param in this.parameters) {
                if (this.parameters.hasOwnProperty(param)) {
                    if ('GetResources' in this.parameters[param]) {
                        this.parameters[param].GetResources(out);
                    }
                }
            }

            return out;
        }

        /**
         * Rebuilds Cached Data
         * @param resource
         */

    }, {
        key: 'RebuildCachedData',
        value: function RebuildCachedData(resource) {
            this.shader = resource.GetShader(this.options);
            this.BindParameters();
        }

        /**
         * Unbinds parameters
         * @returns {boolean}
         */

    }, {
        key: 'UnBindParameters',
        value: function UnBindParameters() {
            for (var t in this.techniques) {
                if (this.techniques.hasOwnProperty(t)) {
                    var technique = this.techniques[t];
                    for (var i = 0; i < technique.length; ++i) {
                        for (var j = 0; j < technique[i].stages.length; ++j) {
                            for (var k = 0; k < technique[i].stages[j].reroutedParameters.length; ++k) {
                                technique[i].stages[j].reroutedParameters[k].Unbind();
                            }
                        }
                    }
                }
            }
            this.techniques = {};
        }

        /**
         * Binds parameters
         * @returns {boolean}
         */

    }, {
        key: 'BindParameters',
        value: function BindParameters() {
            this.UnBindParameters();
            if (!this.IsGood()) {
                return false;
            }

            for (var techniqueName in this.shader.techniques) {
                if (this.shader.techniques.hasOwnProperty(techniqueName)) {
                    var technique = this.shader.techniques[techniqueName];
                    var passes = [];

                    for (var i = 0; i < technique.passes.length; ++i) {
                        var pass = [];
                        pass.stages = [];
                        for (var j = 0; j < technique.passes[i].stages.length; ++j) {
                            var stageRes = technique.passes[i].stages[j],
                                stage = {};

                            stage.constantBuffer = new Float32Array(stageRes.constantSize);
                            stage.reroutedParameters = [];
                            stage.parameters = [];
                            stage.textures = [];
                            stage.constantBuffer.set(stageRes.constantValues);

                            for (var k = 0; k < stageRes.constants.length; ++k) {
                                var constant = stageRes.constants[k],
                                    name = constant.name,
                                    Type = constant.Type;

                                if (Tw2Effect.ConstantIgnore.includes(name)) continue;

                                if (name in this.parameters) {
                                    var param = this.parameters[name];
                                    if (param.Bind(stage.constantBuffer, constant.offset, constant.size)) {
                                        stage.reroutedParameters.push(param);
                                    } else {
                                        stage.parameters.push({
                                            parameter: param,
                                            constantBuffer: stage.constantBuffer,
                                            offset: constant.offset,
                                            size: constant.size
                                        });
                                    }
                                } else if (_global.store.HasVariable(name)) {
                                    stage.parameters.push({
                                        parameter: _global.store.GetVariable(name),
                                        constantBuffer: stage.constantBuffer,
                                        offset: constant.offset,
                                        size: constant.size
                                    });
                                } else if (constant.isAutoregister && Type) {
                                    var variable = _global.store.RegisterVariable(name, undefined, Type);
                                    if (variable) {
                                        stage.parameters.push({
                                            parameter: variable,
                                            constantBuffer: stage.constantBuffer,
                                            offset: constant.offset,
                                            size: constant.size
                                        });
                                    }
                                } else if (this.autoParameter && constant.elements === 1) {
                                    var value = stage.constantBuffer.subarray(constant.offset, constant.offset + constant.size);
                                    if (value.length === 0) {
                                        value = undefined;
                                    } else if (value.length === 1) {
                                        value = value[0];
                                    }

                                    var _param = _global.store.CreateType(name, value, Type);
                                    if (_param) {
                                        this.parameters[name] = _param;
                                        if (_param.Bind(stage.constantBuffer, constant.offset, constant.size)) {
                                            stage.reroutedParameters.push(_param);
                                        } else {
                                            stage.parameter.push({
                                                parameter: _param,
                                                constantBuffer: stage.constantBuffer,
                                                offset: constant.offset,
                                                size: constant.size
                                            });
                                        }
                                    }
                                }
                            }

                            for (var _k = 0; _k < stageRes.textures.length; ++_k) {
                                var _name = stageRes.textures[_k].name;
                                var _param2 = null;
                                if (_name in this.parameters) {
                                    _param2 = this.parameters[_name];
                                } else if (_global.store.HasVariable(_name)) {
                                    _param2 = _global.store.GetVariable(_name);
                                } else if (stageRes.textures[_k].isAutoregister) {
                                    _param2 = _global.store.RegisterVariable(_name, undefined, _Tw2TextureParameter.Tw2TextureParameter);
                                } else if (this.autoParameter) {
                                    _param2 = this.parameters[_name] = new _Tw2TextureParameter.Tw2TextureParameter(_name);
                                } else {
                                    continue;
                                }

                                var p = {
                                    parameter: _param2,
                                    slot: stageRes.textures[_k].registerIndex,
                                    sampler: null
                                };

                                for (var n = 0; n < stageRes.samplers.length; ++n) {
                                    if (stageRes.samplers[n].registerIndex === p.slot) {
                                        if (stageRes.samplers[n].name in this.samplerOverrides) {
                                            p.sampler = this.samplerOverrides[stageRes.samplers[n].name].GetSampler(stageRes.samplers[n]);
                                        } else {
                                            p.sampler = stageRes.samplers[n];
                                        }
                                        break;
                                    }
                                }

                                if (j === 0) p.slot += 12;
                                stage.textures.push(p);
                            }
                            pass.stages.push(stage);
                        }
                        passes.push(pass);
                    }
                    this.techniques[techniqueName] = passes;
                }
            }

            if (_global.device['effectObserver']) {
                _global.device['effectObserver']['OnEffectChanged'](this);
            }

            this.autoParameter = false;
            return true;
        }

        /**
         * ApplyPass
         * @param technique {string} - technique name
         * @param pass {number}
         */

    }, {
        key: 'ApplyPass',
        value: function ApplyPass(technique, pass) {
            if (!this.IsGood() || !(technique in this.techniques) || pass >= this.techniques[technique].length) {
                return;
            }

            this.shader.ApplyPass(technique, pass);

            var p = this.techniques[technique][pass],
                rp = this.shader.techniques[technique].passes[pass],
                d = _global.device;

            var program = d.IsAlphaTestEnabled() && rp.shadowShaderProgram ? rp.shadowShaderProgram : rp.shaderProgram;

            for (var i = 0; i < 2; ++i) {
                var stages = p.stages[i];

                for (var j = 0; j < stages.parameters.length; ++j) {
                    var pp = stages.parameters[j];
                    pp.parameter.Apply(pp.constantBuffer, pp.offset, pp.size);
                }

                for (var _j = 0; _j < stages.textures.length; ++_j) {
                    var tex = stages.textures[_j];
                    tex.parameter.Apply(tex.slot, tex.sampler, program.volumeSlices[tex.sampler.registerIndex]);
                }
            }

            var cbh = program.constantBufferHandles;
            if (cbh[0]) d.gl.uniform4fv(cbh[0], p.stages[0].constantBuffer);
            if (cbh[7]) d.gl.uniform4fv(cbh[7], p.stages[1].constantBuffer);
            if (d.perFrameVSData && cbh[1]) d.gl.uniform4fv(cbh[1], d.perFrameVSData.data);
            if (d.perFramePSData && cbh[2]) d.gl.uniform4fv(cbh[2], d.perFramePSData.data);
            if (d.perObjectData) d.perObjectData.SetPerObjectDataToDevice(cbh);
        }

        /**
         * GetPassCount
         * @param technique {string} - technique name
         * @returns {number}
         */

    }, {
        key: 'GetPassCount',
        value: function GetPassCount(technique) {
            if (this.shader === null || !(technique in this.techniques)) {
                return 0;
            }
            return this.techniques[technique].length;
        }

        /**
         * GetPassInput
         * @param technique {string} - technique name
         * @param {number} pass
         * @returns {*}
         */

    }, {
        key: 'GetPassInput',
        value: function GetPassInput(technique, pass) {
            if (this.shader === null || !(technique in this.techniques) || pass >= this.techniques[technique].length) {
                return null;
            }

            if (_global.device.IsAlphaTestEnabled() && this.shader.techniques[technique].passes[pass].shadowShaderProgram) {
                return this.shader.techniques[technique].passes[pass].shadowShaderProgram.input;
            } else {
                return this.shader.techniques[technique].passes[pass].shaderProgram.input;
            }
        }

        /**
         * Render
         * @param {function} cb - callback
         */

    }, {
        key: 'Render',
        value: function Render(cb) {
            var count = this.GetPassCount('Main');
            for (var i = 0; i < count; ++i) {
                this.ApplyPass('Main', i);
                cb(this, i);
            }
        }

        /**
         * Gets an object containing the textures currently set in the Tw2Effect
         * @param {{}} [out={}]
         * @returns {Object.<string, string>} out
         */

    }, {
        key: 'GetTextures',
        value: function GetTextures() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            for (var key in this.parameters) {
                if (this.parameters.hasOwnProperty(key) && this.parameters[key] instanceof _Tw2TextureParameter.Tw2TextureParameter) {
                    var resourcePath = this.parameters[key].GetValue();
                    if (resourcePath) {
                        out[key] = resourcePath;
                    }
                }
            }
            return out;
        }

        /**
         * Sets textures from an object
         * @param {{string:string}} options
         * @returns {boolean} true if updated
         */

    }, {
        key: 'SetTextures',
        value: function SetTextures() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var updated = false;
            for (var key in options) {
                if (options.hasOwnProperty(key)) {
                    var value = options[key],
                        param = this.parameters[key];

                    if (_Tw2TextureParameter.Tw2TextureParameter.is(value)) {
                        if (param) {
                            if (!param.EqualsValue(value)) {
                                param.SetTexturePath(value);
                                updated = true;
                            }
                        } else {
                            this.parameters[key] = new _Tw2TextureParameter.Tw2TextureParameter(key, value);
                            updated = true;
                        }
                    }
                }
            }

            return updated;
        }

        /**
         * Gets an object containing all non texture parameters currently set in the Tw2Effect
         * - Matches sof parameter object
         * @param {{}} [out={}]
         * @returns {Object.<string, *>}
         */

    }, {
        key: 'GetParameters',
        value: function GetParameters() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            for (var key in this.parameters) {
                if (this.parameters.hasOwnProperty(key) && !(this.parameters[key] instanceof _Tw2TextureParameter.Tw2TextureParameter)) {
                    out[key] = this.parameters[key].GetValue(true);
                }
            }
            return out;
        }

        /**
         * Sets parameters from an object
         * @param {{string:*}} [options={}]
         * @returns {boolean} true if updated
         */

    }, {
        key: 'SetParameters',
        value: function SetParameters() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var updated = false;
            for (var key in options) {
                if (options.hasOwnProperty(key)) {
                    var value = options[key],
                        param = this.parameters[key];

                    if (param) {
                        if (param.constructor.is(value) && !param.EqualsValue(value)) {
                            this.parameters[key].SetValue(value);
                            updated = true;
                        }
                    } else {
                        var parameter = _global.store.CreateType(key, value);
                        if (parameter) {
                            this.parameters[key] = parameter;
                            updated = true;
                        }
                    }
                }
            }

            return updated;
        }

        /**
         * Sets texture overrides
         * @param {*} [options={}]
         * @returns {boolean} true if updated
         */

    }, {
        key: 'SetOverrides',
        value: function SetOverrides() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var updated = false;
            for (var key in options) {
                if (options.hasOwnProperty(key)) {
                    var param = this.parameters[key];
                    if (param && param instanceof _Tw2TextureParameter.Tw2TextureParameter) {
                        var doUpdate = false;

                        var overrides = options[key];
                        for (var prop in overrides) {
                            if (overrides.hasOwnProperty(prop) && _Tw2TextureParameter.Tw2TextureParameter.overrideProperties.includes(prop)) {
                                if (overrides[prop] !== param[prop]) {
                                    doUpdate = true;
                                    break;
                                }
                            }
                        }

                        if (doUpdate) {
                            param.SetOverrides(options[key]);
                            updated = true;
                        }
                    }
                }
            }
            return updated;
        }

        /**
         * Gets texture overrides
         * @param {{ string: {}}} [out={}]
         */

    }, {
        key: 'GetOverrides',
        value: function GetOverrides() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            for (var key in this.parameters) {
                if (this.parameters.hasOwnProperty(key)) {
                    var param = this.parameters[key];
                    if (param && param instanceof _Tw2TextureParameter.Tw2TextureParameter && param.useAllOverrides) {
                        out[key] = this.parameters[key].GetOverrides();
                    }
                }
            }
            return out;
        }

        /**
         * Converts an effect file path into one suitable for an effect resource
         * @param {string} path
         * @returns {string}
         */

    }], [{
        key: 'ToEffectResPath',
        value: function ToEffectResPath(path) {
            path = path ? path.substr(0, path.lastIndexOf('.')).replace('/effect/', _global.device.effectDir) + '.sm_' + _global.device.shaderModel : '';
            return path.toLowerCase();
        }

        /**
         * Converts an effect resource path back into a normal effect file path
         * @param {string} path
         * @param {string} [ext='fx']
         * @returns {string}
         */

    }, {
        key: 'FromEffectResPath',
        value: function FromEffectResPath(path) {
            var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'fx';

            path = path.substr(0, path.lastIndexOf('.')).replace(_global.device.effectDir, '/effect/') + '.' + ext;
            return path.toLowerCase();
        }

        /**
         * Creates a Tw2Effect from an object
         * @param {{}} [opt]
         * @param {string} [opt.name='']
         * @param {string} [opt.effectFilePath='']
         * @param {boolean} [opt.autoParameter]
         * @param {{string: *}} [opt.parameters]
         * @param {{string: string}} [opt.textures]
         * @param {{string: {}}} [opt.overrides]
         * @returns {Tw2Effect}
         */

    }, {
        key: 'create',
        value: function create() {
            var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var effect = new this();
            _math.util.assignIfExists(effect, opt, ['name', 'effectFilePath', 'display', 'autoParameter']);
            if ('parameters' in opt) effect.SetParameters(opt.parameters);
            if ('textures' in opt) effect.SetTextures(opt.textures);
            if ('overrides' in opt) effect.SetOverrides(opt.overrides);

            if (effect.name === '' && opt.effectFilePath !== '') {
                var path = opt.effectFilePath;
                effect.name = path.substring(path.lastIndexOf('/') + 1, path.length);
            }

            effect.Initialize();
            return effect;
        }
    }]);

    return Tw2Effect;
}();

/**
 * Constant parameters which are ignored when creating an effect
 * @type {string[]}
 */


Tw2Effect.ConstantIgnore = ['PerFrameVS', 'PerObjectVS', 'PerFramePS', 'PerObjectPS', 'PerObjectPSInt'];

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2TextureParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Tw2ResMan = __webpack_require__(6);

var _Tw2Device = __webpack_require__(2);

var _sampler = __webpack_require__(21);

var _Tw2Parameter2 = __webpack_require__(7);

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2TextureParameter
 * 
 * @param {string} [name=''] - Name of the texture parameter
 * @param {string} [texturePath=''] - The texture's resource path
 * @property {string} name
 * @property {boolean} useAllOverrides
 * @property {number} addressUMode
 * @property {number} addressVMode
 * @property {number} addressWMode
 * @property {number} filterMode
 * @property {number} mapFilterMode
 * @property {number} maxAnisotropy
 * @property {Tw2TextureRes} textureRes
 * @property {Tw2SamplerState} _sampler
 * @class
 */
var Tw2TextureParameter = exports.Tw2TextureParameter = function (_Tw2Parameter) {
    _inherits(Tw2TextureParameter, _Tw2Parameter);

    function Tw2TextureParameter() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var texturePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

        _classCallCheck(this, Tw2TextureParameter);

        var _this = _possibleConstructorReturn(this, (Tw2TextureParameter.__proto__ || Object.getPrototypeOf(Tw2TextureParameter)).call(this, name));

        _this.resourcePath = texturePath;
        _this.useAllOverrides = false;
        _this.addressUMode = 1;
        _this.addressVMode = 1;
        _this.addressWMode = 1;
        _this.filterMode = 2;
        _this.mipFilterMode = 2;
        _this.maxAnisotropy = 4;
        _this.textureRes = null;
        _this._sampler = null;

        if (texturePath) _this.Initialize();
        return _this;
    }

    /**
     * Checks if the parameter has a texture that was attached
     * @returns {boolean}
     */


    _createClass(Tw2TextureParameter, [{
        key: 'Initialize',


        /**
         * Initializes the texture
         */
        value: function Initialize() {
            this.OnValueChanged();
        }

        /**
         * Sets the texture path
         * @param {string} value
         * @returns {boolean} true if changed
         */

    }, {
        key: 'SetTexturePath',
        value: function SetTexturePath(value) {
            this.resourcePath = value;
            this.OnValueChanged();
        }

        /**
         * Returns the texture's resource path
         * @returns {?string}
         */

    }, {
        key: 'GetValue',
        value: function GetValue() {
            return this.isTextureAttached ? null : this.resourcePath;
        }

        /**
         * Sets the texture's resource manually
         * @param {Tw2TextureRes} res
         * @returns {boolean}
         */

    }, {
        key: 'SetTextureRes',
        value: function SetTextureRes(res) {
            if (this.textureRes !== res) {
                this.resourcePath = '';
                this.textureRes = res;
            }
            this.textureRes._isAttached = true;
        }

        /**
         * Fire on value changes
         * @param {*} [controller]        - An optional parameter for tracking the object that called this function
         * @param {string[]} [properties] - An optional array for tracking the properties that were modified
         */

    }, {
        key: 'OnValueChanged',
        value: function OnValueChanged(controller, properties) {
            if (this.resourcePath !== '') {
                this.resourcePath = this.resourcePath.toLowerCase();
                this.textureRes = this.resourcePath !== '' ? _Tw2ResMan.resMan.GetResource(this.resourcePath) : null;
            }

            this.UpdateOverrides();
            _get(Tw2TextureParameter.prototype.__proto__ || Object.getPrototypeOf(Tw2TextureParameter.prototype), 'OnValueChanged', this).call(this, controller, properties);
        }

        /**
         * Apply
         * @param {number} stage
         * @param {Tw2SamplerState} sampler
         * @param {number} slices
         */

    }, {
        key: 'Apply',
        value: function Apply(stage, sampler, slices) {
            if (this.textureRes) {
                if (this.useAllOverrides) {
                    this._sampler.samplerType = sampler.samplerType;
                    this._sampler.isVolume = sampler.isVolume;
                    this._sampler.registerIndex = sampler.registerIndex;
                    sampler = this._sampler;
                }
                _Tw2Device.device.gl.activeTexture(_Tw2Device.device.gl.TEXTURE0 + stage);
                this.textureRes.Bind(sampler, slices);
            }
        }

        /**
         * Sets the textures overrides
         * @param {{}} [opt={}] - An object containing the override options to set
         */

    }, {
        key: 'SetOverrides',
        value: function SetOverrides() {
            var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            _math.util.assignIfExists(this, opt, Tw2TextureParameter.overrideProperties);
            this.OnValueChanged();
        }

        /**
         * Gets the texture's overrides
         * @returns {{}}
         */

    }, {
        key: 'GetOverrides',
        value: function GetOverrides() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            _math.util.assignIfExists(out, this, Tw2TextureParameter.overrideProperties);
            return out;
        }

        /**
         * Updates the parameter's overrides
         */

    }, {
        key: 'UpdateOverrides',
        value: function UpdateOverrides() {
            if (this.useAllOverrides) {
                this._sampler = this._sampler || new _sampler.Tw2SamplerState();
                var sampler = this._sampler;

                if (this.filterMode === 1) {
                    switch (this.mipFilterMode) {
                        case 0:
                            sampler.minFilter = _Tw2Device.device.gl.NEAREST;
                            break;

                        case 1:
                            sampler.minFilter = _Tw2Device.device.gl.NEAREST_MIPMAP_NEAREST;
                            break;

                        default:
                            sampler.minFilter = _Tw2Device.device.gl.NEAREST_MIPMAP_LINEAR;
                    }

                    sampler.minFilterNoMips = _Tw2Device.device.gl.NEAREST;
                    sampler.magFilter = _Tw2Device.device.gl.NEAREST;
                } else {
                    switch (this.mipFilterMode) {
                        case 0:
                            sampler.minFilter = _Tw2Device.device.gl.LINEAR;
                            break;

                        case 1:
                            sampler.minFilter = _Tw2Device.device.gl.LINEAR_MIPMAP_NEAREST;
                            break;

                        default:
                            sampler.minFilter = _Tw2Device.device.gl.LINEAR_MIPMAP_LINEAR;
                    }
                    sampler.minFilterNoMips = _Tw2Device.device.gl.LINEAR;
                    sampler.magFilter = _Tw2Device.device.gl.LINEAR;
                }

                sampler.addressU = _Tw2Device.device.wrapModes[this.addressUMode];
                sampler.addressV = _Tw2Device.device.wrapModes[this.addressVMode];
                sampler.addressW = _Tw2Device.device.wrapModes[this.addressWMode];
                sampler.anisotropy = this.maxAnisotropy;
                sampler.ComputeHash();
            } else if (this._sampler) {
                this._sampler = null;
            }
        }

        /**
         * Checks if a value is equal to the parameter's resource path
         * @param {*} value
         * @returns {boolean}
         */

    }, {
        key: 'EqualsValue',
        value: function EqualsValue(value) {
            return value.toLowerCase() === this.GetValue();
        }

        /**
         * Copies another texture parameter's values
         * @param {Tw2TextureParameter} parameter
         * @param {boolean} [includeName]
         */

    }, {
        key: 'Copy',
        value: function Copy(parameter, includeName) {
            if (includeName) this.name = parameter.name;
            this.resourcePath = parameter.resourcePath;
            this.SetOverrides(parameter.GetOverrides);
        }

        /**
         * Clones the texture parameter
         * @returns {Tw2TextureParameter}
         */

    }, {
        key: 'Clone',
        value: function Clone() {
            var parameter = new Tw2TextureParameter();
            parameter.Copy(this, true);
            return parameter;
        }

        /**
         * Gets the texture's resources
         * @param {Array} [out=[]]
         * @returns {Array.<Tw2Resource>}
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.textureRes && !out.includes(this.textureRes)) {
                out.push(this.textureRes);
            }
            return out;
        }

        /**
         *
         * @param value
         * @returns {boolean}
         */

    }, {
        key: 'isTextureAttached',
        get: function get() {
            return this.textureRes && this.textureRes._isAttached;
        }
    }], [{
        key: 'is',
        value: function is(value) {
            return typeof value === 'string';
        }
    }]);

    return Tw2TextureParameter;
}(_Tw2Parameter2.Tw2Parameter);

/**
 * Alias for {@link Tw2TextureParameter.SetTexturePath}
 * @type {Tw2TextureParameter.SetTexturePath}
 */


Tw2TextureParameter.prototype.SetValue = Tw2TextureParameter.prototype.SetTexturePath;

/**
 * The texture parameter's override properties
 * @type {string[]}
 */
Tw2TextureParameter.overrideProperties = ['useAllOverrides', 'addressUMode', 'addressVMode', 'addressWMode', 'filterMode', 'mipFilterMode', 'maxAnisotropy'];

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2SamplerState = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Device = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2SamplerState
 *
 * @property {string} name
 * @property {number} registerIndex
 * @property {number} minFilter
 * @property {number} maxFilter
 * @property {number} minFilterNoMips
 * @property {number} addressU
 * @property {number} addressV
 * @property {number} addressW
 * @property {number} anisotropy
 * @property samplerType
 * @property {boolean} isVolume
 * @property {number} hash
 * @class
 */
var Tw2SamplerState = exports.Tw2SamplerState = function () {
    function Tw2SamplerState() {
        _classCallCheck(this, Tw2SamplerState);

        this.name = '';
        this.registerIndex = 0;
        this.minFilter = _Tw2Device.device.gl.LINEAR;
        this.maxFilter = _Tw2Device.device.gl.LINEAR;
        this.minFilterNoMips = _Tw2Device.device.gl.LINEAR;
        this.addressU = _Tw2Device.device.gl.REPEAT;
        this.addressV = _Tw2Device.device.gl.REPEAT;
        this.addressW = _Tw2Device.device.gl.REPEAT;
        this.anisotropy = 1;
        this.samplerType = _Tw2Device.device.gl.TEXTURE_2D;
        this.isVolume = false;
        this.hash = 0;
    }

    /**
     * Computes the sampler hash
     */


    _createClass(Tw2SamplerState, [{
        key: 'ComputeHash',
        value: function ComputeHash() {
            this.hash = 2166136261;
            this.hash *= 16777619;
            this.hash ^= this.minFilter;
            this.hash *= 16777619;
            this.hash ^= this.maxFilter;
            this.hash *= 16777619;
            this.hash ^= this.addressU;
            this.hash *= 16777619;
            this.hash ^= this.addressV;
            this.hash *= 16777619;
            this.hash ^= this.anisotropy;
        }

        /**
         * Apply
         * @param {boolean} hasMipMaps
         */

    }, {
        key: 'Apply',
        value: function Apply(hasMipMaps) {
            var targetType = this.samplerType,
                d = _Tw2Device.device;

            d.gl.texParameteri(targetType, d.gl.TEXTURE_WRAP_S, hasMipMaps ? this.addressU : d.gl.CLAMP_TO_EDGE);
            d.gl.texParameteri(targetType, d.gl.TEXTURE_WRAP_T, hasMipMaps ? this.addressV : d.gl.CLAMP_TO_EDGE);
            d.gl.texParameteri(targetType, d.gl.TEXTURE_MIN_FILTER, hasMipMaps ? this.minFilter : this.minFilterNoMips);
            d.gl.texParameteri(targetType, d.gl.TEXTURE_MAG_FILTER, this.magFilter);
            if (d.ext.AnisotropicFilter && d.enableAnisotropicFiltering) {
                d.gl.texParameterf(targetType, d.ext.AnisotropicFilter.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this.anisotropy, d.ext.AnisotropicFilter.maxAnisotropy));
            }
        }

        /**
         * Gets the current filter mode
         * @returns {number}
         */

    }, {
        key: 'GetFilterMode',
        value: function GetFilterMode() {
            return this.minFilterNoMips in Tw2SamplerState.FilterMode ? Tw2SamplerState.FilterMode[this.minFilterNoMips] : 2;
        }

        /**
         * Gets the current mip filter mode
         * @returns {number}
         */

    }, {
        key: 'GetMipFilterMode',
        value: function GetMipFilterMode() {
            return this.minFilter in Tw2SamplerState.MipFilterMode ? Tw2SamplerState.MipFilterMode[this.minFilter] : 2;
        }
    }]);

    return Tw2SamplerState;
}();

/**
 * Filter modes
 */


Tw2SamplerState.FilterMode = {
    9728: 1,
    9729: 2
};

/**
 * Mip filter modes
 */
Tw2SamplerState.MipFilterMode = {
    9728: 0,
    9729: 0,
    9984: 1,
    9985: 1,
    9986: 2,
    9987: 2
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2VertexElement
 *
 * @param {number} usage
 * @param {number} usageIndex
 * @param {number} type
 * @param {number} elements
 * @param {number} [offset=0]
 * @property {number} usage
 * @property {number} usageIndex
 * @property {number} type
 * @property {number} elements
 * @property {number} offset
 * @property location
 * @property customSetter
 * @class
 */
var Tw2VertexElement = exports.Tw2VertexElement = function Tw2VertexElement(usage, usageIndex, type, elements) {
    var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    _classCallCheck(this, Tw2VertexElement);

    this.usage = usage;
    this.usageIndex = usageIndex;
    this.type = type;
    this.elements = elements;
    this.offset = offset;
    this.location = null;
    this.customSetter = null;
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2PerObjectData = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Device = __webpack_require__(2);

var _Tw2RawData = __webpack_require__(25);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2PerObjectData
 *
 * @param {RawDataObject} [rawDataObject]
 * @property {?Tw2RawData} perObjectVSData - Per object vertex shader data
 * @property {?Tw2RawData} perObjectPSData - Per object pixel shader data
 * @class
 */
var Tw2PerObjectData = exports.Tw2PerObjectData = function () {
    function Tw2PerObjectData(rawDataObject) {
        _classCallCheck(this, Tw2PerObjectData);

        this.perObjectVSData = null;
        this.perObjectPSData = null;

        if (rawDataObject) {
            this.DeclareFromObject(rawDataObject);
        }
    }

    /**
     * Sets per object data to the device
     * @param constantBufferHandles
     */


    _createClass(Tw2PerObjectData, [{
        key: 'SetPerObjectDataToDevice',
        value: function SetPerObjectDataToDevice(constantBufferHandles) {
            if (this.perObjectVSData && constantBufferHandles[3]) {
                _Tw2Device.device.gl.uniform4fv(constantBufferHandles[3], this.perObjectVSData.data);
            }

            if (this.perObjectPSData && constantBufferHandles[4]) {
                _Tw2Device.device.gl.uniform4fv(constantBufferHandles[4], this.perObjectPSData.data);
            }
        }

        /**
         * Defines and creates raw data from an object
         * @param {RawDataObject} rawDataObject
         */

    }, {
        key: 'DeclareFromObject',
        value: function DeclareFromObject() {
            var rawDataObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (rawDataObject.VSData) {
                this.perObjectVSData = new _Tw2RawData.Tw2RawData(rawDataObject.VSData);
            }

            if (rawDataObject.PSData) {
                this.perObjectPSData = new _Tw2RawData.Tw2RawData(rawDataObject.PSData);
            }
        }
    }]);

    return Tw2PerObjectData;
}();

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _emitters = __webpack_require__(100);

Object.keys(_emitters).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _emitters[key];
    }
  });
});

var _forces = __webpack_require__(104);

Object.keys(_forces).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _forces[key];
    }
  });
});

var _generators = __webpack_require__(111);

Object.keys(_generators).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _generators[key];
    }
  });
});

var _constraints = __webpack_require__(115);

Object.keys(_constraints).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _constraints[key];
    }
  });
});

var _Tw2ParticleSystem = __webpack_require__(116);

Object.keys(_Tw2ParticleSystem).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleSystem[key];
    }
  });
});

var _Tw2ParticleElement = __webpack_require__(18);

Object.keys(_Tw2ParticleElement).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleElement[key];
    }
  });
});

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2BlendShapeData = __webpack_require__(118);

Object.keys(_Tw2BlendShapeData).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2BlendShapeData[key];
    }
  });
});

var _Tw2GeometryAnimation = __webpack_require__(119);

Object.keys(_Tw2GeometryAnimation).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2GeometryAnimation[key];
    }
  });
});

var _Tw2GeometryBone = __webpack_require__(120);

Object.keys(_Tw2GeometryBone).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2GeometryBone[key];
    }
  });
});

var _Tw2GeometryCurve = __webpack_require__(121);

Object.keys(_Tw2GeometryCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2GeometryCurve[key];
    }
  });
});

var _Tw2GeometryMesh = __webpack_require__(122);

Object.keys(_Tw2GeometryMesh).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2GeometryMesh[key];
    }
  });
});

var _Tw2GeometryMeshArea = __webpack_require__(123);

Object.keys(_Tw2GeometryMeshArea).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2GeometryMeshArea[key];
    }
  });
});

var _Tw2GeometryMeshBinding = __webpack_require__(124);

Object.keys(_Tw2GeometryMeshBinding).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2GeometryMeshBinding[key];
    }
  });
});

var _Tw2GeometryModel = __webpack_require__(125);

Object.keys(_Tw2GeometryModel).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2GeometryModel[key];
    }
  });
});

var _Tw2GeometrySkeleton = __webpack_require__(126);

Object.keys(_Tw2GeometrySkeleton).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2GeometrySkeleton[key];
    }
  });
});

var _Tw2GeometryTrackGroup = __webpack_require__(127);

Object.keys(_Tw2GeometryTrackGroup).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2GeometryTrackGroup[key];
    }
  });
});

var _Tw2GeometryTransformTrack = __webpack_require__(128);

Object.keys(_Tw2GeometryTransformTrack).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2GeometryTransformTrack[key];
    }
  });
});

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2Effect = __webpack_require__(40);

Object.keys(_Tw2Effect).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Effect[key];
    }
  });
});

var _Tw2InstancedMesh = __webpack_require__(129);

Object.keys(_Tw2InstancedMesh).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2InstancedMesh[key];
    }
  });
});

var _Tw2Mesh = __webpack_require__(48);

Object.keys(_Tw2Mesh).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Mesh[key];
    }
  });
});

var _Tw2MeshArea = __webpack_require__(49);

Object.keys(_Tw2MeshArea).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2MeshArea[key];
    }
  });
});

var _Tw2MeshLineArea = __webpack_require__(130);

Object.keys(_Tw2MeshLineArea).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2MeshLineArea[key];
    }
  });
});

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Mesh = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ResMan = __webpack_require__(6);

var _Tw2Device = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2Mesh
 *
 * @property {string} name
 * @property {boolean} display                      - Enables/ disables all mesh batch accumulations
 * @parameter {{}} visible                          - Batch accumulation options for the mesh's elements
 * @property {boolean} visible.opaqueAreas          - Enables/ disables opaque area batch accumulation
 * @property {boolean} visible.transparentAreas     - Enables/ disables transparent area batch accumulation
 * @property {boolean} visible.additiveAreas        - Enables/ disables additive area batch accumulation
 * @property {boolean} visible.pickableAreas        - Enables/ disables pickable area batch accumulation
 * @property {boolean} visible.decalAreas           - Enables/ disables decal area batch accumulation
 * @property {boolean} visible.depthAreas           - Not supported
 * @property {Array.<Tw2MeshArea>} opaqueAreas
 * @property {Array.<Tw2MeshArea>} transparentAreas
 * @property {Array.<Tw2MeshArea>} additiveAreas
 * @property {Array.<Tw2MeshArea>} pickableAreas
 * @property {Array.<Tw2MeshArea>} decalAreas
 * @property {Array.<Tw2MeshArea>} depthAreas       - Not supported
 * @property {number} meshIndex
 * @property {string} geometryResPath
 * @property {string} lowDetailGeometryResPath
 * @property {Tw2GeometryRes} geometryResource
 * @class
 */
var Tw2Mesh = exports.Tw2Mesh = function () {
    function Tw2Mesh() {
        _classCallCheck(this, Tw2Mesh);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.visible = {};
        this.visible.opaqueAreas = true;
        this.visible.transparentAreas = true;
        this.visible.additiveAreas = true;
        this.visible.pickableAreas = true;
        this.visible.decalAreas = true;
        this.visible.depthAreas = true;
        this.opaqueAreas = [];
        this.transparentAreas = [];
        this.additiveAreas = [];
        this.pickableAreas = [];
        this.decalAreas = [];
        this.depthAreas = [];
        this.meshIndex = 0;
        this.geometryResPath = '';
        this.lowDetailGeometryResPath = '';
        this.geometryResource = null;
    }

    /**
     * Initializes the Tw2Mesh
     */


    _createClass(Tw2Mesh, [{
        key: 'Initialize',
        value: function Initialize() {
            if (this.geometryResPath !== '') {
                this.geometryResource = _Tw2ResMan.resMan.GetResource(this.geometryResPath);
            }
        }

        /**
         * Checks if the mesh's resource is good
         * @returns {boolean}
         */

    }, {
        key: 'IsGood',
        value: function IsGood() {
            return this.geometryResource && this.geometryResource.IsGood();
        }

        /**
         * Gets mesh resources
         * @param {Array} [out=[]] - Optional receiving array
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (!out.includes(this.geometryResource)) {
                out.push(this.geometryResource);
            }

            _math.util.perArrayChild(this.opaqueAreas, 'GetResources', out);
            _math.util.perArrayChild(this.transparentAreas, 'GetResources', out);
            _math.util.perArrayChild(this.additiveAreas, 'GetResources', out);
            _math.util.perArrayChild(this.pickableAreas, 'GetResources', out);
            _math.util.perArrayChild(this.decalAreas, 'GetResources', out);
            _math.util.perArrayChild(this.depthAreas, 'GetResources', out);
            return out;
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (!this.IsGood() || !this.display) return false;

            var getBatches = this.constructor.GetAreaBatches;
            switch (mode) {
                case _Tw2Device.device.RM_OPAQUE:
                    if (this.visible.opaqueAreas) {
                        getBatches(this, this.opaqueAreas, mode, accumulator, perObjectData);
                    }
                    return;

                case _Tw2Device.device.RM_DECAL:
                    if (this.visible.decalAreas) {
                        getBatches(this, this.opaqueAreas, mode, accumulator, perObjectData);
                    }
                    return;

                case _Tw2Device.device.RM_TRANSPARENT:
                    if (this.visible.transparentAreas) {
                        getBatches(this, this.transparentAreas, mode, accumulator, perObjectData);
                    }
                    return;

                case _Tw2Device.device.RM_ADDITIVE:
                    if (this.visible.transparentAreas) {
                        getBatches(this, this.additiveAreas, mode, accumulator, perObjectData);
                    }
                    return;

                case _Tw2Device.device.RM_PICKABLE:
                    if (this.visible.pickableAreas) {
                        getBatches(this, this.pickableAreas, mode, accumulator, perObjectData);
                    }
                    return;
            }
        }

        /**
         * Gets render batches from a mesh area array and commits them to an accumulator
         * @param {Tw2Mesh} mesh
         * @param {Array.<Tw2MeshArea>} areas
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }], [{
        key: 'GetAreaBatches',
        value: function GetAreaBatches(mesh, areas, mode, accumulator, perObjectData) {
            for (var i = 0; i < areas.length; ++i) {
                var area = areas[i];
                if (area.effect && area.display) {
                    var batch = new area.constructor.batchType();
                    batch.renderMode = mode;
                    batch.perObjectData = perObjectData;
                    batch.geometryRes = mesh.geometryResource;
                    batch.meshIx = mesh.meshIndex;
                    batch.start = area.index;
                    batch.count = area.count;
                    batch.effect = area.effect;
                    accumulator.Commit(batch);
                }
            }
        }
    }]);

    return Tw2Mesh;
}();

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2MeshArea = undefined;

var _batch = __webpack_require__(20);

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2MeshArea
 *
 * @property {string} name
 * @property {Tw2Effect} effect
 * @property {number} meshIndex
 * @property {number} index
 * @property {number} count
 * @property {boolean} display
 * @class
 */
var Tw2MeshArea = exports.Tw2MeshArea = function Tw2MeshArea() {
  _classCallCheck(this, Tw2MeshArea);

  this._id = _math.util.generateID();
  this.name = '';
  this.effect = null;
  this.meshIndex = 0;
  this.index = 0;
  this.count = 1;
  this.display = true;
};

/**
 * Render Batch Constructor
 * @type {Tw2RenderBatch}
 */


Tw2MeshArea.batchType = _batch.Tw2GeometryBatch;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2Animation
 *
 * @property {Tw2GeometryAnimation} animationRes
 * @property {number} time
 * @property {number} timeScale
 * @property {boolean} cycle
 * @property {boolean} isPlaying
 * @property {Function} callback - Stores optional callback passed to prototypes
 * @property {Array} trackGroups - Array of {@link Tw2TrackGroup}
 * @class
 */
var Tw2Animation = exports.Tw2Animation = function () {
    function Tw2Animation() {
        _classCallCheck(this, Tw2Animation);

        this.animationRes = null;
        this.time = 0;
        this.timeScale = 1.0;
        this.cycle = false;
        this.isPlaying = false;
        this.callback = null;
        this.trackGroups = [];
    }

    /**
     * Checks to see if the animation has finished playing
     * @return {boolean}
     */


    _createClass(Tw2Animation, [{
        key: "IsFinished",
        value: function IsFinished() {
            return !this.cycle && this.time >= this.animationRes.duration;
        }
    }]);

    return Tw2Animation;
}();

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2TextureRes = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2ResMan = __webpack_require__(6);

var _Tw2Device = __webpack_require__(2);

var _Tw2Logger = __webpack_require__(4);

var _Tw2Resource2 = __webpack_require__(12);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2TextureRes
 *
 * @property {WebGLTexture} texture
 * @property {boolean} isCube
 * @property {Array} images
 * @property {number} width
 * @property {number} height
 * @property {number} _facesLoaded
 * @property {boolean} hasMipMaps
 * @property {number} _currentSampler
 * @property {boolean} isAttached - identifies if the texture was attached rather than loaded
 * @inherit Tw2Resource
 */
var Tw2TextureRes = exports.Tw2TextureRes = function (_Tw2Resource) {
    _inherits(Tw2TextureRes, _Tw2Resource);

    function Tw2TextureRes() {
        _classCallCheck(this, Tw2TextureRes);

        var _this = _possibleConstructorReturn(this, (Tw2TextureRes.__proto__ || Object.getPrototypeOf(Tw2TextureRes)).call(this));

        _this.texture = null;
        _this.isCube = false;
        _this.images = [];
        _this.width = 0;
        _this.height = 0;
        _this.hasMipMaps = false;
        _this._facesLoaded = 0;
        _this._currentSampler = 0;
        _this._isAttached = false;
        return _this;
    }

    /**
     * Prepares the resource
     * @param {string} text
     */


    _createClass(Tw2TextureRes, [{
        key: 'Prepare',
        value: function Prepare(text) {
            var d = _Tw2Device.device,
                format = this.images[0]['ccpGLFormat'] ? this.images[0]['ccpGLFormat'] : d.gl.RGBA;

            switch (text) {
                case 'cube':
                    this.texture = d.gl.createTexture();
                    d.gl.bindTexture(d.gl.TEXTURE_CUBE_MAP, this.texture);
                    var canvas = document.createElement('canvas');
                    canvas.width = canvas.height = this.images[0].height;
                    var ctx = canvas.getContext('2d');
                    for (var j = 0; j < 6; ++j) {
                        ctx.drawImage(this.images[0], j * canvas.width, 0, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
                        d.gl.texImage2D(d.gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, format, format, d.gl.UNSIGNED_BYTE, canvas);
                    }
                    d.gl.generateMipmap(d.gl.TEXTURE_CUBE_MAP);
                    d.gl.bindTexture(d.gl.TEXTURE_CUBE_MAP, null);
                    this.width = canvas.width;
                    this.height = canvas.height;
                    this.hasMipMaps = true;
                    this._isAttached = false;
                    this.PrepareFinished(true);
                    break;

                //case 'png':
                default:
                    this.texture = d.gl.createTexture();
                    d.gl.bindTexture(d.gl.TEXTURE_2D, this.texture);
                    d.gl.texImage2D(d.gl.TEXTURE_2D, 0, format, format, d.gl.UNSIGNED_BYTE, this.images[0]);
                    this.hasMipMaps = Tw2TextureRes.IsPowerOfTwo(this.images[0].width) && Tw2TextureRes.IsPowerOfTwo(this.images[0].height);
                    if (this.hasMipMaps) d.gl.generateMipmap(d.gl.TEXTURE_2D);
                    d.gl.bindTexture(d.gl.TEXTURE_2D, null);
                    this.width = this.images[0].width;
                    this.height = this.images[0].height;
                    this._isAttached = false;
                    this.PrepareFinished(true);
                    break;
            }

            this.images = null;
        }

        /**
         * An optional method resources can have that allows them to take over loading their resources
         * @param {string} path - texture resource path
         * @returns {boolean} returns true to tell the resMan not to handle http requests
         */

    }, {
        key: 'DoCustomLoad',
        value: function DoCustomLoad(path) {
            var _this2 = this;

            var ext = _Tw2ResMan.resMan.constructor.GetPathExt(path);
            switch (ext) {
                case 'cube':
                    this.isCube = true;
                    path = path.substr(0, path.length - 5) + '.png';
                    break;

                //case 'png':
                default:
                    this.isCube = false;
                    break;
            }

            this.LoadStarted();
            _Tw2ResMan.resMan._pendingLoads++;

            this.images = [];
            this.images[0] = new Image();
            this.images[0].crossOrigin = 'anonymous';

            /**
             * Fires on errors
             */
            this.images[0].onerror = function () {
                _Tw2ResMan.resMan._pendingLoads--;
                _Tw2Logger.logger.log('res.error', {
                    log: 'error',
                    src: ['Tw2TextureRes', 'DoCustomLoad'],
                    msg: 'Error loading resource',
                    type: 'http.error',
                    path: path
                });
                _this2.LoadFinished(false);
                _this2.PrepareFinished(false);
                _this2.images = null;
            };

            /**
             * Fires when loaded
             */
            this.images[0].onload = function () {
                _Tw2ResMan.resMan._pendingLoads--;
                _Tw2ResMan.resMan._prepareQueue.push([_this2, ext, null]);
                _this2.LoadFinished(true);
            };

            this.images[0].src = Tw2TextureRes.AddMipLevelSkipCount(path);
            return true;
        }

        /**
         * Unloads the texture from memory
         * @returns {boolean}
         */

    }, {
        key: 'Unload',
        value: function Unload() {
            if (this.texture) {
                _Tw2Device.device.gl.deleteTexture(this.texture);
                this.texture = null;
            }
            this._isPurged = true;
            this._isGood = false;
            this._isAttached = false;
            return true;
        }

        /**
         * Attach
         * @param {WebGLTexture} texture
         */

    }, {
        key: 'Attach',
        value: function Attach(texture) {
            this.texture = texture;
            this._isAttached = true;
            this.LoadFinished(true);
            this.PrepareFinished(true);
        }

        /**
         * Bind
         * @param sampler
         * @param slices
         */

    }, {
        key: 'Bind',
        value: function Bind(sampler, slices) {
            var d = _Tw2Device.device;

            this.KeepAlive();
            var targetType = sampler.samplerType;
            if (targetType !== (this.isCube ? d.gl.TEXTURE_CUBE_MAP : d.gl.TEXTURE_2D)) return;

            if (!this.texture) {
                var texture = targetType === d.gl.TEXTURE_2D ? d.GetFallbackTexture() : d.GetFallbackCubeMap();
                d.gl.bindTexture(targetType, texture);
                return;
            }

            if (sampler.isVolume) {
                d.gl.uniform1f(slices, this.height / this.width);
            }

            d.gl.bindTexture(targetType, this.texture);
            if (sampler.hash !== this._currentSampler) {
                sampler.Apply(this.hasMipMaps);
                this._currentSampler = sampler.hash;
            }
        }

        /**
         * Finds out if a number is to the power of 2
         * @param {number} x
         * @returns {boolean}
         */

    }], [{
        key: 'IsPowerOfTwo',
        value: function IsPowerOfTwo(x) {
            return (x & x - 1) === 0;
        }

        /**
         * Adds mip levels to a path
         * @param {string} path
         * @returns {string}}
         */

    }, {
        key: 'AddMipLevelSkipCount',
        value: function AddMipLevelSkipCount(path) {
            var d = _Tw2Device.device,
                mipExt = d.mipLevelSkipCount > 0 ? '.' + d.mipLevelSkipCount.toString() : '';

            if (d.mipLevelSkipCount > 0) {
                var index = path.lastIndexOf('.');
                if (index >= 0) {
                    path = path.substr(0, index - 2) + mipExt + path.substr(index);
                }
            }
            return path;
        }
    }]);

    return Tw2TextureRes;
}(_Tw2Resource2.Tw2Resource);

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Bone = undefined;

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2Bone
 *
 * @property {Tw2GeometryBone} boneRes
 * @property {mat4} localTransform
 * @property {mat4} worldTransform
 * @property {mat4} offsetTransform
 * @class
 */
var Tw2Bone = exports.Tw2Bone = function Tw2Bone() {
    _classCallCheck(this, Tw2Bone);

    this.boneRes = null;
    this.localTransform = _math.mat4.create();
    this.worldTransform = _math.mat4.create();
    this.offsetTransform = _math.mat4.create();
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2Model
 *
 * @property {Tw2GeometryModel} modelRes
 * @property {Array.<Tw2Bone>} bones
 * @property {Object.<string, Tw2Bone>} bonesByName - An object containing every Tw2Bone name and it's object
 * @class
 */
var Tw2Model = exports.Tw2Model = function Tw2Model() {
    _classCallCheck(this, Tw2Model);

    this.modelRes = null;
    this.bones = [];
    this.bonesByName = {};
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2Track
 *
 * @property {Tw2GeometryTransformTrack} trackRes
 * @property {Tw2Bone} bone
 * @class
 */
var Tw2Track = exports.Tw2Track = function Tw2Track() {
    _classCallCheck(this, Tw2Track);

    this.trackRes = null;
    this.bone = null;
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2TrackGroup
 *
 * @property {Tw2GeometryTrackGroup} trackGroupRes
 * @property {Tw2GeometryModel} model
 * @property {Array.<Tw2GeometryTransformTrack>} transformTracks
 * @class
 */
var Tw2TrackGroup = exports.Tw2TrackGroup = function Tw2TrackGroup() {
    _classCallCheck(this, Tw2TrackGroup);

    this.trackGroupRes = null;
    this.model = null;
    this.transformTracks = [];
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2RenderTarget = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Device = __webpack_require__(2);

var _Tw2TextureRes = __webpack_require__(51);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2RenderTarget
 *
 * @property {string|number} _id               - the render target's id
 * @property {string} name                     - the render target's name
 * @property {Tw2TextureRes} texture           - the render target's texture
 * @property {?number} width                   - width of the render target's texture
 * @property {?number} height                  - height of the render target's texture
 * @property {?boolean} hasDepth               - toggles depth
 * @property {WebGLFramebuffer} _frameBuffer   - the render target's webgl frame buffer
 * @property {WebGLRenderbuffer} _renderBuffer - the render target's webgl render buffer
 * @class
 */
var Tw2RenderTarget = exports.Tw2RenderTarget = function () {
    function Tw2RenderTarget() {
        _classCallCheck(this, Tw2RenderTarget);

        this._id = _math.util.generateID();
        this.name = '';
        this.texture = null;
        this.width = null;
        this.height = null;
        this.hasDepth = null;
        this._frameBuffer = null;
        this._renderBuffer = null;
    }

    /**
     * Destroys the render target's webgl buffers and textures
     */


    _createClass(Tw2RenderTarget, [{
        key: 'Destroy',
        value: function Destroy() {
            if (this.texture) {
                _Tw2Device.device.gl.deleteTexture(this.texture.texture);
                this.texture = null;
            }

            if (this._renderBuffer) {
                _Tw2Device.device.gl.deleteRenderbuffer(this._renderBuffer);
                this._renderBuffer = null;
            }

            if (this._frameBuffer) {
                _Tw2Device.device.gl.deleteFramebuffer(this._frameBuffer);
                this._frameBuffer = null;
            }
        }

        /**
         * Creates the render target's texture
         *
         * @param {number} width     - The resulting texture's width
         * @param {number} height    - The resulting texture's height
         * @param {boolean} hasDepth - Optional flag to enable a depth buffer
         */

    }, {
        key: 'Create',
        value: function Create(width, height, hasDepth) {
            this.Destroy();
            this.texture = new _Tw2TextureRes.Tw2TextureRes();
            this.texture.Attach(_Tw2Device.device.gl.createTexture());

            this._frameBuffer = _Tw2Device.device.gl.createFramebuffer();
            _Tw2Device.device.gl.bindFramebuffer(_Tw2Device.device.gl.FRAMEBUFFER, this._frameBuffer);

            _Tw2Device.device.gl.bindTexture(_Tw2Device.device.gl.TEXTURE_2D, this.texture.texture);
            _Tw2Device.device.gl.texImage2D(_Tw2Device.device.gl.TEXTURE_2D, 0, _Tw2Device.device.gl.RGBA, width, height, 0, _Tw2Device.device.gl.RGBA, _Tw2Device.device.gl.UNSIGNED_BYTE, null);
            _Tw2Device.device.gl.texParameteri(_Tw2Device.device.gl.TEXTURE_2D, _Tw2Device.device.gl.TEXTURE_MAG_FILTER, _Tw2Device.device.gl.LINEAR);
            _Tw2Device.device.gl.texParameteri(_Tw2Device.device.gl.TEXTURE_2D, _Tw2Device.device.gl.TEXTURE_MIN_FILTER, _Tw2Device.device.gl.LINEAR);
            _Tw2Device.device.gl.bindTexture(_Tw2Device.device.gl.TEXTURE_2D, null);

            this._renderBuffer = null;

            if (hasDepth) {
                this._renderBuffer = _Tw2Device.device.gl.createRenderbuffer();
                _Tw2Device.device.gl.bindRenderbuffer(_Tw2Device.device.gl.RENDERBUFFER, this._renderBuffer);
                _Tw2Device.device.gl.renderbufferStorage(_Tw2Device.device.gl.RENDERBUFFER, _Tw2Device.device.gl.DEPTH_COMPONENT16, width, height);
            }

            _Tw2Device.device.gl.framebufferTexture2D(_Tw2Device.device.gl.FRAMEBUFFER, _Tw2Device.device.gl.COLOR_ATTACHMENT0, _Tw2Device.device.gl.TEXTURE_2D, this.texture.texture, 0);

            if (hasDepth) {
                _Tw2Device.device.gl.framebufferRenderbuffer(_Tw2Device.device.gl.FRAMEBUFFER, _Tw2Device.device.gl.DEPTH_ATTACHMENT, _Tw2Device.device.gl.RENDERBUFFER, this._renderBuffer);
            }

            _Tw2Device.device.gl.bindRenderbuffer(_Tw2Device.device.gl.RENDERBUFFER, null);
            _Tw2Device.device.gl.bindFramebuffer(_Tw2Device.device.gl.FRAMEBUFFER, null);

            this.texture.width = this.width = width;
            this.texture.height = this.height = height;
            this.hasDepth = hasDepth;
        }

        /**
         * Sets the render target as the current frame buffer
         */

    }, {
        key: 'Set',
        value: function Set() {
            _Tw2Device.device.gl.bindFramebuffer(_Tw2Device.device.gl.FRAMEBUFFER, this._frameBuffer);
            _Tw2Device.device.gl.viewport(0, 0, this.width, this.height);
        }

        /**
         * Unsets the render target as the current frame buffer
         */

    }, {
        key: 'Unset',
        value: function Unset() {
            _Tw2Device.device.gl.bindFramebuffer(_Tw2Device.device.gl.FRAMEBUFFER, null);
            _Tw2Device.device.gl.viewport(0, 0, _Tw2Device.device.viewportWidth, _Tw2Device.device.viewportHeight);
        }
    }]);

    return Tw2RenderTarget;
}();

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _curves = __webpack_require__(19);

Object.keys(_curves).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _curves[key];
    }
  });
});

var _sequencers = __webpack_require__(155);

Object.keys(_sequencers).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _sequencers[key];
    }
  });
});

var _tracks = __webpack_require__(164);

Object.keys(_tracks).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _tracks[key];
    }
  });
});

var _maya = __webpack_require__(167);

Object.keys(_maya).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _maya[key];
    }
  });
});

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _EveChild = __webpack_require__(14);

Object.keys(_EveChild).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveChild[key];
    }
  });
});

var _EveChildBillboard = __webpack_require__(173);

Object.keys(_EveChildBillboard).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveChildBillboard[key];
    }
  });
});

var _EveChildContainer = __webpack_require__(174);

Object.keys(_EveChildContainer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveChildContainer[key];
    }
  });
});

var _EveChildExplosion = __webpack_require__(175);

Object.keys(_EveChildExplosion).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveChildExplosion[key];
    }
  });
});

var _EveChildMesh = __webpack_require__(176);

Object.keys(_EveChildMesh).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveChildMesh[key];
    }
  });
});

var _EveChildParticleSystem = __webpack_require__(177);

Object.keys(_EveChildParticleSystem).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveChildParticleSystem[key];
    }
  });
});

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveOccluder = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EveOccluder
 *
 * @property {number|string} _id
 * @property {String} name
 * @property {number} value
 * @property {Array.<EveSpriteSet>} sprites
 * @class
 */
var EveOccluder = exports.EveOccluder = function () {
    function EveOccluder() {
        _classCallCheck(this, EveOccluder);

        this._id = _math.util.generateID();
        this.name = '';
        this.value = 1;
        this.sprites = [];

        EveOccluder.init();
    }

    /**
     * UpdateValues
     * @param {mat4} parentTransform
     * @param {number} index
     */


    _createClass(EveOccluder, [{
        key: 'UpdateValue',
        value: function UpdateValue(parentTransform, index) {
            if (!_core.device.alphaBlendBackBuffer) return;

            var d = _core.device,
                g = EveOccluder.global,
                worldViewProj = g.mat4_0,
                center = g.vec4_0;

            g.accumulator.Clear();

            for (var i = 0; i < this.sprites.length; ++i) {
                this.sprites[i].UpdateViewDependentData(parentTransform);
                this.sprites[i].GetBatches(d.RM_DECAL, g.accumulator);
            }

            _core.store.SetVariableValue('OccluderValue', [(1 << index * 2) / 255.0, (2 << index * 2) / 255.0, 0, 0]);

            g.accumulator.Render();

            _math.mat4.multiply(worldViewProj, d.viewProjection, this.sprites[0].worldTransform);
            _math.vec4.transformMat4(center, [0, 0, 0, 1], worldViewProj);

            var x0 = (center[0] / center[3] + 1) * 0.5,
                y0 = (center[1] / center[3] + 1) * 0.5;

            _math.vec4.set(center, 0.5, 0.5, 0, 1);
            _math.vec4.transformMat4(center, center, worldViewProj);

            var x1 = (center[0] / center[3] + 1) * 0.5,
                y1 = (center[1] / center[3] + 1) * 0.5;

            center[0] = x0;
            center[1] = y0;
            center[2] = x1 - x0;
            center[3] = y1 - y0;

            g.effect.parameters.OccluderPosition.SetValue(center);
        }

        /**
         * CollectSamples
         * @param {Tw2TextureRes} tex
         * @param {number} index
         * @param {number} total
         * @param {number} samples
         * @returns boolean
         */

    }], [{
        key: 'CollectSamples',
        value: function CollectSamples(tex, index, total, samples) {
            var d = _core.device,
                g = this.global,
                effect = g.effect,
                vertexBuffer = g.vertexBuffer,
                decl = g.decl;

            if (!effect.effectRes || !effect.effectRes.IsGood()) return false;

            effect.parameters.BackBuffer.textureRes = tex;
            effect.parameters.OccluderIndex.SetValue([index, total, samples]);

            d.SetStandardStates(d.RM_ADDITIVE);
            d.gl.bindBuffer(d.gl.ARRAY_BUFFER, vertexBuffer);

            for (var pass = 0; pass < effect.GetPassCount('Main'); ++pass) {
                effect.ApplyPass('Main', pass);
                if (decl.SetDeclaration(effect.GetPassInput('Main', pass), 16)) return false;
                d.ApplyShadowState();
                d.gl.drawArrays(d.gl.TRIANGLES, 0, 255 * 6);
            }
            return true;
        }

        /**
         * Initializes class globals and scratch variables
         */

    }, {
        key: 'init',
        value: function init() {
            if (EveOccluder.global) return;

            var d = _core.device,
                g = EveOccluder.global = {};

            g.mat4_0 = _math.mat4.create();
            g.vec4_0 = _math.vec4.create();
            g.accumulator = new _core.Tw2BatchAccumulator();

            g.effect = _core.Tw2Effect.create({
                name: 'Occluder sampler',
                effectFilePath: 'res:/graphics/effect/managed/space/specialfx/lensflares/collectsamples.fx',
                parameters: {
                    'OccluderPosition': [1, 1, 1, 1],
                    'OccluderIndex': [1, 1, 1],
                    'BackBuffer': ''
                }
            });

            g.vertexBuffer = null;
            g.decl = new _core.Tw2VertexDeclaration();
            g.decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.POSITION, 0, d.gl.FLOAT, 2, 0));
            g.decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 0, d.gl.FLOAT, 2, 8));
            g.decl.RebuildHash();

            var vb = new Float32Array(255 * 6 * 4);
            var index = 0;
            for (var i = 0; i < 16; ++i) {
                for (var j = 0; j < 16; ++j) {
                    var x = (i + Math.random()) / 16 * 2 - 1,
                        y = (j + Math.random()) / 16 * 2 - 1;

                    vb[index++] = 1;
                    vb[index++] = 1;
                    vb[index++] = x;
                    vb[index++] = y;
                    vb[index++] = -1;
                    vb[index++] = 1;
                    vb[index++] = x;
                    vb[index++] = y;
                    vb[index++] = 1;
                    vb[index++] = -1;
                    vb[index++] = x;
                    vb[index++] = y;

                    vb[index++] = -1;
                    vb[index++] = 1;
                    vb[index++] = x;
                    vb[index++] = y;
                    vb[index++] = 1;
                    vb[index++] = -1;
                    vb[index++] = x;
                    vb[index++] = y;
                    vb[index++] = -1;
                    vb[index++] = -1;
                    vb[index++] = x;
                    vb[index++] = y;
                }
            }

            g.vertexBuffer = d.gl.createBuffer();
            d.gl.bindBuffer(d.gl.ARRAY_BUFFER, g.vertexBuffer);
            d.gl.bufferData(d.gl.ARRAY_BUFFER, vb, d.gl.STATIC_DRAW);
            d.gl.bindBuffer(d.gl.ARRAY_BUFFER, null);
        }
    }]);

    return EveOccluder;
}();

/**
 * Class global and scratch variables
 * @type {*}
 */


EveOccluder.global = null;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _EveObject = __webpack_require__(15);

Object.keys(_EveObject).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveObject[key];
    }
  });
});

var _EveEffectRoot = __webpack_require__(183);

Object.keys(_EveEffectRoot).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveEffectRoot[key];
    }
  });
});

var _EveMissile = __webpack_require__(184);

Object.keys(_EveMissile).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveMissile[key];
    }
  });
});

var _EvePlanet = __webpack_require__(185);

Object.keys(_EvePlanet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EvePlanet[key];
    }
  });
});

var _EveShip = __webpack_require__(186);

Object.keys(_EveShip).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveShip[key];
    }
  });
});

var _EveSpaceObject = __webpack_require__(62);

Object.keys(_EveSpaceObject).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveSpaceObject[key];
    }
  });
});

var _EveTransform = __webpack_require__(61);

Object.keys(_EveTransform).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveTransform[key];
    }
  });
});

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveTransform = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveObject2 = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EveTransform
 *
 * @property {{}} visible                                           - Batch accumulation options for the transforms's elements
 * @property {Boolean} visible.mesh                                 - Enables/ disables mesh batch accumulation
 * @property {Boolean} visible.children                             - Enables/ disables child batch accumulation
 * @property {Tw2Mesh} mesh
 * @property {Array.<Tw2CurveSet>} curveSets
 * @property {Array} children
 * @property {Array.<Tw2ParticleSystem>} particleSystems
 * @property {Array.<Tw2StaticEmitter|Tw2DynamicEmitter>} particleEmitters
 * @property {Number} Modifier
 * @property {Number} sortValueMultiplier
 * @property {Number} distanceBasedScaleArg1
 * @property {Number} distanceBasedScaleArg2
 * @property {Boolean} useDistanceBasedScale
 * @property {vec3} scaling
 * @property {vec3} translation
 * @property {quat} rotation
 * @property {mat4} localTransform
 * @property {mat4} worldTransform
 * @property {Array.<mat4>} _mat4Cache
 * @property {Array.<vec3>} _vec3Cache
 * @property {Tw2BasicPerObjectData} _perObjectData
 * @class
 */
var EveTransform = exports.EveTransform = function (_EveObject) {
    _inherits(EveTransform, _EveObject);

    function EveTransform() {
        _classCallCheck(this, EveTransform);

        var _this = _possibleConstructorReturn(this, (EveTransform.__proto__ || Object.getPrototypeOf(EveTransform)).call(this));

        _this.visible = {};
        _this.visible.mesh = true;
        _this.visible.children = true;
        _this.mesh = null;
        _this.curveSets = [];
        _this.children = [];
        _this.particleSystems = [];
        _this.particleEmitters = [];
        _this.modifier = EveTransform.Modifier.NONE;
        _this.sortValueMultiplier = 1.0;
        _this.distanceBasedScaleArg1 = 0.2;
        _this.distanceBasedScaleArg2 = 0.63;
        _this.useDistanceBasedScale = false;
        _this.scaling = _math.vec3.fromValues(1, 1, 1);
        _this.translation = _math.vec3.create();
        _this.rotation = _math.quat.create();
        _this.localTransform = _math.mat4.create();
        _this.worldTransform = _math.mat4.create();

        _this._perObjectData = new _core.Tw2BasicPerObjectData();
        _this._perObjectData.perObjectFFEData = new _core.Tw2RawData();
        _this._perObjectData.perObjectFFEData.Declare('World', 16);
        _this._perObjectData.perObjectFFEData.Declare('WorldInverseTranspose', 16);
        _this._perObjectData.perObjectFFEData.Create();
        return _this;
    }

    /**
     * Initializes the EveTransform
     */


    _createClass(EveTransform, [{
        key: 'Initialize',
        value: function Initialize() {
            _math.mat4.fromRotationTranslationScale(this.localTransform, this.rotation, this.translation, this.scaling);
        }

        /**
         * Gets transform res objects
         * @param {Array} [out=[]] - Optional receiving array
         * @param {Boolean} [excludeChildren] - True to exclude children's res objects
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var excludeChildren = arguments[1];

            if (this.mesh) this.mesh.GetResources(out);

            if (!excludeChildren) {
                for (var i = 0; i < this.children; i++) {
                    this.children[i].GetResources(out);
                }
            }

            return out;
        }

        /**
         * Per frame update
         * @param {mat4} parentTransform
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData(parentTransform) {
            var d = _core.device,
                g = EveTransform.global,
                finalScale = g.vec3_0,
                parentScale = g.vec3_1,
                dir = g.vec3_2,
                viewInv = d.viewInverse;

            _math.quat.normalize(this.rotation, this.rotation);
            _math.mat4.fromRotationTranslationScale(this.localTransform, this.rotation, this.translation, this.scaling);
            _math.mat4.getScaling(parentScale, parentTransform);

            switch (this.modifier) {
                case EveTransform.Modifier.BILLBOARD:
                case EveTransform.Modifier.SIMPLE_HALO:
                    var dirNorm = g.vec3_3;
                    _math.mat4.multiply(this.worldTransform, parentTransform, this.localTransform);
                    _math.vec3.multiply(finalScale, this.scaling, parentScale);

                    if (this.modifier === EveTransform.Modifier.SIMPLE_HALO) {
                        _math.vec3.subtract(dir, d.GetEyePosition(dir), this.worldTransform.subarray(12));
                        _math.vec3.normalize(dirNorm, this.worldTransform.subarray(8));
                        _math.vec3.normalize(dir, dir);
                        var scale = _math.vec3.dot(dir, dirNorm);
                        if (scale < 0) scale = 0;
                        _math.vec3.scale(finalScale, finalScale, scale * scale);
                    }

                    this.worldTransform[0] = viewInv[0] * finalScale[0];
                    this.worldTransform[1] = viewInv[1] * finalScale[0];
                    this.worldTransform[2] = viewInv[2] * finalScale[0];
                    this.worldTransform[4] = viewInv[4] * finalScale[1];
                    this.worldTransform[5] = viewInv[5] * finalScale[1];
                    this.worldTransform[6] = viewInv[6] * finalScale[1];
                    this.worldTransform[8] = viewInv[8] * finalScale[2];
                    this.worldTransform[9] = viewInv[9] * finalScale[2];
                    this.worldTransform[10] = viewInv[10] * finalScale[2];
                    break;

                case EveTransform.Modifier.EVE_CAMERA_ROTATION:
                    var translation = g.vec3_3;
                    _math.vec3.transformMat4(translation, this.translation, parentTransform);
                    _math.mat4.fromRotationTranslationScale(this.localTransform, this.rotation, translation, this.scaling);
                    _math.mat4.multiply(this.worldTransform, viewInv, this.localTransform);
                    this.worldTransform[12] = this.localTransform[12];
                    this.worldTransform[13] = this.localTransform[13];
                    this.worldTransform[14] = this.localTransform[14];
                    break;

                case EveTransform.Modifier.EVE_CAMERA_ROTATION_ALIGNED:
                case EveTransform.Modifier.EVE_SIMPLE_HALO:
                    var camFwd = g.vec3_3,
                        right = g.vec3_4,
                        up = g.vec3_5,
                        forward = g.vec3_6,
                        dirToCamNorm = g.vec3_7,
                        parentT = g.mat4_0,
                        alignMat = g.mat4_1,
                        rotationT = g.mat4_2;

                    // 3 4 3 3 3 4 3 3
                    _math.mat4.translate(this.worldTransform, parentTransform, this.translation);
                    _math.mat4.transpose(parentT, parentTransform);

                    d.GetEyePosition(dir);
                    dir[0] -= this.worldTransform[12];
                    dir[1] -= this.worldTransform[13];
                    dir[2] -= this.worldTransform[14];

                    _math.vec3.copy(camFwd, dir);
                    _math.vec3.transformMat4(camFwd, camFwd, parentT);
                    _math.vec3.divide(camFwd, camFwd, parentScale);
                    _math.vec3.normalize(camFwd, camFwd);

                    _math.vec3.set(right, d.view[0], d.view[4], d.view[8]);
                    _math.vec3.transformMat4(right, right, parentT);
                    _math.vec3.normalize(right, right);

                    _math.vec3.cross(up, camFwd, right);
                    _math.vec3.normalize(up, up);
                    _math.vec3.cross(right, up, camFwd);

                    alignMat[0] = right[0];
                    alignMat[1] = right[1];
                    alignMat[2] = right[2];
                    alignMat[4] = up[0];
                    alignMat[5] = up[1];
                    alignMat[6] = up[2];
                    alignMat[8] = camFwd[0];
                    alignMat[9] = camFwd[1];
                    alignMat[10] = camFwd[2];
                    alignMat[15] = 1;

                    _math.mat4.fromQuat(rotationT, this.rotation);
                    _math.mat4.multiply(alignMat, alignMat, rotationT);

                    if (this.modifier === EveTransform.Modifier.EVE_SIMPLE_HALO) {
                        _math.vec3.normalize(forward, this.worldTransform.subarray(8));
                        _math.vec3.normalize(dirToCamNorm, dir);
                        var _scale = -_math.vec3.dot(dirToCamNorm, forward);
                        if (_scale < 0) _scale = 0;
                        _math.mat4.multiply(this.worldTransform, this.worldTransform, alignMat);
                        _math.mat4.scale(this.worldTransform, this.worldTransform, [this.scaling[0] * _scale, this.scaling[1] * _scale, this.scaling[2] * _scale]);
                    } else {
                        _math.mat4.scale(this.worldTransform, this.worldTransform, this.scaling);
                        _math.mat4.multiply(this.worldTransform, this.worldTransform, alignMat);
                    }
                    break;

                case EveTransform.Modifier.LOOK_AT_CAMERA:
                    var lookAt = g.mat4_0;
                    _math.mat4.multiply(this.worldTransform, parentTransform, this.localTransform);
                    _math.mat4.lookAt(lookAt, viewInv.subarray(12), this.worldTransform.subarray(12), [0, 1, 0]);
                    _math.mat4.transpose(lookAt, lookAt);
                    _math.vec3.multiply(finalScale, this.scaling, parentScale);
                    this.worldTransform[0] = lookAt[0] * finalScale[0];
                    this.worldTransform[1] = lookAt[1] * finalScale[0];
                    this.worldTransform[2] = lookAt[2] * finalScale[0];
                    this.worldTransform[4] = lookAt[4] * finalScale[1];
                    this.worldTransform[5] = lookAt[5] * finalScale[1];
                    this.worldTransform[6] = lookAt[6] * finalScale[1];
                    this.worldTransform[8] = lookAt[8] * finalScale[2];
                    this.worldTransform[9] = lookAt[9] * finalScale[2];
                    this.worldTransform[10] = lookAt[10] * finalScale[2];
                    break;

                default:
                    _math.mat4.multiply(this.worldTransform, parentTransform, this.localTransform);
            }

            for (var i = 0; i < this.children.length; ++i) {
                this.children[i].UpdateViewDependentData(this.worldTransform);
            }
        }

        /**
         * Per frame update
         * @param {Number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            for (var i = 0; i < this.children.length; ++i) {
                this.children[i].Update(dt);
            }

            for (var _i = 0; _i < this.particleEmitters.length; ++_i) {
                this.particleEmitters[_i].Update(dt);
            }

            for (var _i2 = 0; _i2 < this.particleSystems.length; ++_i2) {
                this.particleSystems[_i2].Update(dt);
            }

            for (var _i3 = 0; _i3 < this.curveSets.length; ++_i3) {
                this.curveSets[_i3].Update(dt);
            }
        }

        /**
         * Gets render batches for accumulation
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData|Tw2BasicPerObjectData} [perObjectData]
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (!this.display) return;

            if (this.visible.mesh && this.mesh) {
                _math.mat4.transpose(this._perObjectData.perObjectFFEData.Get('World'), this.worldTransform);
                _math.mat4.invert(this._perObjectData.perObjectFFEData.Get('WorldInverseTranspose'), this.worldTransform);

                if (perObjectData) {
                    this._perObjectData.perObjectVSData = perObjectData.perObjectVSData;
                    this._perObjectData.perObjectPSData = perObjectData.perObjectPSData;
                }

                this.mesh.GetBatches(mode, accumulator, this._perObjectData);
            }

            if (this.visible.children) {
                for (var i = 0; i < this.children.length; ++i) {
                    this.children[i].GetBatches(mode, accumulator, perObjectData);
                }
            }
        }

        /**
         * multiply3x3
         */

    }], [{
        key: 'Multiply3x3',
        value: function Multiply3x3(a, b, c) {
            c || (c = b);
            var d = b[0],
                e = b[1];
            b = b[2];
            c[0] = a[0] * d + a[4] * e + a[8] * b;
            c[1] = a[1] * d + a[5] * e + a[9] * b;
            c[2] = a[2] * d + a[6] * e + a[10] * b;
            return c;
        }
    }]);

    return EveTransform;
}(_EveObject2.EveObject);

/**
 * Modifier states
 * @type {{string:Number}}
 */


EveTransform.Modifier = {
    NONE: 0,
    BILLBOARD: 1,
    TRANSLATE_WITH_CAMERA: 2,
    LOOK_AT_CAMERA: 3,
    SIMPLE_HALO: 4,
    EVE_CAMERA_ROTATION_ALIGNED: 100,
    EVE_BOOSTER: 101,
    EVE_SIMPLE_HALO: 102,
    EVE_CAMERA_ROTATION: 103
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveStation = exports.EveSpaceObject = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveObject2 = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EveSpaceObject
 *
 * @parameter {String} name
 * @parameter {boolean} display                             - Enables/ disables visibility
 * @parameter {{}} visible                                  - Visibility options for the space object's elements
 * @parameter {boolean} visible.mesh                        - Enables/ disables mesh visibility
 * @parameter {boolean} visible.children                    - Enables/ disables child visibility
 * @parameter {boolean} visible.effectChildren              - Enables/ disables effect child visibility
 * @parameter {boolean} visible.spriteSets                  - Enables/ disables sprite visibility
 * @parameter {boolean} visible.decals                      - Enables/ disables decal visibility
 * @parameter {boolean} visible.spotlightSets               - Enables/ disables spotlight visibility
 * @parameter {boolean} visible.planeSets                   - Enables/ disables plane visibility
 * @parameter {boolean} visible.lineSets                    - Enables/ disables lines visibility
 * @parameter {boolean} visible.overlayEffects              - Enables/ disables overlay effect visibility
 * @parameter {boolean} visible.killmarks                   - Enables/ disables killmark visibility
 * @parameter {boolean} visible.customMasks                 - Enables/ disables custom mask visibility
 * @parameter {Number} lod
 * @parameter {Tw2Mesh} mesh
 * @parameter {Array.<EveLocator>} locators
 * @parameter {Array.<EveSpriteSet>} spriteSets
 * @parameter {Array.<EveTurretSet>} turretSets
 * @parameter {Array.<EveSpaceObjectDecal>} decals
 * @parameter {Array.<EveSpotlightSet>} spotlightSets
 * @parameter {Array.<EvePlaneSet>} planeSets
 * @parameter {Array.<Tw2CurveSet>} curveSets
 * @parameter {Array.<EveCurveLineSet>} lineSets
 * @parameter {Array.<EveMeshOverlayEffect>} overlayEffects
 * @parameter {Array.<{}>} children
 * @parameter {vec3} boundingSphereCenter
 * @parameter {Number} boundingSphereRadius
 * @parameter {vec3} shapeEllipsoidRadius
 * @parameter {vec3} shapeEllipsoidCenter
 * @parameter {mat4} transform
 * @parameter {Tw2AnimationController} animation
 * @parameter {number} killCount                            - number of kills to show on kill counter decals
 * @parameter {Tw2PerObjectData} _perObjectData
 * @class
 */
var EveSpaceObject = exports.EveSpaceObject = function (_EveObject) {
    _inherits(EveSpaceObject, _EveObject);

    function EveSpaceObject() {
        _classCallCheck(this, EveSpaceObject);

        var _this = _possibleConstructorReturn(this, (EveSpaceObject.__proto__ || Object.getPrototypeOf(EveSpaceObject)).call(this));

        _this.visible = {};
        _this.visible.mesh = true;
        _this.visible.children = true;
        _this.visible.effectChildren = true;
        _this.visible.planeSets = true;
        _this.visible.spotlightSets = true;
        _this.visible.decals = true;
        _this.visible.spriteSets = true;
        _this.visible.overlayEffects = true;
        _this.visible.lineSets = true;
        _this.visible.killmarks = true;
        _this.visible.customMasks = true;

        _this.mesh = null;
        _this.animation = new _core.Tw2AnimationController();
        _this.locators = [];
        _this.spriteSets = [];
        _this.turretSets = [];
        _this.decals = [];
        _this.spotlightSets = [];
        _this.planeSets = [];
        _this.curveSets = [];
        _this.lineSets = [];
        _this.overlayEffects = [];
        _this.children = [];
        _this.effectChildren = [];
        _this.customMasks = [];
        _this.lod = 3;
        _this.killCount = 0;
        _this.transform = _math.mat4.create();
        _this.boundingSphereCenter = _math.vec3.create();
        _this.boundingSphereRadius = 0;
        _this.shapeEllipsoidRadius = _math.vec3.create();
        _this.shapeEllipsoidCenter = _math.vec3.create();

        _this._perObjectData = new _core.Tw2PerObjectData();
        _this._perObjectData.perObjectVSData = new _core.Tw2RawData();
        _this._perObjectData.perObjectVSData.Declare('WorldMat', 16);
        _this._perObjectData.perObjectVSData.Declare('WorldMatLast', 16);
        _this._perObjectData.perObjectVSData.Declare('Shipdata', 4);
        _this._perObjectData.perObjectVSData.Declare('Clipdata1', 4);
        _this._perObjectData.perObjectVSData.Declare('EllipsoidRadii', 4);
        _this._perObjectData.perObjectVSData.Declare('EllipsoidCenter', 4);
        _this._perObjectData.perObjectVSData.Declare('CustomMaskMatrix0', 16);
        _this._perObjectData.perObjectVSData.Declare('CustomMaskMatrix1', 16);
        _this._perObjectData.perObjectVSData.Declare('CustomMaskData0', 4);
        _this._perObjectData.perObjectVSData.Declare('CustomMaskData1', 4);
        _this._perObjectData.perObjectVSData.Declare('JointMat', 696);
        _this._perObjectData.perObjectVSData.Create();

        _this._perObjectData.perObjectPSData = new _core.Tw2RawData();
        _this._perObjectData.perObjectPSData.Declare('Shipdata', 4);
        _this._perObjectData.perObjectPSData.Declare('Clipdata1', 4);
        _this._perObjectData.perObjectPSData.Declare('Clipdata2', 4);
        _this._perObjectData.perObjectPSData.Declare('ShLighting', 4 * 7);
        _this._perObjectData.perObjectPSData.Declare('CustomMaskMaterialID0', 4);
        _this._perObjectData.perObjectPSData.Declare('CustomMaskMaterialID1', 4);
        _this._perObjectData.perObjectPSData.Declare('CustomMaskTarget0', 4);
        _this._perObjectData.perObjectPSData.Declare('CustomMaskTarget1', 4);
        _this._perObjectData.perObjectPSData.Create();

        _this._perObjectData.perObjectVSData.Get('Shipdata')[1] = 1;
        _this._perObjectData.perObjectPSData.Get('Shipdata')[1] = 1;
        _this._perObjectData.perObjectVSData.Get('Shipdata')[3] = -10;
        _this._perObjectData.perObjectPSData.Get('Shipdata')[3] = 1;

        _math.mat4.identity(_this._perObjectData.perObjectVSData.Get('CustomMaskMatrix0'));
        _math.mat4.identity(_this._perObjectData.perObjectVSData.Get('CustomMaskMatrix1'));
        return _this;
    }

    /**
     * Initializes the EveSpaceObject
     */


    _createClass(EveSpaceObject, [{
        key: 'Initialize',
        value: function Initialize() {
            if (this.mesh) {
                this.animation.SetGeometryResource(this.mesh.geometryResource);

                for (var i = 0; i < this.decals.length; ++i) {
                    this.decals[i].SetParentGeometry(this.mesh.geometryResource);
                }
            }
        }

        /**
         * Resets the lod
         */

    }, {
        key: 'ResetLod',
        value: function ResetLod() {
            this.lod = 3;
        }

        /**
         * Updates the lod
         * @param {Tw2Frustum} frustum
         */

    }, {
        key: 'UpdateLod',
        value: function UpdateLod(frustum) {
            var center = _math.vec3.transformMat4(EveSpaceObject.global.vec3_0, this.boundingSphereCenter, this.transform);

            if (frustum.IsSphereVisible(center, this.boundingSphereRadius)) {
                if (frustum.GetPixelSizeAcross(center, this.boundingSphereRadius) < 100) {
                    this.lod = 1;
                } else {
                    this.lod = 2;
                }
            } else {
                this.lod = 0;
            }
        }

        /**
         * Adds a custom mask
         * @param {vec3} position
         * @param {vec3} scaling
         * @param {quat} rotation
         * @param {vec4} isMirrored
         * @param {vec4} sourceMaterial
         * @param {vec4} targetMaterials
         */

    }, {
        key: 'AddCustomMask',
        value: function AddCustomMask(position, scaling, rotation, isMirrored, sourceMaterial, targetMaterials) {
            var transform = _math.mat4.fromRotationTranslationScale(_math.mat4.create(), rotation, position, scaling);
            _math.mat4.invert(transform, transform);
            _math.mat4.transpose(transform, transform);

            this.customMasks.push({
                transform: transform,
                maskData: _math.vec4.fromValues(1, isMirrored ? 1 : 0, 0, 0),
                materialID: _math.vec4.fromValues(sourceMaterial, 0, 0, 0),
                targets: targetMaterials
            });
        }

        /**
         * Gets locator count for a specific locator group
         * @param {String} prefix
         * @returns {number}
         */

    }, {
        key: 'GetLocatorCount',
        value: function GetLocatorCount(prefix) {
            var locators = this.FindLocatorsByPrefix(prefix);
            return locators.length;
        }

        /**
         * Finds a locator's joint by name
         * @param {string} name
         * @returns {?mat4}
         */

    }, {
        key: 'FindLocatorJointByName',
        value: function FindLocatorJointByName(name) {
            var locator = this.FindLocatorBoneByName(name);
            return locator ? locator.worldTransform : null;
        }

        /**
         *
         * @param name
         * @returns {null}
         */

    }, {
        key: 'FindLocatorTransformByName',
        value: function FindLocatorTransformByName(name) {
            var locator = this.FindLocatorByName(name);
            return locator ? locator.transform : null;
        }

        /**
         * Checks if a locator prefix exists
         * @param {string} prefix
         * @returns {boolean}
         */

    }, {
        key: 'HasLocatorPrefix',
        value: function HasLocatorPrefix(prefix) {
            for (var i = 0; i < this.locators.length; i++) {
                if (this.locators[i].name.substring(0, prefix.length) === prefix) {
                    return true;
                }
            }
            return false;
        }

        /**
         * Finds a locator's bone by it's name
         * @param {String} name
         * @returns {?Tw2Bone} null if not found
         */

    }, {
        key: 'FindLocatorBoneByName',
        value: function FindLocatorBoneByName(name) {
            var model = this.animation.FindModelForMesh(0);
            if (model) {
                for (var i = 0; i < model.bones.length; ++i) {
                    if (model.bones[i].boneRes.name === name) {
                        return model.bones[i];
                    }
                }
            }
            return null;
        }

        /**
         * Finds a locator by name
         * @param {string} name
         * @returns {?EveLocator}
         */

    }, {
        key: 'FindLocatorByName',
        value: function FindLocatorByName(name) {
            for (var i = 0; i < this.locators.length; i++) {
                if (this.locators[i].name === name) {
                    return this.locators[i];
                }
            }
            return null;
        }

        /**
         * Finds locators with a given prefix
         * @param {string} prefix
         * @returns {Array<EveLocator>}
         */

    }, {
        key: 'FindLocatorsByPrefix',
        value: function FindLocatorsByPrefix(prefix) {
            var locators = [];
            for (var i = 0; i < this.locators.length; i++) {
                if (this.locators[i].name.indexOf(prefix) === 0) {
                    locators.push(this.locators[i]);
                }
            }
            return locators;
        }

        /**
         * Gets object's res objects
         * @param {Array} [out=[]] - Optional receiving array
         * @param {Boolean} excludeChildren - True to exclude children's res objects
         * @returns {Array.<Tw2EffectRes|Tw2TextureRes|Tw2GeometryRes>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var excludeChildren = arguments[1];

            if (this.mesh) this.mesh.GetResources(out);
            if (this.animation) this.animation.GetResources(out);

            _math.util.perArrayChild(this.spriteSets, 'GetResources', out);
            _math.util.perArrayChild(this.turretSets, 'GetResources', out);
            _math.util.perArrayChild(this.decals, 'GetResources', out);
            _math.util.perArrayChild(this.spotlightSets, 'GetResources', out);
            _math.util.perArrayChild(this.planeSets, 'GetResources', out);
            _math.util.perArrayChild(this.lineSets, 'GetResources', out);
            _math.util.perArrayChild(this.overlayEffects, 'GetResources', out);
            _math.util.perArrayChild(this.effectChildren, 'GetResources', out);

            if (!excludeChildren) {
                _math.util.perArrayChild(this.children, 'GetResources', out);
            }

            return out;
        }

        /**
         * A Per frame function that updates view dependent data
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData() {
            for (var i = 0; i < this.children.length; ++i) {
                this.children[i].UpdateViewDependentData(this.transform);
            }

            _math.mat4.transpose(this._perObjectData.perObjectVSData.Get('WorldMat'), this.transform);
            _math.mat4.transpose(this._perObjectData.perObjectVSData.Get('WorldMatLast'), this.transform);

            var center = this._perObjectData.perObjectVSData.Get('EllipsoidCenter'),
                radii = this._perObjectData.perObjectVSData.Get('EllipsoidRadii');

            if (this.shapeEllipsoidRadius[0] > 0) {
                center[0] = this.shapeEllipsoidCenter[0];
                center[1] = this.shapeEllipsoidCenter[1];
                center[2] = this.shapeEllipsoidCenter[2];
                radii[0] = this.shapeEllipsoidRadius[0];
                radii[1] = this.shapeEllipsoidRadius[1];
                radii[2] = this.shapeEllipsoidRadius[2];
            } else if (this.mesh && this.mesh.IsGood()) {
                _math.vec3.subtract(center, this.mesh.geometryResource.maxBounds, this.mesh.geometryResource.minBounds);
                _math.vec3.scale(center, center, 0.5 * 1.732050807);
                _math.vec3.add(radii, this.mesh.geometryResource.maxBounds, this.mesh.geometryResource.minBounds);
                _math.vec3.scale(radii, radii, 0.5);
            }

            for (var _i = 0; _i < this.customMasks.length; ++_i) {
                var targets = this.visible.customMasks ? this.customMasks[_i].targets : [0, 0, 0, 0];
                this._perObjectData.perObjectVSData.Set(_i ? 'CustomMaskMatrix1' : 'CustomMaskMatrix0', this.customMasks[_i].transform);
                this._perObjectData.perObjectVSData.Set(_i ? 'CustomMaskData1' : 'CustomMaskData0', this.customMasks[_i].maskData);
                this._perObjectData.perObjectPSData.Set(_i ? 'CustomMaskMaterialID1' : 'CustomMaskMaterialID0', this.customMasks[_i].materialID);
                this._perObjectData.perObjectPSData.Set(_i ? 'CustomMaskTarget1' : 'CustomMaskTarget0', targets);
            }

            if (this.animation.animations.length) {
                this._perObjectData.perObjectVSData.Set('JointMat', this.animation.GetBoneMatrices(0));
            }

            for (var _i2 = 0; _i2 < this.lineSets.length; ++_i2) {
                this.lineSets[_i2].UpdateViewDependentData(this.transform);
            }
        }

        /**
         * Per frame update
         * @param {Number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            if (this.lod > 0) {
                for (var i = 0; i < this.spriteSets.length; ++i) {
                    this.spriteSets[i].Update(dt);
                }

                for (var _i3 = 0; _i3 < this.planeSets.length; _i3++) {
                    this.planeSets[_i3].Update(dt);
                }

                for (var _i4 = 0; _i4 < this.spotlightSets.length; _i4++) {
                    this.spotlightSets[_i4].Update(dt);
                }

                for (var _i5 = 0; _i5 < this.children.length; ++_i5) {
                    this.children[_i5].Update(dt);
                }

                for (var _i6 = 0; _i6 < this.effectChildren.length; ++_i6) {
                    this.effectChildren[_i6].Update(dt, this.transform);
                }

                for (var _i7 = 0; _i7 < this.curveSets.length; ++_i7) {
                    this.curveSets[_i7].Update(dt);
                }

                for (var _i8 = 0; _i8 < this.overlayEffects.length; ++_i8) {
                    this.overlayEffects[_i8].Update(dt);
                }

                for (var _i9 = 0; _i9 < this.lineSets.length; _i9++) {
                    this.lineSets[_i9].Update(dt);
                }

                this.animation.Update(dt);
            }
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (this.display) {
                var show = this.visible;

                if (show.mesh && this.mesh && this.lod > 0) {
                    this.mesh.GetBatches(mode, accumulator, this._perObjectData);
                }

                if (this.lod > 1) {
                    if (show.spriteSets) {
                        for (var i = 0; i < this.spriteSets.length; i++) {
                            this.spriteSets[i].GetBatches(mode, accumulator, this._perObjectData, this.transform);
                        }
                    }

                    if (show.spotlightSets) {
                        for (var _i10 = 0; _i10 < this.spotlightSets.length; _i10++) {
                            this.spotlightSets[_i10].GetBatches(mode, accumulator, this._perObjectData);
                        }
                    }

                    if (show.planeSets) {
                        for (var _i11 = 0; _i11 < this.planeSets.length; _i11++) {
                            this.planeSets[_i11].GetBatches(mode, accumulator, this._perObjectData);
                        }
                    }

                    if (show.decals) {
                        for (var _i12 = 0; _i12 < this.decals.length; _i12++) {
                            this.decals[_i12].GetBatches(mode, accumulator, this._perObjectData, show.killmarks ? this.killCount : 0);
                        }
                    }

                    if (show.lineSets) {
                        for (var _i13 = 0; _i13 < this.lineSets.length; _i13++) {
                            this.lineSets[_i13].GetBatches(mode, accumulator);
                        }
                    }
                }

                if (show.children) {
                    for (var _i14 = 0; _i14 < this.children.length; _i14++) {
                        this.children[_i14].GetBatches(mode, accumulator, this._perObjectData);
                    }
                }

                if (show.effectChildren) {
                    for (var _i15 = 0; _i15 < this.effectChildren.length; _i15++) {
                        this.effectChildren[_i15].GetBatches(mode, accumulator, this._perObjectData);
                    }
                }

                if (show.overlayEffects && this.mesh && this.mesh.IsGood()) {
                    for (var _i16 = 0; _i16 < this.overlayEffects.length; _i16++) {
                        this.overlayEffects[_i16].GetBatches(mode, accumulator, this._perObjectData, this.mesh);
                    }
                }
            }
        }

        /**
         * RenderDebugInfo
         * @param debugHelper
         */

    }, {
        key: 'RenderDebugInfo',
        value: function RenderDebugInfo(debugHelper) {
            this.animation.RenderDebugInfo(debugHelper);
        }
    }]);

    return EveSpaceObject;
}(_EveObject2.EveObject);

exports.EveStation = EveSpaceObject;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _EveObjectSet = __webpack_require__(10);

Object.keys(_EveObjectSet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveObjectSet[key];
    }
  });
});

var _EveBoosterSet = __webpack_require__(187);

Object.keys(_EveBoosterSet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveBoosterSet[key];
    }
  });
});

var _EveCurveLineSet = __webpack_require__(188);

Object.keys(_EveCurveLineSet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveCurveLineSet[key];
    }
  });
});

var _EveLocator = __webpack_require__(189);

Object.keys(_EveLocator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveLocator[key];
    }
  });
});

var _EvePlaneSet = __webpack_require__(190);

Object.keys(_EvePlaneSet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EvePlaneSet[key];
    }
  });
});

var _EveSpaceObjectDecal = __webpack_require__(191);

Object.keys(_EveSpaceObjectDecal).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveSpaceObjectDecal[key];
    }
  });
});

var _EveSpotlightSet = __webpack_require__(192);

Object.keys(_EveSpotlightSet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveSpotlightSet[key];
    }
  });
});

var _EveSpriteSet = __webpack_require__(193);

Object.keys(_EveSpriteSet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveSpriteSet[key];
    }
  });
});

var _EveTurretSet = __webpack_require__(194);

Object.keys(_EveTurretSet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveTurretSet[key];
    }
  });
});

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.math = undefined;

var _core = __webpack_require__(1);

Object.keys(_core).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _core[key];
        }
    });
});

var _curve = __webpack_require__(57);

Object.keys(_curve).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _curve[key];
        }
    });
});

var _eve = __webpack_require__(172);

Object.keys(_eve).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _eve[key];
        }
    });
});

var _particle = __webpack_require__(45);

Object.keys(_particle).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
            return _particle[key];
        }
    });
});

var _math = __webpack_require__(0);

var math = _interopRequireWildcard(_math);

var core = _interopRequireWildcard(_core);

var curve = _interopRequireWildcard(_curve);

var eve = _interopRequireWildcard(_eve);

var particle = _interopRequireWildcard(_particle);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.math = math;
var vec4 = math.vec4,
    mat4 = math.mat4;

/**
 * Register globals
 */

core.store.Register({

    paths: {
        'res': 'https://developers.eveonline.com/ccpwgl/assetpath/1097993/'
    },

    extensions: {
        'sm_hi': core.Tw2EffectRes,
        'sm_lo': core.Tw2EffectRes,
        'wbg': core.Tw2GeometryRes,
        'png': core.Tw2TextureRes,
        'cube': core.Tw2TextureRes,
        'mp4': core.Tw2VideoRes,
        'ogg': core.Tw2VideoRes,
        'webm': core.Tw2VideoRes
    },

    constructors: [core, curve, eve, particle],

    types: {
        'float': core.Tw2FloatParameter,
        'number': core.Tw2FloatParameter,
        'texture': core.Tw2TextureParameter,
        'vector2': core.Tw2Vector2Parameter,
        'vector3': core.Tw2Vector3Parameter,
        'vector4': core.Tw2Vector4Parameter,
        'matrix4': core.Tw2MatrixParameter
    },

    variables: {
        'WorldMat': mat4.create(),
        'ViewMat': mat4.create(),
        'ProjectionMat': mat4.create(),
        'ViewProjectionMat': mat4.create(),
        'ViewportSize': vec4.create(),
        'Time': vec4.create(),
        'u_DecalMatrix': mat4.create(),
        'u_InvDecalMatrix': mat4.create(),
        'EveSpaceSceneEnvMap': '',
        'EnvMap1': '',
        'EnvMap2': '',
        'EnvMap3': '',
        'ShadowLightness': 0,
        'OccluderValue': vec4.fromValues(1, 1, 0, 0),
        'LensflareFxOccScale': vec4.fromValues(1, 1, 0, 0),
        'LensflareFxDirectionScale': vec4.create()
    }

});

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2BatchAccumulator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Device = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Accumulates render batches for rendering
 *
 * @param {function} [sorting=null]           - An optional function for sorting the collected render batches
 * @property {Array.<Tw2RenderBatch>} batches - Accumulator render batches and/or child Tw2BatchAccumulators
 * @property {function} _sortMethod           - An optional method to sort batches before rendering them
 * @class
 */
var Tw2BatchAccumulator = exports.Tw2BatchAccumulator = function () {
    function Tw2BatchAccumulator() {
        var sorting = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        _classCallCheck(this, Tw2BatchAccumulator);

        this.batches = [];
        this._sortMethod = sorting;
    }

    /**
     * Commits a batch
     * @param {Tw2BatchAccumulator|Tw2RenderBatch} batch
     */


    _createClass(Tw2BatchAccumulator, [{
        key: 'Commit',
        value: function Commit(batch) {
            this.batches.push(batch);
        }

        /**
         * Clears any accumulated render batches
         */

    }, {
        key: 'Clear',
        value: function Clear() {
            this.batches = [];
        }

        /**
         * Renders the accumulated render batches
         * @param {string} [technique] - technique name
         */

    }, {
        key: 'Render',
        value: function Render() {
            var technique = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Main';

            if (this._sortMethod) {
                this.batches.sort(this._sortMethod);
            }

            for (var i = 0; i < this.batches.length; ++i) {
                if (this.batches[i] instanceof Tw2BatchAccumulator) {
                    this.batches[i].Render(technique);
                } else {
                    if (this.batches[i].renderMode !== _Tw2Device.device.RM_ANY) {
                        _Tw2Device.device.SetStandardStates(this.batches[i].renderMode);
                    }

                    _Tw2Device.device.perObjectData = this.batches[i].perObjectData;
                    this.batches[i].Commit(technique);
                }
            }
        }
    }]);

    return Tw2BatchAccumulator;
}();

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec2 = undefined;

var _glMatrix = __webpack_require__(11);

exports.vec2 = _glMatrix.vec2;

/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["LDU"] = LDU;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues(m00, m01, m10, m11) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    let a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function invert(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];

  // Calculate the determinant
  let det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] =  a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] =  a0 * det;

  return out;
}

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  let a0 = a[0];
  out[0] =  a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] =  a0;

  return out;
}

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function multiply(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function rotate(out, a, rad) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 *  c + a2 * s;
  out[1] = a1 *  c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
function scale(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
}

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2]/a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out;
}

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat2.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
function fromValues(a, b, c, d, tx, ty) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function invert(out, a) {
  let aa = a[0], ab = a[1], ac = a[2], ad = a[3];
  let atx = a[4], aty = a[5];

  let det = aa * ad - ab * ac;
  if(!det){
    return null;
  }
  det = 1.0 / det;

  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function multiply(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function rotate(out, a, rad) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 *  c + a2 * s;
  out[1] = a1 *  c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
function scale(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
function translate(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let v0 = v[0], v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
          a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
}

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromXRotation"] = fromXRotation;
/* harmony export (immutable) */ __webpack_exports__["fromYRotation"] = fromYRotation;
/* harmony export (immutable) */ __webpack_exports__["fromZRotation"] = fromZRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslation"] = fromRotationTranslation;
/* harmony export (immutable) */ __webpack_exports__["getTranslation"] = getTranslation;
/* harmony export (immutable) */ __webpack_exports__["getScaling"] = getScaling;
/* harmony export (immutable) */ __webpack_exports__["getRotation"] = getRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScale"] = fromRotationTranslationScale;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScaleOrigin"] = fromRotationTranslationScaleOrigin;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["frustum"] = frustum;
/* harmony export (immutable) */ __webpack_exports__["perspective"] = perspective;
/* harmony export (immutable) */ __webpack_exports__["perspectiveFromFieldOfView"] = perspectiveFromFieldOfView;
/* harmony export (immutable) */ __webpack_exports__["ortho"] = ortho;
/* harmony export (immutable) */ __webpack_exports__["lookAt"] = lookAt;
/* harmony export (immutable) */ __webpack_exports__["targetTo"] = targetTo;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 4x4 Matrix
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a03 = a[3];
    let a12 = a[6], a13 = a[7];
    let a23 = a[11];

    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
}

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
  out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
  out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
  out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
  out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
  out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
  return out;
}

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  // Cache only the current line of the second matrix
  let b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
  out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
  out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
  out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
  return out;
}

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
  let x = v[0], y = v[1], z = v[2];
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
  let x = v[0], y = v[1], z = v[2];

  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;
  let b00, b01, b02;
  let b10, b11, b12;
  let b20, b21, b22;

  if (Math.abs(len) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
  a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
  a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

  // Construct the elements of the rotation matrix
  b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
  b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
  b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

  // Perform rotation-specific matrix multiplication
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[0]  = a[0];
    out[1]  = a[1];
    out[2]  = a[2];
    out[3]  = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[4]  = a[4];
    out[5]  = a[5];
    out[6]  = a[6];
    out[7]  = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[8]  = a[8];
    out[9]  = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;

  if (Math.abs(len) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = 1;
  out[1]  = 0;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = 0;
  out[2]  = -s;
  out[3]  = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = s;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
}

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getScaling(out, mat) {
  let m11 = mat[0];
  let m12 = mat[1];
  let m13 = mat[2];
  let m21 = mat[4];
  let m22 = mat[5];
  let m23 = mat[6];
  let m31 = mat[8];
  let m32 = mat[9];
  let m33 = mat[10];

  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
}

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  let trace = mat[0] + mat[5] + mat[10];
  let S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;
  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  let ox = o[0];
  let oy = o[1];
  let oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
}

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;

  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;

  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;

  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;

  return out;
}

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
  let rl = 1 / (right - left);
  let tb = 1 / (top - bottom);
  let nf = 1 / (near - far);
  out[0] = (near * 2) * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = (near * 2) * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = (far * near * 2) * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
  let f = 1.0 / Math.tan(fovy / 2);
  let nf = 1 / (near - far);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = (2 * far * near) * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
  let upTan = Math.tan(fov.upDegrees * Math.PI/180.0);
  let downTan = Math.tan(fov.downDegrees * Math.PI/180.0);
  let leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0);
  let rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0);
  let xScale = 2.0 / (leftTan + rightTan);
  let yScale = 2.0 / (upTan + downTan);

  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = ((upTan - downTan) * yScale * 0.5);
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = (far * near) / (near - far);
  out[15] = 0.0;
  return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
  let lr = 1 / (left - right);
  let bt = 1 / (bottom - top);
  let nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  let eyex = eye[0];
  let eyey = eye[1];
  let eyez = eye[2];
  let upx = up[0];
  let upy = up[1];
  let upz = up[2];
  let centerx = center[0];
  let centery = center[1];
  let centerz = center[2];

  if (Math.abs(eyex - centerx) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"] &&
      Math.abs(eyey - centery) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"] &&
      Math.abs(eyez - centerz) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) {
    return mat4.identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;

  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;

  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;

  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;

  return out;
}

/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function targetTo(out, eye, target, up) {
  let eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];

  let z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];

  let len = z0*z0 + z1*z1 + z2*z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  let x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
          a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
          a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
          a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
}

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  out[9] = a[9] + (b[9] * scale);
  out[10] = a[10] + (b[10] * scale);
  out[11] = a[11] + (b[11] * scale);
  out[12] = a[12] + (b[12] * scale);
  out[13] = a[13] + (b[13] * scale);
  out[14] = a[14] + (b[14] * scale);
  out[15] = a[15] + (b[15] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] &&
         a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] &&
         a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
         a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3];
  let a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7];
  let a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11];
  let a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

  let b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3];
  let b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7];
  let b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11];
  let b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
          Math.abs(a9 - b9) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
          Math.abs(a10 - b10) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
          Math.abs(a11 - b11) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
          Math.abs(a12 - b12) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
          Math.abs(a13 - b13) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
          Math.abs(a14 - b14) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
          Math.abs(a15 - b15) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
}

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat4.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["setAxisAngle"] = setAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["getAxisAngle"] = getAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["calculateW"] = calculateW;
/* harmony export (immutable) */ __webpack_exports__["slerp"] = slerp;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["conjugate"] = conjugate;
/* harmony export (immutable) */ __webpack_exports__["fromMat3"] = fromMat3;
/* harmony export (immutable) */ __webpack_exports__["fromEuler"] = fromEuler;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mat3__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__vec3__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__vec4__ = __webpack_require__(33);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */






/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  let s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
function getAxisAngle(out_axis, q) {
  let rad = Math.acos(q[3]) * 2.0;
  let s = Math.sin(rad / 2.0);
  if (s != 0.0) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
function multiply(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateX(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateY(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let by = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateZ(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bz = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
function calculateW(out, a) {
  let x = a[0], y = a[1], z = a[2];

  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  let omega, cosom, sinom, scale0, scale1;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if ( cosom < 0.0 ) {
    cosom = -cosom;
    bx = - bx;
    by = - by;
    bz = - bz;
    bw = - bw;
  }
  // calculate coefficients
  if ( (1.0 - cosom) > 0.000001 ) {
    // standard case (slerp)
    omega  = Math.acos(cosom);
    sinom  = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;

  return out;
}

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
function invert(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let dot = a0*a0 + a1*a1 + a2*a2 + a3*a3;
  let invDot = dot ? 1.0/dot : 0;

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0*invDot;
  out[1] = -a1*invDot;
  out[2] = -a2*invDot;
  out[3] = a3*invDot;
  return out;
}

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  let fTrace = m[0] + m[4] + m[8];
  let fRoot;

  if ( fTrace > 0.0 ) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0);  // 2w
    out[3] = 0.5 * fRoot;
    fRoot = 0.5/fRoot;  // 1/(4w)
    out[0] = (m[5]-m[7])*fRoot;
    out[1] = (m[6]-m[2])*fRoot;
    out[2] = (m[1]-m[3])*fRoot;
  } else {
    // |w| <= 1/2
    let i = 0;
    if ( m[4] > m[0] )
      i = 1;
    if ( m[8] > m[i*3+i] )
      i = 2;
    let j = (i+1)%3;
    let k = (i+2)%3;

    fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
    out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
    out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
  }

  return out;
}

/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */
function fromEuler(out, x, y, z) {
    let halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;

    let sx = Math.sin(x);
    let cx = Math.cos(x);
    let sy = Math.sin(y);
    let cy = Math.cos(y);
    let sz = Math.sin(z);
    let cz = Math.cos(z);

    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;

    return out;
}

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
const clone = __WEBPACK_IMPORTED_MODULE_3__vec4__["clone"];
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;


/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
const fromValues = __WEBPACK_IMPORTED_MODULE_3__vec4__["fromValues"];
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;


/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
const copy = __WEBPACK_IMPORTED_MODULE_3__vec4__["copy"];
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;


/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
const set = __WEBPACK_IMPORTED_MODULE_3__vec4__["set"];
/* harmony export (immutable) */ __webpack_exports__["set"] = set;


/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
const add = __WEBPACK_IMPORTED_MODULE_3__vec4__["add"];
/* harmony export (immutable) */ __webpack_exports__["add"] = add;


/**
 * Alias for {@link quat.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
const scale = __WEBPACK_IMPORTED_MODULE_3__vec4__["scale"];
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;


/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
const dot = __WEBPACK_IMPORTED_MODULE_3__vec4__["dot"];
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;


/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
const lerp = __WEBPACK_IMPORTED_MODULE_3__vec4__["lerp"];
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;


/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */
const length = __WEBPACK_IMPORTED_MODULE_3__vec4__["length"];
/* harmony export (immutable) */ __webpack_exports__["length"] = length;


/**
 * Alias for {@link quat.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
const squaredLength = __WEBPACK_IMPORTED_MODULE_3__vec4__["squaredLength"];
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;


/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
const normalize = __WEBPACK_IMPORTED_MODULE_3__vec4__["normalize"];
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;


/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const exactEquals = __WEBPACK_IMPORTED_MODULE_3__vec4__["exactEquals"];
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;


/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const equals = __WEBPACK_IMPORTED_MODULE_3__vec4__["equals"];
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;


/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
const rotationTo = (function() {
  let tmpvec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["create"]();
  let xUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["fromValues"](1,0,0);
  let yUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["fromValues"](0,1,0);

  return function(out, a, b) {
    let dot = __WEBPACK_IMPORTED_MODULE_2__vec3__["dot"](a, b);
    if (dot < -0.999999) {
      __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, xUnitVec3, a);
      if (__WEBPACK_IMPORTED_MODULE_2__vec3__["len"](tmpvec3) < 0.000001)
        __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, yUnitVec3, a);
      __WEBPACK_IMPORTED_MODULE_2__vec3__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
})();
/* harmony export (immutable) */ __webpack_exports__["rotationTo"] = rotationTo;


/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
const sqlerp = (function () {
  let temp1 = create();
  let temp2 = create();

  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
}());
/* harmony export (immutable) */ __webpack_exports__["sqlerp"] = sqlerp;


/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
const setAxes = (function() {
  let matr = __WEBPACK_IMPORTED_MODULE_1__mat3__["create"]();

  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];

    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];

    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];

    return normalize(out, fromMat3(out, matr));
  };
})();
/* harmony export (immutable) */ __webpack_exports__["setAxes"] = setAxes;



/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat2"] = transformMat2;
/* harmony export (immutable) */ __webpack_exports__["transformMat2d"] = transformMat2d;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(5);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function fromValues(x, y) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
};

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
};

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
function round (out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.sqrt(x*x + y*y);
};

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x*x + y*y;
};

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0],
    y = a[1];
  return Math.sqrt(x*x + y*y);
};

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength (a) {
  var x = a[0],
    y = a[1];
  return x*x + y*y;
};

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x*x + y*y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }
  return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale || 1.0;
  var r = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  let x = a[0];
  let y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1];
  let b0 = b[0], b1 = b[1];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec2.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec2.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec2.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec2.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 2;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.quat = undefined;

var _glMatrix = __webpack_require__(11);

exports.quat = _glMatrix.quat;

/**
 * QuaternionExp
 *
 * @param {quat} out
 * @param {quat|vec3} a
 * @returns {quat}
 */

_glMatrix.quat.exp = function (out, a) {
    var norm = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
    if (norm) {
        out[0] = Math.sin(norm) * a[0] / norm;
        out[1] = Math.sin(norm) * a[1] / norm;
        out[2] = Math.sin(norm) * a[2] / norm;
        out[3] = Math.cos(norm);
    } else {
        out[0] = 0.0;
        out[1] = 0.0;
        out[2] = 0.0;
        out[3] = 1.0;
    }
    return out;
};

/**
 * QuaternionLn
 *
 * @param {quat} out
 * @param {quat} q
 * @returns {quat}
 */
_glMatrix.quat.ln = function (out, q) {
    var norm = _glMatrix.quat.length(q);
    if (norm > 1.0001 || norm < 0.99999) {
        out[0] = q[0];
        out[1] = q[1];
        out[2] = q[2];
        out[3] = 0.0;
    } else {
        norm = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]);
        if (norm) {
            var theta = Math.atan2(norm, q[3]) / norm;
            out[0] = theta * q[0];
            out[1] = theta * q[1];
            out[2] = theta * q[2];
            out[3] = 0.0;
        } else {
            out[0] = 0.0;
            out[1] = 0.0;
            out[2] = 0.0;
            out[3] = 0.0;
        }
    }
    return out;
};

/**
 * QuaternionPow
 *
 * @param {quat} out
 * @param {quat} inq
 * @param {number} exponent
 * @returns {quat}
 */
_glMatrix.quat.pow = function (out, inq, exponent) {
    if (exponent === 1) {
        return _glMatrix.quat.copy(out, inq);
    }

    _glMatrix.quat.ln(out, inq);
    out[0] *= exponent;
    out[1] *= exponent;
    out[2] *= exponent;
    out[3] *= exponent;
    _glMatrix.quat.exp(out, out);
    return out;
};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mat3 = undefined;

var _glMatrix = __webpack_require__(11);

exports.mat3 = _glMatrix.mat3;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mat4 = undefined;

var _glMatrix = __webpack_require__(11);

exports.mat4 = _glMatrix.mat4;

/**
 * arcFromForward
 * @param {mat4} out
 * @param {vec3} v
 * @return {mat4} out
 */

_glMatrix.mat4.arcFromForward = function () {
    var vec3_0 = void 0;

    return function arcFromForward(out, v) {
        if (!vec3_0) vec3_0 = _glMatrix.vec3.create();

        var norm = _glMatrix.vec3.normalize(vec3_0, v);
        _glMatrix.mat4.identity(out);

        if (norm[2] < -0.99999) {
            return out;
        }

        if (norm[2] > 0.99999) {
            out[5] = -1.0;
            out[10] = -1.0;
            return out;
        }

        var h = (1 + norm[2]) / (norm[0] * norm[0] + norm[1] * norm[1]);
        out[0] = h * norm[1] * norm[1] - norm[2];
        out[1] = -h * norm[0] * norm[1];
        out[2] = norm[0];

        out[4] = out[1];
        out[5] = h * norm[0] * norm[0] - norm[2];
        out[6] = norm[1];

        out[8] = -norm[0];
        out[9] = -norm[1];
        out[10] = -norm[2];

        return out;
    };
}();

/**
 * Copies the translation component from one mat4 to another
 * @param {mat4} out
 * @param {mat4} a
 * @returns {mat4} out
 */
_glMatrix.mat4.copyTranslation = function (out, a) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    return out;
};

/**
 * Sets a mat4 from a mat4
 * @param {mat4} out
 * @param {mat3} m
 * @returns {mat4} out
 */
_glMatrix.mat4.fromMat3 = function (out, m) {
    out[0] = m[0];
    out[1] = m[1];
    out[2] = m[2];
    out[4] = m[3];
    out[5] = m[4];
    out[6] = m[5];
    out[8] = m[6];
    out[9] = m[7];
    out[10] = m[8];
    out[3] = out[7] = out[11] = out[12] = out[13] = out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis from a left handed coordinate system
 *
 * @param {mat4} out - mat4 frustum matrix will be written into
 * @param {vec3} eye - Position of the viewer
 * @param {vec3} center - Point the viewer is looking at
 * @param {vec3} up - vec3 pointing up
 * @returns {mat4} out
 */
_glMatrix.mat4.lookAtGL = function () {
    var vec3_0 = void 0,
        vec3_1 = void 0,
        vec3_2 = void 0;

    return function lookAtGL(out, eye, center, up) {
        if (!vec3_0) {
            vec3_0 = _glMatrix.vec3.create();
            vec3_1 = _glMatrix.vec3.create();
            vec3_2 = _glMatrix.vec3.create();
        }

        _glMatrix.vec3.subtract(vec3_2, eye, center);

        if (_glMatrix.vec3.squaredLength(vec3_2) === 0) {
            vec3_2[2] = 1;
        }

        _glMatrix.vec3.normalize(vec3_2, vec3_2);
        _glMatrix.vec3.cross(vec3_0, up, vec3_2);

        if (_glMatrix.vec3.squaredLength(vec3_0) === 0) {
            vec3_2[2] += 0.0001;
            _glMatrix.vec3.cross(vec3_0, up, vec3_2);
        }

        _glMatrix.vec3.normalize(vec3_0, vec3_0);
        _glMatrix.vec3.cross(vec3_1, vec3_2, vec3_0);

        out[0] = vec3_0[0];
        out[1] = vec3_0[1];
        out[2] = vec3_0[2];

        out[4] = vec3_1[0];
        out[5] = vec3_1[1];
        out[6] = vec3_1[2];

        out[8] = vec3_2[0];
        out[9] = vec3_2[1];
        out[10] = vec3_2[2];

        return out;
    };
}();

/**
 * Sets a left handed co-ordinate system perspective from a right handed co-ordinate system
 * @param {mat4} out        - receiving mat4
 * @param {number} fovY     - Vertical field of view in radians
 * @param {number} aspect   - Aspect ratio. typically viewport width/height
 * @param {number} near     - Near bound of the frustum
 * @param {number} far      - Far bound of the frustum
 * @returns {mat4} out      - receiving mat4
 */
_glMatrix.mat4.perspectiveGL = function (out, fovY, aspect, near, far) {
    var fH = Math.tan(fovY / 360 * Math.PI) * near;
    var fW = fH * aspect;
    _glMatrix.mat4.frustum(out, -fW, fW, -fH, fH, near, far);
    return out;
};

/**
 * Sets the translation component of a mat4 from a vec3
 * @param {mat4} out
 * @param {vec3} v
 * @returns {mat4} out
 */
_glMatrix.mat4.setTranslation = function (out, v) {
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    return out;
};

/**
 * Sets the translation component of a mat4 from values
 * @param {mat4} out
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @returns {mat4} out
 */
_glMatrix.mat4.setTranslationFromValues = function (out, x, y, z) {
    out[12] = x;
    out[13] = y;
    out[14] = z;
    return out;
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.noise = undefined;

var _vec = __webpack_require__(34);

var _vec2 = __webpack_require__(35);

var noise = exports.noise = {};

/**
 * Generates turbulent noise
 *
 * @param {vec4} out
 * @param {number} pos_0
 * @param {number} pos_1
 * @param {number} pos_2
 * @param {number} pos_3
 * @param {number} power
 * @returns {vec4} out
 */
noise.turbulence = function () {
    var s_noiseLookup = [],
        s_permutations = [],
        s_globalNoiseTemps = [];

    var s_initialized = false;

    /**
     * Initializes noise
     */
    function initialize() {
        for (var _i = 0; _i < 256; _i++) {
            s_noiseLookup[_i] = _vec2.vec4.fromValues(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
            s_permutations[_i] = _i;
        }

        var i = 256;
        while (--i) {
            var tmp = s_permutations[i],
                index = Math.floor(Math.random() * 256);

            s_permutations[i] = s_permutations[index];
            s_permutations[index] = tmp;
        }

        for (var _i2 = 0; _i2 < 256; _i2++) {
            s_permutations[256 + _i2] = s_permutations[_i2];
            s_noiseLookup[256 + _i2] = s_noiseLookup[_i2];
            s_noiseLookup[256 * 2 + _i2] = s_noiseLookup[_i2];
        }

        for (var _i3 = 0; _i3 < 15; ++_i3) {
            s_globalNoiseTemps[_i3] = _vec.vec3.create();
        }

        s_initialized = true;
    }

    return function turbulence(out, pos_0, pos_1, pos_2, pos_3, power) {
        if (!s_initialized) initialize();

        pos_0 += 4096;
        pos_1 += 4096;
        pos_2 += 4096;
        pos_3 += 4096;

        var a_0 = Math.floor(pos_0),
            a_1 = Math.floor(pos_1),
            a_2 = Math.floor(pos_2),
            a_3 = Math.floor(pos_3);

        var t_0 = pos_0 - a_0,
            t_1 = pos_1 - a_1,
            t_2 = pos_2 - a_2,
            t_3 = pos_3 - a_3;

        a_0 &= 255;
        a_1 &= 255;
        a_2 &= 255;
        a_3 &= 255;

        var b_0 = a_0 + 1,
            b_1 = a_1 + 1,
            b_2 = a_2 + 1,
            b_3 = a_3 + 1;

        var i = s_permutations[a_0],
            j = s_permutations[b_0];

        var b00 = s_permutations[i + a_1],
            b10 = s_permutations[j + a_1],
            b01 = s_permutations[i + b_1],
            b11 = s_permutations[j + b_1];

        var c00 = _vec.vec3.lerp(s_globalNoiseTemps[0], s_noiseLookup[b00 + a_2 + a_3], s_noiseLookup[b10 + a_2 + a_3], t_0);
        var c10 = _vec.vec3.lerp(s_globalNoiseTemps[1], s_noiseLookup[b01 + a_2 + a_3], s_noiseLookup[b11 + a_2 + a_3], t_0);
        var c01 = _vec.vec3.lerp(s_globalNoiseTemps[2], s_noiseLookup[b00 + b_2 + a_3], s_noiseLookup[b10 + b_2 + a_3], t_0);
        var c11 = _vec.vec3.lerp(s_globalNoiseTemps[3], s_noiseLookup[b00 + b_2 + a_3], s_noiseLookup[b10 + b_2 + a_3], t_0);
        var c0 = _vec.vec3.lerp(s_globalNoiseTemps[4], c00, c10, t_1);
        var c1 = _vec.vec3.lerp(s_globalNoiseTemps[5], c01, c11, t_1);
        var c = _vec.vec3.lerp(s_globalNoiseTemps[6], c0, c1, t_2);

        c00 = _vec.vec3.lerp(s_globalNoiseTemps[7], s_noiseLookup[b00 + a_2 + b_3], s_noiseLookup[b10 + a_2 + b_3], t_0);
        c10 = _vec.vec3.lerp(s_globalNoiseTemps[8], s_noiseLookup[b01 + a_2 + b_3], s_noiseLookup[b11 + a_2 + b_3], t_0);
        c01 = _vec.vec3.lerp(s_globalNoiseTemps[9], s_noiseLookup[b00 + b_2 + b_3], s_noiseLookup[b10 + b_2 + b_3], t_0);
        c11 = _vec.vec3.lerp(s_globalNoiseTemps[10], s_noiseLookup[b00 + b_2 + b_3], s_noiseLookup[b10 + b_2 + b_3], t_0);
        c0 = _vec.vec3.lerp(s_globalNoiseTemps[11], c00, c10, t_1);
        c1 = _vec.vec3.lerp(s_globalNoiseTemps[12], c01, c11, t_1);
        var d = _vec.vec3.lerp(s_globalNoiseTemps[13], c0, c1, t_2);
        var r = _vec.vec3.lerp(s_globalNoiseTemps[14], c, d, t_3);

        out[0] += r[0] * power;
        out[1] += r[1] * power;
        out[2] += r[2] * power;
        return out;
    };
}();

/**
 * Perlin_noise1
 *
 * @param {number} a
 * @returns {number}
 */
noise.perlin1 = function () {
    var p_initialized = false,
        p_B = 0x100,
        p_BM = 0xff,
        p_N = 0x1000,
        p_p = null,
        p_g1 = null;

    /**
     * Initializes Perlin Noise
     */
    function initialize() {
        p_p = new Array(p_B + p_B + 2);
        p_g1 = new Array(p_B + p_B + 2);

        var i = 0,
            j = 0,
            k = 0;

        for (i = 0; i < p_B; i++) {
            p_p[i] = i;
            p_g1[i] = Math.random() * 2 - 1;
        }

        while (--i) {
            k = p_p[i];
            p_p[i] = p_p[j = Math.floor(Math.random() * p_B)];
            p_p[j] = k;
        }

        for (i = 0; i < p_B + 2; i++) {
            p_p[p_B + i] = p_p[i];
            p_g1[p_B + i] = p_g1[i];
        }

        p_initialized = true;
    }

    return function perlin1(a) {
        if (!p_initialized) initialize();

        var t = a + p_N,
            bx0 = Math.floor(t) & p_BM,
            bx1 = bx0 + 1 & p_BM,
            rx0 = t - Math.floor(t),
            rx1 = rx0 - 1;

        var sx = rx0 * rx0 * (3.0 - 2.0 * rx0),
            u = rx0 * p_g1[p_p[bx0]],
            v = rx1 * p_g1[p_p[bx1]];

        return u + sx * (v - u);
    };
}();

/**
 * PerlinNoise1D
 *
 * @param x
 * @param alpha
 * @param beta
 * @param n
 * @returns {number}
 */
noise.perlin1D = function (x, alpha, beta, n) {
    var sum = 0,
        p = x,
        scale = 1;

    for (var i = 0; i < n; ++i) {
        sum += noise.perlin1(p) / scale;
        scale *= alpha;
        p *= beta;
    }
    return sum;
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var curve = exports.curve = {};

/**
 * Evaluates a curve
 *
 * @param {{}|Tw2GeometryCurve} curve
 * @param {Array} curve.knots
 * @param {number} curve.degree
 * @param {Array} curve.controls
 * @param {number} curve.dimension
 * @param {number} time
 * @param {*} value
 * @param {boolean} cycle
 * @param {number} duration
 */
curve.evaluate = function (curve, time, value, cycle, duration) {
    var count = curve.knots.length;
    var knot = count - 1;
    var t = 0;
    for (var i = 0; i < curve.knots.length; ++i) {
        if (curve.knots[i] > time) {
            knot = i;
            break;
        }
    }

    if (curve.degree === 0) {
        for (var _i = 0; _i < curve.dimension; ++_i) {
            value[_i] = curve.controls[knot * curve.dimension + _i];
        }
    } else if (curve.degree === 1) {
        var knot0 = cycle ? (knot + count - 1) % count : knot === 0 ? 0 : knot - 1;
        var dt = curve.knots[knot] - curve.knots[knot0];

        if (dt < 0) {
            dt += duration;
        }

        if (dt > 0) {
            t = (time - curve.knots[curve.knots.length - 1]) / dt;
        }

        for (var _i2 = 0; _i2 < curve.dimension; ++_i2) {
            value[_i2] = curve.controls[knot0 * curve.dimension + _i2] * (1 - t) + curve.controls[knot * curve.dimension + _i2] * t;
        }
    } else {
        var k_2 = cycle ? (knot + count - 2) % count : knot === 0 ? 0 : knot - 2;
        var k_1 = cycle ? (knot + count - 1) % count : knot === 0 ? 0 : knot - 1;

        var p1 = k_2 * curve.dimension;
        var p2 = k_1 * curve.dimension;
        var p3 = knot * curve.dimension;

        var ti_2 = curve.knots[k_2];
        var ti_1 = curve.knots[k_1];
        var ti = curve.knots[knot];
        var ti1 = curve.knots[(knot + 1) % count];

        if (ti_2 > ti) {
            ti += duration;
            ti1 += duration;
            time += duration;
        }

        if (ti_1 > ti) {
            ti += duration;
            ti1 += duration;
            time += duration;
        }

        if (ti1 < ti) {
            ti1 += duration;
        }

        var tmti_1 = time - ti_1;
        var tmti_2 = time - ti_2;
        var dL0 = ti - ti_1;
        var dL1_1 = ti - ti_2;
        var dL1_2 = ti1 - ti_1;

        var L0 = tmti_1 / dL0;
        var L1_1 = tmti_2 / dL1_1;
        var L1_2 = tmti_1 / dL1_2;

        var ci_2 = L1_1 + L0 - L0 * L1_1;
        var ci = L0 * L1_2;
        var ci_1 = ci_2 - ci;
        ci_2 = 1 - ci_2;

        for (var _i3 = 0; _i3 < curve.dimension; ++_i3) {
            value[_i3] = ci_2 * curve.controls[p1 + _i3] + ci_1 * curve.controls[p2 + _i3] + ci * curve.controls[p3 + _i3];
        }
    }
};

/**
 * ag_horner1
 *
 * @param P
 * @param deg
 * @param s
 * @returns {*}
 */
curve.ag_horner1 = function (P, deg, s) {
    var h = P[deg];
    while (--deg >= 0) {
        h = s * h + P[deg];
    }return h;
};

/**
 * ag_zeroin2
 *
 * @param a
 * @param b
 * @param fa
 * @param fb
 * @param tol
 * @param pars
 * @returns {*}
 */
curve.ag_zeroin2 = function (a, b, fa, fb, tol, pars) {
    var test = void 0;
    var c = void 0,
        d = void 0,
        e = void 0,
        fc = void 0,
        del = void 0,
        m = void 0,
        machtol = void 0,
        p = void 0,
        q = void 0,
        r = void 0,
        s = void 0;

    /* initialization */
    machtol = 1.192092896e-07;
    var label1 = true;

    /* start iteration */
    while (true) {
        if (label1) {
            c = a;
            fc = fa;
            d = b - a;
            e = d;
        }

        if (Math.abs(fc) < Math.abs(fb)) {
            a = b;
            b = c;
            c = a;
            fa = fb;
            fb = fc;
            fc = fa;
        }
        label1 = false;

        /* convergence test */
        del = 2.0 * machtol * Math.abs(b) + 0.5 * tol;
        m = 0.5 * (c - b);
        test = Math.abs(m) > del && fb !== 0.0;
        if (test) {
            if (Math.abs(e) < del || Math.abs(fa) <= Math.abs(fb)) {
                /* bisection */
                d = m;
                e = d;
            } else {
                s = fb / fa;
                if (a === c) {
                    /* linear interpolation */
                    p = 2.0 * m * s;
                    q = 1.0 - s;
                } else {
                    /* inverse quadratic interpolation */
                    q = fa / fc;
                    r = fb / fc;
                    p = s * (2.0 * m * q * (q - r) - (b - a) * (r - 1.0));
                    q = (q - 1.0) * (r - 1.0) * (s - 1.0);
                }
                /* adjust the sign */
                if (p > 0.0) q = -q;else p = -p;
                /* check if interpolation is acceptable */
                s = e;
                e = d;
                if (2.0 * p < 3.0 * m * q - Math.abs(del * q) && p < Math.abs(0.5 * s * q)) {
                    d = p / q;
                } else {
                    d = m;
                    e = d;
                }
            }
            /* complete step */
            a = b;
            fa = fb;
            if (Math.abs(d) > del) b += d;else if (m > 0.0) b += del;else b -= del;
            fb = curve.ag_horner1(pars.p, pars.deg, b);
            if (fb * (fc / Math.abs(fc)) > 0.0) {
                label1 = true;
            }
        } else {
            break;
        }
    }
    return b;
};

/**
 * ag_zeroin
 *
 * @param a
 * @param b
 * @param tol
 * @param pars
 * @returns {*}
 */
curve.ag_zeroin = function (a, b, tol, pars) {
    var fa = void 0,
        fb = void 0;

    fa = curve.ag_horner1(pars.p, pars.deg, a);
    if (Math.abs(fa) < 1.192092896e-07) return a;

    fb = curve.ag_horner1(pars.p, pars.deg, b);
    if (Math.abs(fb) < 1.192092896e-07) return b;

    return curve.ag_zeroin2(a, b, fa, fb, tol, pars);
};

/**
 * polyZeroes
 *
 * @param Poly
 * @param deg
 * @param a
 * @param a_closed
 * @param b
 * @param b_closed
 * @param Roots
 * @returns {*}
 */
curve.polyZeroes = function (Poly, deg, a, a_closed, b, b_closed, Roots) {
    var i = void 0,
        left_ok = void 0,
        right_ok = void 0,
        nr = void 0,
        ndr = void 0,
        skip = void 0;

    var e = void 0,
        f = void 0,
        s = void 0,
        pe = void 0,
        ps = void 0,
        tol = void 0,
        p = void 0,
        p_x = new Array(22),
        d = void 0,
        d_x = new Array(22),
        dr = void 0,
        dr_x = new Array(22);

    var ply = {
        p: [],
        deg: 0
    };

    e = pe = 0.0;
    f = 0.0;

    for (i = 0; i < deg + 1; ++i) {
        f += Math.abs(Poly[i]);
    }
    tol = (Math.abs(a) + Math.abs(b)) * (deg + 1) * 1.192092896e-07;

    /* Zero polynomial to tolerance? */
    if (f <= tol) return -1;

    p = p_x;
    d = d_x;
    dr = dr_x;
    for (i = 0; i < deg + 1; ++i) {
        p[i] = 1.0 / f * Poly[i];
    }

    /* determine true degree */
    while (Math.abs(p[deg]) < tol) {
        deg--;
    } /* Identically zero poly already caught so constant fn !== 0 */
    nr = 0;
    if (deg === 0) return nr;

    /* check for linear case */
    if (deg === 1) {
        Roots[0] = -p[0] / p[1];
        left_ok = a_closed ? a < Roots[0] + tol : a < Roots[0] - tol;
        right_ok = b_closed ? b > Roots[0] - tol : b > Roots[0] + tol;
        nr = left_ok && right_ok ? 1 : 0;
        if (nr) {
            if (a_closed && Roots[0] < a) Roots[0] = a;else if (b_closed && Roots[0] > b) Roots[0] = b;
        }
        return nr;
    }
    /* handle non-linear case */
    else {
            ply.p = p;
            ply.deg = deg;

            /* compute derivative */
            for (i = 1; i <= deg; i++) {
                d[i - 1] = i * p[i];
            } /* find roots of derivative */
            ndr = curve.polyZeroes(d, deg - 1, a, 0, b, 0, dr);
            if (ndr.length === 0) return 0;

            /* find roots between roots of the derivative */
            for (i = skip = 0; i <= ndr; i++) {
                if (nr > deg) return nr;
                if (i === 0) {
                    s = a;
                    ps = curve.ag_horner1(p, deg, s);
                    if (Math.abs(ps) <= tol && a_closed) Roots[nr++] = a;
                } else {
                    s = e;
                    ps = pe;
                }
                if (i === ndr) {
                    e = b;
                    skip = 0;
                } else e = dr[i];
                pe = curve.ag_horner1(p, deg, e);
                if (skip) skip = 0;else {
                    if (Math.abs(pe) < tol) {
                        if (i !== ndr || b_closed) {
                            Roots[nr++] = e;
                            skip = 1;
                        }
                    } else if (ps < 0 && pe > 0 || ps > 0 && pe < 0) {
                        Roots[nr++] = curve.ag_zeroin(s, e, 0.0, ply);
                        if (nr > 1 && Roots[nr - 2] >= Roots[nr - 1] - tol) {
                            Roots[nr - 2] = (Roots[nr - 2] + Roots[nr - 1]) * 0.5;
                            nr--;
                        }
                    }
                }
            }
        }

    return nr;
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var util = exports.util = {};

/**
 * Adds arguments to an array if they don't already exist in it
 * @param {Array} arr
 * @param args
 * @returns {boolean} true if something was added
 */
util.addToArray = function (arr) {
    var added = false;

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
    }

    for (var i = 0; i < args.length; i++) {
        if (arr.indexOf(args[i]) !== -1) {
            arr.push(args[i]);
            added = true;
        }
    }
    return added;
};

/**
 * Assigns property values if they exist in a source object
 * - Typed arrays are cloned/ copied to ensure no pass-by-reference errors
 *
 * @param {*} dest
 * @param {*} src
 * @param {string|string[]} attrs
 */
util.assignIfExists = function (dest, src, attrs) {
    if (!src) return;

    attrs = util.toArray(attrs);
    for (var i = 0; i < attrs.length; i++) {
        var attr = attrs[i];
        if (src[attr] !== undefined) {
            if (util.isTyped(dest[attr])) {
                if (dest[attr].length !== src[attr].length) {
                    dest[attr] = new dest[attr]['constructor'](src[attr]);
                } else {
                    dest[attr].set(src[attr]);
                }
            } else if (util.isTyped(src[attr])) {
                dest[attr] = new src[attr]['constructor'](src[attr]);
            } else {
                dest[attr] = src[attr];
            }
        }
    }
};

/**
 * Identifies if UUIDs should be used for ID generation
 * @type {?boolean}
 */
var USE_UUID = null;

/**
 * Generates an object id
 * @returns {number}
 * @private
 */
var _generateObjectID = function () {
    var OBJECT_COUNT = 0;
    return function _generateObjectID() {
        return OBJECT_COUNT++;
    };
}();

/**
 * Generates a UUID
 * @author Three.js
 * @returns {string}
 * @private
 */
var _generateUUID = function () {
    var lut = [];
    for (var i = 0; i < 256; i++) {
        lut[i] = (i < 16 ? '0' : '') + i.toString(16).toUpperCase();
    }

    return function _generateUUID() {
        var d0 = Math.random() * 0xffffffff | 0,
            d1 = Math.random() * 0xffffffff | 0,
            d2 = Math.random() * 0xffffffff | 0,
            d3 = Math.random() * 0xffffffff | 0;

        return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
    };
}();

/**
 * Enables UUID's for ID generation
 * @param {boolean} bool
 * @throws When generateID have already been used and trying to set a different ID type
 */
util.enableUUID = function (bool) {
    if (USE_UUID !== null && bool !== USE_UUID) {
        throw new Error('Cannot change id generation type once used');
    }
    USE_UUID = bool;
};

/**
 * Generates an id
 * - Defaults to Object IDs
 * @returns {string|number}
 */
util.generateID = function () {
    if (USE_UUID === null) USE_UUID = false;
    return USE_UUID ? _generateUUID() : _generateObjectID();
};

/**
 * Gets a source's property value if it exists else returns a default value
 * @param {*} src
 * @param {string} prop
 * @param {*} defaultValue
 * @returns {*}
 */
util.get = function (src, prop, defaultValue) {
    return src && prop in src ? src[prop] : defaultValue;
};

/**
 * Checks if a value is an array
 * @param {*} a
 * @returns {boolean}
 */
util.isArray = Array.isArray;

/**
 * Checks if a value is array like
 * @param {*} a
 * @returns {boolean}
 */
util.isArrayLike = function (a) {
    return a ? util.isArray(a) || util.isTyped(a) : false;
};

/**
 * Checks if a value is a vector
 * @param {*} a
 * @returns {boolean}
 */
util.isVector = function (a) {
    if (a) {
        if (util.isTyped(a)) {
            return true;
        }

        if (util.isArray(a)) {
            for (var i = 0; i < a.length; i++) {
                if (typeof a[i] !== 'number') return false;
            }
            return true;
        }
    }
    return false;
};

/**
 * Checks if a value is a typed array
 * @param {*} a
 * @returns {boolean}
 */
util.isTyped = function (a) {
    return a ? !!(a.buffer instanceof ArrayBuffer && a.BYTES_PER_ELEMENT) : false;
};

/**
 * Calls a function with arguments for each child in an array where that function exists
 * @param {Array} arr
 * @param {string} func
 * @param args
 */
util.perArrayChild = function (arr, func) {
    var len = arr.length;

    for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
    }

    for (var i = 0; i < len; i++) {
        var _arr$i;

        if (func in arr) (_arr$i = arr[i])[func].apply(_arr$i, args);
    }
};

/**
 * Removes arguments from an array if they exist in it
 * @param {Array} arr
 * @param args
 * @returns {boolean} true if something was removed
 */
util.removeFromArray = function (arr) {
    var removed = false;

    for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
    }

    for (var i = 0; i < args.length; i++) {
        var index = arr.indexOf(args[i]);
        if (index !== -1) {
            arr.splice(index, 1);
            removed = true;
        }
    }
    return removed;
};

/**
 * Returns a value if it is an array, or a new array with the object in it
 * @param {*} a
 * @returns {Array}
 */
util.toArray = function (a) {
    return Array.isArray(a) ? a : [a];
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2MotherLode = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Logger = __webpack_require__(4);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Manages loaded resources
 * 
 * @property {Object} _loadedObjects            - loaded resources
 * @property {{string:Array<eventLog>}} _errors - Not implemented yet
 * @class
 */
var Tw2MotherLode = exports.Tw2MotherLode = function () {
    function Tw2MotherLode() {
        _classCallCheck(this, Tw2MotherLode);

        this._loadedObjects = {};
        this._errors = {};
    }

    /**
     * Adds an error log for a given path
     * @param {string} path
     * @param {eventLog} log
     */


    _createClass(Tw2MotherLode, [{
        key: 'AddError',
        value: function AddError(path, log) {
            this._errors[path] = this._errors[path] || [];
            if (!this._errors[path].includes(log)) {
                this._errors[path].push(log);
            }
        }

        /**
         * Gets a path's error logs
         * @param {string} path
         * @returns {?Array<eventLog>}
         */

    }, {
        key: 'GetErrors',
        value: function GetErrors(path) {
            return path && path in this._errors ? Object.assign([], this._errors[path]) : null;
        }

        /**
         * Finds a loaded object by it's file path
         * @param {string} path
         * @returns {Tw2LoadingObject}
         */

    }, {
        key: 'Find',
        value: function Find(path) {
            if (path in this._loadedObjects) {
                return this._loadedObjects[path];
            }
            return null;
        }

        /**
         * Adds a loaded object
         * @param {string} path
         * @param {Tw2LoadingObject} obj
         */

    }, {
        key: 'Add',
        value: function Add(path, obj) {
            this._loadedObjects[path] = obj;
        }

        /**
         * Removes a loaded object by it's file path
         * @param {string} path
         */

    }, {
        key: 'Remove',
        value: function Remove(path) {
            delete this._loadedObjects[path];
        }

        /**
         * Clears the loaded object object
         */

    }, {
        key: 'Clear',
        value: function Clear() {
            this._loadedObjects = {};
        }

        /**
         * Unloads all loaded objects and then clears the loadedObject object
         */

    }, {
        key: 'UnloadAndClear',
        value: function UnloadAndClear() {
            for (var path in this._loadedObjects) {
                if (this._loadedObjects.hasOwnProperty(path)) {
                    this._loadedObjects[path].Unload();
                }
            }
            this._loadedObjects = {};
        }

        /**
         * Purges inactive loaded objects (resources that have been loaded but are not being actively used)
         * - Loaded objects can flagged with `doNotPurge` to ensure they are never removed
         * - Resource auto purging can be managed in `ccpwgl` or `ccpwgl_int.resMan` - {@link Tw2ResMan}
         *     ccpwgl.setResourceUnloadPolicy()
         *     ccpwgl_int.resMan.autoPurgeResources=true
         *     ccpwgl_int.resMan.purgeTime=30
         * @param {Number} curFrame - the current frame count
         * @param {Number} frameLimit - how many frames the object can stay alive for before being purged
         * @param {Number} frameDistance - how long the resource has been alive for
         */

    }, {
        key: 'PurgeInactive',
        value: function PurgeInactive(curFrame, frameLimit, frameDistance) {
            for (var path in this._loadedObjects) {
                if (this._loadedObjects.hasOwnProperty(path)) {
                    var res = this._loadedObjects[path];
                    if (!res.doNotPurge) {
                        if (res._isPurged) {
                            _Tw2Logger.logger.log('res.event', {
                                msg: 'Unloaded  ',
                                path: res.path,
                                type: 'purged'
                            });

                            delete this._loadedObjects[path];
                        }
                        if (res._isGood && (curFrame - res.activeFrame) % frameLimit >= frameDistance) {
                            if (res.Unload()) {
                                _Tw2Logger.logger.log('res.event', {
                                    msg: 'Unloaded  ',
                                    path: res.path,
                                    type: 'unused'
                                });
                                delete this._loadedObjects[path];
                            }
                        }
                    }
                }
            }
        }
    }]);

    return Tw2MotherLode;
}();

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2SamplerOverride = undefined;

var _Tw2Device = __webpack_require__(2);

var _Tw2SamplerState = __webpack_require__(42);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2SamplerOverride
 *
 * @property {number} addressU
 * @property {number} addressV
 * @property {number} addressW
 * @property {number} filter
 * @property {number} mipFilter
 * @property {number} lodBias
 * @property {number} maxMipLevel
 * @property {number} maxAnisotropy
 * @class
 */
var Tw2SamplerOverride = exports.Tw2SamplerOverride = function Tw2SamplerOverride() {
    _classCallCheck(this, Tw2SamplerOverride);

    this.name = '';
    this.addressU = 0;
    this.addressV = 0;
    this.addressW = 0;
    this.filter = 0;
    this.mipFilter = 0;
    this.lodBias = 0;
    this.maxMipLevel = 0;
    this.maxAnisotropy = 0;

    var sampler = null;

    /**
     * Gets the sampler
     * @param originalSampler
     * @returns {Tw2SamplerState}
     */
    this.GetSampler = function (originalSampler) {
        if (!sampler) {
            sampler = new _Tw2SamplerState.Tw2SamplerState();
            sampler.registerIndex = originalSampler.registerIndex;
            sampler.name = originalSampler.name;

            if (this.filter === 1) {
                switch (this.mipFilter) {
                    case 0:
                        sampler.minFilter = _Tw2Device.device.gl.NEAREST;
                        break;

                    case 1:
                        sampler.minFilter = _Tw2Device.device.gl.NEAREST_MIPMAP_NEAREST;
                        break;

                    default:
                        sampler.minFilter = _Tw2Device.device.gl.NEAREST_MIPMAP_LINEAR;
                }

                sampler.minFilterNoMips = _Tw2Device.device.gl.NEAREST;
            } else {
                switch (this.mipFilter) {
                    case 0:
                        sampler.minFilter = _Tw2Device.device.gl.LINEAR;
                        break;

                    case 1:
                        sampler.minFilter = _Tw2Device.device.gl.LINEAR_MIPMAP_NEAREST;
                        break;

                    default:
                        sampler.minFilter = _Tw2Device.device.gl.LINEAR_MIPMAP_LINEAR;
                }

                sampler.minFilterNoMips = _Tw2Device.device.gl.LINEAR;
            }

            if (this.filter === 3 || this.mipFilter === 3) {
                sampler.anisotropy = Math.max(this.maxAnisotropy, 1);
            }

            sampler.magFilter = this.filter === 1 ? _Tw2Device.device.gl.NEAREST : _Tw2Device.device.gl.LINEAR;
            sampler.addressU = _Tw2Device.device.wrapModes[this.addressU];
            sampler.addressV = _Tw2Device.device.wrapModes[this.addressV];
            sampler.addressW = _Tw2Device.device.wrapModes[this.addressW];
            sampler.samplerType = originalSampler.samplerType;
            sampler.isVolume = originalSampler.isVolume;
            sampler.ComputeHash();
        }

        return sampler;
    };
};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2VertexDeclaration = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Device = __webpack_require__(2);

var _Tw2VertexElement = __webpack_require__(43);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2VertexDeclaration
 *
 * @param {Array<Array|Object>} [declarations]
 * @param {number} [stride]
 * @property {Array.<Tw2VertexElement>} elements
 * @property {Array.<Tw2VertexElement>} _elementsSorted
 * @class
 */
var Tw2VertexDeclaration = exports.Tw2VertexDeclaration = function () {
    function Tw2VertexDeclaration(declarations, stride) {
        _classCallCheck(this, Tw2VertexDeclaration);

        this.elements = [];
        this._elementsSorted = [];

        if (stride !== undefined) {
            this.stride = stride;
        }

        if (declarations) {
            this.DeclareFromObject(declarations);
        }
    }

    /**
     * Re-sorts elements
     */


    _createClass(Tw2VertexDeclaration, [{
        key: 'RebuildHash',
        value: function RebuildHash() {
            this._elementsSorted = [];
            for (var i = 0; i < this.elements.length; ++i) {
                this._elementsSorted[i] = this.elements[i];
            }
            this._elementsSorted.sort(Tw2VertexDeclaration.CompareDeclarationElements);
        }

        /**
         * Finds an element by it's usage type and usage index
         * @param {number} usage
         * @param {number} usageIndex
         * @returns {Tw2VertexElement|null}
         */

    }, {
        key: 'FindUsage',
        value: function FindUsage(usage, usageIndex) {
            for (var i = 0; i < this._elementsSorted.length; ++i) {
                var e = this._elementsSorted[i];
                if (e.usage === usage) {
                    if (e.usageIndex === usageIndex) {
                        return e;
                    } else if (e.usageIndex > usageIndex) {
                        return null;
                    }
                }

                if (e.usage > usage) {
                    return null;
                }
            }
            return null;
        }

        /**
         * SetDeclaration
         * @param {Tw2VertexDeclaration} inputDecl
         * @param {number} stride
         * @returns {boolean}
         */

    }, {
        key: 'SetDeclaration',
        value: function SetDeclaration(inputDecl, stride) {
            var index = 0;
            for (var i = 0; i < inputDecl._elementsSorted.length; ++i) {
                var el = inputDecl._elementsSorted[i];
                if (el.location < 0) continue;

                while (true) {
                    if (index >= this._elementsSorted.length) {
                        _Tw2Device.device.gl.disableVertexAttribArray(el.location);
                        _Tw2Device.device.gl.vertexAttrib4f(el.location, 0, 0, 0, 0);
                        break;
                    }

                    var input = this._elementsSorted[index],
                        cmp = Tw2VertexDeclaration.CompareDeclarationElements(input, el);

                    if (cmp > 0) {
                        _Tw2Device.device.gl.disableVertexAttribArray(el.location);
                        _Tw2Device.device.gl.vertexAttrib4f(el.location, 0, 0, 0, 0);
                        break;
                    }

                    if (cmp === 0) {
                        if (input.customSetter) {
                            input.customSetter(el);
                        } else {
                            _Tw2Device.device.gl.enableVertexAttribArray(el.location);
                            _Tw2Device.device.gl.vertexAttribPointer(el.location, input.elements, input.type, false, stride, input.offset);
                        }
                        break;
                    }
                    index++;
                }
            }
            return true;
        }

        /**
         * SetPartialDeclaration
         * @param {Tw2VertexDeclaration} inputDecl
         * @param {number} stride
         * @param {number} [usageOffset=0]
         * @param {number} [divisor=0]
         * @returns {Array} ResetData
         */

    }, {
        key: 'SetPartialDeclaration',
        value: function SetPartialDeclaration(inputDecl, stride) {
            var usageOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var divisor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

            var resetData = [];

            var index = 0;
            for (var i = 0; i < inputDecl._elementsSorted.length; ++i) {
                var el = inputDecl._elementsSorted[i];
                if (el.location < 0) continue;

                while (true) {
                    var input = this._elementsSorted[index],
                        cmp = Tw2VertexDeclaration.CompareDeclarationElements(input, el, usageOffset);

                    if (cmp === 0) {
                        if (input.customSetter) {
                            input.customSetter(el);
                        } else {
                            _Tw2Device.device.gl.enableVertexAttribArray(el.location);
                            _Tw2Device.device.gl.vertexAttribPointer(el.location, input.elements, input.type, false, stride, input.offset);
                            _Tw2Device.device.ext.vertexAttribDivisor(el.location, divisor);

                            if (divisor) {
                                resetData.push(el.location);
                            }
                        }
                        break;
                    } else if (cmp > 0) {
                        if (!divisor) {
                            _Tw2Device.device.gl.disableVertexAttribArray(el.location);
                            _Tw2Device.device.gl.vertexAttrib4f(el.location, 0, 0, 0, 0);
                        }
                        break;
                    }

                    index++;
                    if (index >= this._elementsSorted.length) {
                        if (!divisor) {
                            _Tw2Device.device.gl.disableVertexAttribArray(el.location);
                            _Tw2Device.device.gl.vertexAttrib4f(el.location, 0, 0, 0, 0);
                        }
                        return resetData;
                    }
                }
            }
            return resetData;
        }

        /**
         * ResetInstanceDivisors
         * @param {Array} resetData
         */

    }, {
        key: 'ResetInstanceDivisors',
        value: function ResetInstanceDivisors(resetData) {
            if (resetData) {
                for (var i = 0; i < resetData.length; ++i) {
                    _Tw2Device.device.ext.vertexAttribDivisor(resetData[i], 0);
                }
            }
        }

        /**
         * Sets vertex declarations from an array of arrays, or an array of objects
         * @param {Array<Array>|Array<Object>} declarations
         */

    }, {
        key: 'DeclareFromObject',
        value: function DeclareFromObject(declarations) {
            this.elements.splice(0, this.elements.length);
            var currentOffset = 0;

            for (var i = 0; i < declarations.length; i++) {
                var decl = declarations[i];
                var usage = void 0,
                    usageIndex = void 0,
                    type = void 0,
                    elements = void 0,
                    offset = void 0;

                if (Array.isArray(decl)) {
                    usage = decl[0];
                    usageIndex = decl[1];
                    type = decl[2];
                    elements = decl[3];
                    offset = decl[4];
                } else {
                    usage = decl.usage;
                    usageIndex = decl.usageIndex;
                    type = decl.type;
                    elements = decl.elements;
                    offset = decl.offset;
                }

                if (typeof usage === 'string') {
                    usage = Tw2VertexDeclaration.Type[usage.toUpperCase()];
                }

                if (typeof type === 'string') {
                    type = _Tw2Device.device.gl[type.toUpperCase()];
                }

                if (offset === undefined) {
                    offset = currentOffset;
                }

                this.elements.push(new _Tw2VertexElement.Tw2VertexElement(usage, usageIndex, type, elements, offset));
                currentOffset += elements * 4;
            }

            this.RebuildHash();
        }

        /**
         * CompareDeclarationElements
         * @param {Tw2VertexElement} a
         * @param {Tw2VertexElement} b
         * @param {number} [usageOffset=0]
         * @returns {number}
         * @function
         */

    }], [{
        key: 'CompareDeclarationElements',
        value: function CompareDeclarationElements(a, b) {
            var usageOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

            if (a.usage < b.usage) return -1;
            if (a.usage > b.usage) return 1;
            if (a.usageIndex + usageOffset < b.usageIndex) return -1;
            if (a.usageIndex + usageOffset > b.usageIndex) return 1;
            return 0;
        }
    }]);

    return Tw2VertexDeclaration;
}();

/**
 * Tw2 Vertex Declaration Types
 * @type {number}
 */


Tw2VertexDeclaration.Type = {
    POSITION: 0,
    COLOR: 1,
    NORMAL: 2,
    TANGENT: 3,
    BINORMAL: 4,
    TEXCOORD: 5,
    BLENDWEIGHT: 6,
    BLENDINDICES: 7
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*
** Copyright (c) 2012 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

//Ported to node by Marcin Ignac on 2016-05-20

// Various functions for helping debug WebGL apps.

var WebGLDebugUtils = function() {
var window

//polyfill window in node
if (typeof(window) == 'undefined') {
    window = global;
}

/**
 * Wrapped logging function.
 * @param {string} msg Message to log.
 */
var log = function(msg) {
  if (window.console && window.console.log) {
    window.console.log(msg);
  }
};

/**
 * Wrapped error logging function.
 * @param {string} msg Message to log.
 */
var error = function(msg) {
  if (window.console && window.console.error) {
    window.console.error(msg);
  } else {
    log(msg);
  }
};


/**
 * Which arguments are enums based on the number of arguments to the function.
 * So
 *    'texImage2D': {
 *       9: { 0:true, 2:true, 6:true, 7:true },
 *       6: { 0:true, 2:true, 3:true, 4:true },
 *    },
 *
 * means if there are 9 arguments then 6 and 7 are enums, if there are 6
 * arguments 3 and 4 are enums
 *
 * @type {!Object.<number, !Object.<number, string>}
 */
var glValidEnumContexts = {
  // Generic setters and getters

  'enable': {1: { 0:true }},
  'disable': {1: { 0:true }},
  'getParameter': {1: { 0:true }},

  // Rendering

  'drawArrays': {3:{ 0:true }},
  'drawElements': {4:{ 0:true, 2:true }},

  // Shaders

  'createShader': {1: { 0:true }},
  'getShaderParameter': {2: { 1:true }},
  'getProgramParameter': {2: { 1:true }},
  'getShaderPrecisionFormat': {2: { 0: true, 1:true }},

  // Vertex attributes

  'getVertexAttrib': {2: { 1:true }},
  'vertexAttribPointer': {6: { 2:true }},

  // Textures

  'bindTexture': {2: { 0:true }},
  'activeTexture': {1: { 0:true }},
  'getTexParameter': {2: { 0:true, 1:true }},
  'texParameterf': {3: { 0:true, 1:true }},
  'texParameteri': {3: { 0:true, 1:true, 2:true }},
  // texImage2D and texSubImage2D are defined below with WebGL 2 entrypoints
  'copyTexImage2D': {8: { 0:true, 2:true }},
  'copyTexSubImage2D': {8: { 0:true }},
  'generateMipmap': {1: { 0:true }},
  // compressedTexImage2D and compressedTexSubImage2D are defined below with WebGL 2 entrypoints

  // Buffer objects

  'bindBuffer': {2: { 0:true }},
  // bufferData and bufferSubData are defined below with WebGL 2 entrypoints
  'getBufferParameter': {2: { 0:true, 1:true }},

  // Renderbuffers and framebuffers

  'pixelStorei': {2: { 0:true, 1:true }},
  // readPixels is defined below with WebGL 2 entrypoints
  'bindRenderbuffer': {2: { 0:true }},
  'bindFramebuffer': {2: { 0:true }},
  'checkFramebufferStatus': {1: { 0:true }},
  'framebufferRenderbuffer': {4: { 0:true, 1:true, 2:true }},
  'framebufferTexture2D': {5: { 0:true, 1:true, 2:true }},
  'getFramebufferAttachmentParameter': {3: { 0:true, 1:true, 2:true }},
  'getRenderbufferParameter': {2: { 0:true, 1:true }},
  'renderbufferStorage': {4: { 0:true, 1:true }},

  // Frame buffer operations (clear, blend, depth test, stencil)

  'clear': {1: { 0: { 'enumBitwiseOr': ['COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT'] }}},
  'depthFunc': {1: { 0:true }},
  'blendFunc': {2: { 0:true, 1:true }},
  'blendFuncSeparate': {4: { 0:true, 1:true, 2:true, 3:true }},
  'blendEquation': {1: { 0:true }},
  'blendEquationSeparate': {2: { 0:true, 1:true }},
  'stencilFunc': {3: { 0:true }},
  'stencilFuncSeparate': {4: { 0:true, 1:true }},
  'stencilMaskSeparate': {2: { 0:true }},
  'stencilOp': {3: { 0:true, 1:true, 2:true }},
  'stencilOpSeparate': {4: { 0:true, 1:true, 2:true, 3:true }},

  // Culling

  'cullFace': {1: { 0:true }},
  'frontFace': {1: { 0:true }},

  // ANGLE_instanced_arrays extension

  'drawArraysInstancedANGLE': {4: { 0:true }},
  'drawElementsInstancedANGLE': {5: { 0:true, 2:true }},

  // EXT_blend_minmax extension

  'blendEquationEXT': {1: { 0:true }},

  // WebGL 2 Buffer objects

  'bufferData': {
    3: { 0:true, 2:true }, // WebGL 1
    4: { 0:true, 2:true }, // WebGL 2
    5: { 0:true, 2:true }  // WebGL 2
  },
  'bufferSubData': {
    3: { 0:true }, // WebGL 1
    4: { 0:true }, // WebGL 2
    5: { 0:true }  // WebGL 2
  },
  'copyBufferSubData': {5: { 0:true, 1:true }},
  'getBufferSubData': {3: { 0:true }, 4: { 0:true }, 5: { 0:true }},

  // WebGL 2 Framebuffer objects

  'blitFramebuffer': {10: { 8: { 'enumBitwiseOr': ['COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT'] }, 9:true }},
  'framebufferTextureLayer': {5: { 0:true, 1:true }},
  'invalidateFramebuffer': {2: { 0:true }},
  'invalidateSubFramebuffer': {6: { 0:true }},
  'readBuffer': {1: { 0:true }},

  // WebGL 2 Renderbuffer objects

  'getInternalformatParameter': {3: { 0:true, 1:true, 2:true }},
  'renderbufferStorageMultisample': {5: { 0:true, 2:true }},

  // WebGL 2 Texture objects

  'texStorage2D': {5: { 0:true, 2:true }},
  'texStorage3D': {6: { 0:true, 2:true }},
  'texImage2D': {
    9: { 0:true, 2:true, 6:true, 7:true }, // WebGL 1 & 2
    6: { 0:true, 2:true, 3:true, 4:true }, // WebGL 1
    10: { 0:true, 2:true, 6:true, 7:true } // WebGL 2
  },
  'texImage3D': {
    10: { 0:true, 2:true, 7:true, 8:true },
    11: { 0:true, 2:true, 7:true, 8:true }
  },
  'texSubImage2D': {
    9: { 0:true, 6:true, 7:true }, // WebGL 1 & 2
    7: { 0:true, 4:true, 5:true }, // WebGL 1
    10: { 0:true, 6:true, 7:true } // WebGL 2
  },
  'texSubImage3D': {
    11: { 0:true, 8:true, 9:true },
    12: { 0:true, 8:true, 9:true }
  },
  'copyTexSubImage3D': {9: { 0:true }},
  'compressedTexImage2D': {
    7: { 0: true, 2:true }, // WebGL 1 & 2
    8: { 0: true, 2:true }, // WebGL 2
    9: { 0: true, 2:true }  // WebGL 2
  },
  'compressedTexImage3D': {
    8: { 0: true, 2:true },
    9: { 0: true, 2:true },
    10: { 0: true, 2:true }
  },
  'compressedTexSubImage2D': {
    8: { 0: true, 6:true }, // WebGL 1 & 2
    9: { 0: true, 6:true }, // WebGL 2
    10: { 0: true, 6:true } // WebGL 2
  },
  'compressedTexSubImage3D': {
    10: { 0: true, 8:true },
    11: { 0: true, 8:true },
    12: { 0: true, 8:true }
  },

  // WebGL 2 Vertex attribs

  'vertexAttribIPointer': {5: { 2:true }},

  // WebGL 2 Writing to the drawing buffer

  'drawArraysInstanced': {4: { 0:true }},
  'drawElementsInstanced': {5: { 0:true, 2:true }},
  'drawRangeElements': {6: { 0:true, 4:true }},

  // WebGL 2 Reading back pixels

  'readPixels': {
    7: { 4:true, 5:true }, // WebGL 1 & 2
    8: { 4:true, 5:true }  // WebGL 2
  },

  // WebGL 2 Multiple Render Targets

  'clearBufferfv': {3: { 0:true }, 4: { 0:true }},
  'clearBufferiv': {3: { 0:true }, 4: { 0:true }},
  'clearBufferuiv': {3: { 0:true }, 4: { 0:true }},
  'clearBufferfi': {4: { 0:true }},

  // WebGL 2 Query objects

  'beginQuery': {2: { 0:true }},
  'endQuery': {1: { 0:true }},
  'getQuery': {2: { 0:true, 1:true }},
  'getQueryParameter': {2: { 1:true }},

  // WebGL 2 Sampler objects

  'samplerParameteri': {3: { 1:true, 2:true }},
  'samplerParameterf': {3: { 1:true }},
  'getSamplerParameter': {2: { 1:true }},

  // WebGL 2 Sync objects

  'fenceSync': {2: { 0:true, 1: { 'enumBitwiseOr': [] } }},
  'clientWaitSync': {3: { 1: { 'enumBitwiseOr': ['SYNC_FLUSH_COMMANDS_BIT'] } }},
  'waitSync': {3: { 1: { 'enumBitwiseOr': [] } }},
  'getSyncParameter': {2: { 1:true }},

  // WebGL 2 Transform Feedback

  'bindTransformFeedback': {2: { 0:true }},
  'beginTransformFeedback': {1: { 0:true }},
  'transformFeedbackVaryings': {3: { 2:true }},

  // WebGL2 Uniform Buffer Objects and Transform Feedback Buffers

  'bindBufferBase': {3: { 0:true }},
  'bindBufferRange': {5: { 0:true }},
  'getIndexedParameter': {2: { 0:true }},
  'getActiveUniforms': {3: { 2:true }},
  'getActiveUniformBlockParameter': {3: { 2:true }}
};

/**
 * Map of numbers to names.
 * @type {Object}
 */
var glEnums = null;

/**
 * Map of names to numbers.
 * @type {Object}
 */
var enumStringToValue = null;

/**
 * Initializes this module. Safe to call more than once.
 * @param {!WebGLRenderingContext} ctx A WebGL context. If
 *    you have more than one context it doesn't matter which one
 *    you pass in, it is only used to pull out constants.
 */
function init(ctx) {
  if (glEnums == null) {
    glEnums = { };
    enumStringToValue = { };
    for (var propertyName in ctx) {
      if (typeof ctx[propertyName] == 'number') {
        glEnums[ctx[propertyName]] = propertyName;
        enumStringToValue[propertyName] = ctx[propertyName];
      }
    }
  }
}

/**
 * Checks the utils have been initialized.
 */
function checkInit() {
  if (glEnums == null) {
    throw 'WebGLDebugUtils.init(ctx) not called';
  }
}

/**
 * Returns true or false if value matches any WebGL enum
 * @param {*} value Value to check if it might be an enum.
 * @return {boolean} True if value matches one of the WebGL defined enums
 */
function mightBeEnum(value) {
  checkInit();
  return (glEnums[value] !== undefined);
}

/**
 * Gets an string version of an WebGL enum.
 *
 * Example:
 *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
 *
 * @param {number} value Value to return an enum for
 * @return {string} The string version of the enum.
 */
function glEnumToString(value) {
  checkInit();
  var name = glEnums[value];
  return (name !== undefined) ? ("gl." + name) :
      ("/*UNKNOWN WebGL ENUM*/ 0x" + value.toString(16) + "");
}

/**
 * Returns the string version of a WebGL argument.
 * Attempts to convert enum arguments to strings.
 * @param {string} functionName the name of the WebGL function.
 * @param {number} numArgs the number of arguments passed to the function.
 * @param {number} argumentIndx the index of the argument.
 * @param {*} value The value of the argument.
 * @return {string} The value as a string.
 */
function glFunctionArgToString(functionName, numArgs, argumentIndex, value) {
  var funcInfo = glValidEnumContexts[functionName];
  if (funcInfo !== undefined) {
    var funcInfo = funcInfo[numArgs];
    if (funcInfo !== undefined) {
      if (funcInfo[argumentIndex]) {
        if (typeof funcInfo[argumentIndex] === 'object' &&
            funcInfo[argumentIndex]['enumBitwiseOr'] !== undefined) {
          var enums = funcInfo[argumentIndex]['enumBitwiseOr'];
          var orResult = 0;
          var orEnums = [];
          for (var i = 0; i < enums.length; ++i) {
            var enumValue = enumStringToValue[enums[i]];
            if ((value & enumValue) !== 0) {
              orResult |= enumValue;
              orEnums.push(glEnumToString(enumValue));
            }
          }
          if (orResult === value) {
            return orEnums.join(' | ');
          } else {
            return glEnumToString(value);
          }
        } else {
          return glEnumToString(value);
        }
      }
    }
  }
  if (value === null) {
    return "null";
  } else if (value === undefined) {
    return "undefined";
  } else {
    return value.toString();
  }
}

/**
 * Converts the arguments of a WebGL function to a string.
 * Attempts to convert enum arguments to strings.
 *
 * @param {string} functionName the name of the WebGL function.
 * @param {number} args The arguments.
 * @return {string} The arguments as a string.
 */
function glFunctionArgsToString(functionName, args) {
  // apparently we can't do args.join(",");
  var argStr = "";
  var numArgs = args.length;
  for (var ii = 0; ii < numArgs; ++ii) {
    argStr += ((ii == 0) ? '' : ', ') +
        glFunctionArgToString(functionName, numArgs, ii, args[ii]);
  }
  return argStr;
};


function makePropertyWrapper(wrapper, original, propertyName) {
  //log("wrap prop: " + propertyName);
  wrapper.__defineGetter__(propertyName, function() {
    return original[propertyName];
  });
  // TODO(gmane): this needs to handle properties that take more than
  // one value?
  wrapper.__defineSetter__(propertyName, function(value) {
    //log("set: " + propertyName);
    original[propertyName] = value;
  });
}

// Makes a function that calls a function on another object.
function makeFunctionWrapper(original, functionName) {
  //log("wrap fn: " + functionName);
  var f = original[functionName];
  return function() {
    //log("call: " + functionName);
    var result = f.apply(original, arguments);
    return result;
  };
}

/**
 * Given a WebGL context returns a wrapped context that calls
 * gl.getError after every command and calls a function if the
 * result is not gl.NO_ERROR.
 *
 * @param {!WebGLRenderingContext} ctx The webgl context to
 *        wrap.
 * @param {!function(err, funcName, args): void} opt_onErrorFunc
 *        The function to call when gl.getError returns an
 *        error. If not specified the default function calls
 *        console.log with a message.
 * @param {!function(funcName, args): void} opt_onFunc The
 *        function to call when each webgl function is called.
 *        You can use this to log all calls for example.
 * @param {!WebGLRenderingContext} opt_err_ctx The webgl context
 *        to call getError on if different than ctx.
 */
function makeDebugContext(ctx, opt_onErrorFunc, opt_onFunc, opt_err_ctx) {
  opt_err_ctx = opt_err_ctx || ctx;
  init(ctx);
  opt_onErrorFunc = opt_onErrorFunc || function(err, functionName, args) {
        // apparently we can't do args.join(",");
        var argStr = "";
        var numArgs = args.length;
        for (var ii = 0; ii < numArgs; ++ii) {
          argStr += ((ii == 0) ? '' : ', ') +
              glFunctionArgToString(functionName, numArgs, ii, args[ii]);
        }
        error("WebGL error "+ glEnumToString(err) + " in "+ functionName +
              "(" + argStr + ")");
      };

  // Holds booleans for each GL error so after we get the error ourselves
  // we can still return it to the client app.
  var glErrorShadow = { };

  // Makes a function that calls a WebGL function and then calls getError.
  function makeErrorWrapper(ctx, functionName) {
    return function() {
      if (opt_onFunc) {
        opt_onFunc(functionName, arguments);
      }
      var result = ctx[functionName].apply(ctx, arguments);
      var err = opt_err_ctx.getError();
      if (err != 0) {
        glErrorShadow[err] = true;
        opt_onErrorFunc(err, functionName, arguments);
      }
      return result;
    };
  }

  // Make a an object that has a copy of every property of the WebGL context
  // but wraps all functions.
  var wrapper = {};
  for (var propertyName in ctx) {
    if (typeof ctx[propertyName] == 'function') {
      if (propertyName != 'getExtension') {
        wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);
      } else {
        var wrapped = makeErrorWrapper(ctx, propertyName);
        wrapper[propertyName] = function () {
          var result = wrapped.apply(ctx, arguments);
          if (!result) {
            return null;
          }
          return makeDebugContext(result, opt_onErrorFunc, opt_onFunc, opt_err_ctx);
        };
      }
    } else {
      makePropertyWrapper(wrapper, ctx, propertyName);
    }
  }

  // Override the getError function with one that returns our saved results.
  wrapper.getError = function() {
    for (var err in glErrorShadow) {
      if (glErrorShadow.hasOwnProperty(err)) {
        if (glErrorShadow[err]) {
          glErrorShadow[err] = false;
          return err;
        }
      }
    }
    return ctx.NO_ERROR;
  };

  return wrapper;
}

function resetToInitialState(ctx) {
  var isWebGL2RenderingContext = !!ctx.createTransformFeedback;

  if (isWebGL2RenderingContext) {
    ctx.bindVertexArray(null);
  }

  var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
  var tmp = ctx.createBuffer();
  ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);
  for (var ii = 0; ii < numAttribs; ++ii) {
    ctx.disableVertexAttribArray(ii);
    ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);
    ctx.vertexAttrib1f(ii, 0);
    if (isWebGL2RenderingContext) {
      ctx.vertexAttribDivisor(ii, 0);
    }
  }
  ctx.deleteBuffer(tmp);

  var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
  for (var ii = 0; ii < numTextureUnits; ++ii) {
    ctx.activeTexture(ctx.TEXTURE0 + ii);
    ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);
    ctx.bindTexture(ctx.TEXTURE_2D, null);
    if (isWebGL2RenderingContext) {
      ctx.bindTexture(ctx.TEXTURE_2D_ARRAY, null);
      ctx.bindTexture(ctx.TEXTURE_3D, null);
      ctx.bindSampler(ii, null);
    }
  }

  ctx.activeTexture(ctx.TEXTURE0);
  ctx.useProgram(null);
  ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
  ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
  ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
  ctx.disable(ctx.BLEND);
  ctx.disable(ctx.CULL_FACE);
  ctx.disable(ctx.DEPTH_TEST);
  ctx.disable(ctx.DITHER);
  ctx.disable(ctx.SCISSOR_TEST);
  ctx.blendColor(0, 0, 0, 0);
  ctx.blendEquation(ctx.FUNC_ADD);
  ctx.blendFunc(ctx.ONE, ctx.ZERO);
  ctx.clearColor(0, 0, 0, 0);
  ctx.clearDepth(1);
  ctx.clearStencil(-1);
  ctx.colorMask(true, true, true, true);
  ctx.cullFace(ctx.BACK);
  ctx.depthFunc(ctx.LESS);
  ctx.depthMask(true);
  ctx.depthRange(0, 1);
  ctx.frontFace(ctx.CCW);
  ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);
  ctx.lineWidth(1);
  ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);
  ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);
  ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);
  ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
  // TODO: Delete this IF.
  if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {
    ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);
  }
  ctx.polygonOffset(0, 0);
  ctx.sampleCoverage(1, false);
  ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);
  ctx.stencilMask(0xFFFFFFFF);
  ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);
  ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);

  if (isWebGL2RenderingContext) {
    ctx.drawBuffers([ctx.BACK]);
    ctx.readBuffer(ctx.BACK);
    ctx.bindBuffer(ctx.COPY_READ_BUFFER, null);
    ctx.bindBuffer(ctx.COPY_WRITE_BUFFER, null);
    ctx.bindBuffer(ctx.PIXEL_PACK_BUFFER, null);
    ctx.bindBuffer(ctx.PIXEL_UNPACK_BUFFER, null);
    var numTransformFeedbacks = ctx.getParameter(ctx.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS);
    for (var ii = 0; ii < numTransformFeedbacks; ++ii) {
      ctx.bindBufferBase(ctx.TRANSFORM_FEEDBACK_BUFFER, ii, null);
    }
    var numUBOs = ctx.getParameter(ctx.MAX_UNIFORM_BUFFER_BINDINGS);
    for (var ii = 0; ii < numUBOs; ++ii) {
      ctx.bindBufferBase(ctx.UNIFORM_BUFFER, ii, null);
    }
    ctx.disable(ctx.RASTERIZER_DISCARD);
    ctx.pixelStorei(ctx.UNPACK_IMAGE_HEIGHT, 0);
    ctx.pixelStorei(ctx.UNPACK_SKIP_IMAGES, 0);
    ctx.pixelStorei(ctx.UNPACK_ROW_LENGTH, 0);
    ctx.pixelStorei(ctx.UNPACK_SKIP_ROWS, 0);
    ctx.pixelStorei(ctx.UNPACK_SKIP_PIXELS, 0);
    ctx.pixelStorei(ctx.PACK_ROW_LENGTH, 0);
    ctx.pixelStorei(ctx.PACK_SKIP_ROWS, 0);
    ctx.pixelStorei(ctx.PACK_SKIP_PIXELS, 0);
    ctx.hint(ctx.FRAGMENT_SHADER_DERIVATIVE_HINT, ctx.DONT_CARE);
  }

  // TODO: This should NOT be needed but Firefox fails with 'hint'
  while(ctx.getError());
}

function makeLostContextSimulatingCanvas(canvas) {
  var unwrappedContext_;
  var wrappedContext_;
  var onLost_ = [];
  var onRestored_ = [];
  var wrappedContext_ = {};
  var contextId_ = 1;
  var contextLost_ = false;
  var resourceId_ = 0;
  var resourceDb_ = [];
  var numCallsToLoseContext_ = 0;
  var numCalls_ = 0;
  var canRestore_ = false;
  var restoreTimeout_ = 0;
  var isWebGL2RenderingContext;

  // Holds booleans for each GL error so can simulate errors.
  var glErrorShadow_ = { };

  canvas.getContext = function(f) {
    return function() {
      var ctx = f.apply(canvas, arguments);
      // Did we get a context and is it a WebGL context?
      if ((ctx instanceof WebGLRenderingContext) || (window.WebGL2RenderingContext && (ctx instanceof WebGL2RenderingContext))) {
        if (ctx != unwrappedContext_) {
          if (unwrappedContext_) {
            throw "got different context"
          }
          isWebGL2RenderingContext = window.WebGL2RenderingContext && (ctx instanceof WebGL2RenderingContext);
          unwrappedContext_ = ctx;
          wrappedContext_ = makeLostContextSimulatingContext(unwrappedContext_);
        }
        return wrappedContext_;
      }
      return ctx;
    }
  }(canvas.getContext);

  function wrapEvent(listener) {
    if (typeof(listener) == "function") {
      return listener;
    } else {
      return function(info) {
        listener.handleEvent(info);
      }
    }
  }

  var addOnContextLostListener = function(listener) {
    onLost_.push(wrapEvent(listener));
  };

  var addOnContextRestoredListener = function(listener) {
    onRestored_.push(wrapEvent(listener));
  };


  function wrapAddEventListener(canvas) {
    var f = canvas.addEventListener;
    canvas.addEventListener = function(type, listener, bubble) {
      switch (type) {
        case 'webglcontextlost':
          addOnContextLostListener(listener);
          break;
        case 'webglcontextrestored':
          addOnContextRestoredListener(listener);
          break;
        default:
          f.apply(canvas, arguments);
      }
    };
  }

  wrapAddEventListener(canvas);

  canvas.loseContext = function() {
    if (!contextLost_) {
      contextLost_ = true;
      numCallsToLoseContext_ = 0;
      ++contextId_;
      while (unwrappedContext_.getError());
      clearErrors();
      glErrorShadow_[unwrappedContext_.CONTEXT_LOST_WEBGL] = true;
      var event = makeWebGLContextEvent("context lost");
      var callbacks = onLost_.slice();
      setTimeout(function() {
          //log("numCallbacks:" + callbacks.length);
          for (var ii = 0; ii < callbacks.length; ++ii) {
            //log("calling callback:" + ii);
            callbacks[ii](event);
          }
          if (restoreTimeout_ >= 0) {
            setTimeout(function() {
                canvas.restoreContext();
              }, restoreTimeout_);
          }
        }, 0);
    }
  };

  canvas.restoreContext = function() {
    if (contextLost_) {
      if (onRestored_.length) {
        setTimeout(function() {
            if (!canRestore_) {
              throw "can not restore. webglcontestlost listener did not call event.preventDefault";
            }
            freeResources();
            resetToInitialState(unwrappedContext_);
            contextLost_ = false;
            numCalls_ = 0;
            canRestore_ = false;
            var callbacks = onRestored_.slice();
            var event = makeWebGLContextEvent("context restored");
            for (var ii = 0; ii < callbacks.length; ++ii) {
              callbacks[ii](event);
            }
          }, 0);
      }
    }
  };

  canvas.loseContextInNCalls = function(numCalls) {
    if (contextLost_) {
      throw "You can not ask a lost contet to be lost";
    }
    numCallsToLoseContext_ = numCalls_ + numCalls;
  };

  canvas.getNumCalls = function() {
    return numCalls_;
  };

  canvas.setRestoreTimeout = function(timeout) {
    restoreTimeout_ = timeout;
  };

  function isWebGLObject(obj) {
    //return false;
    return (obj instanceof WebGLBuffer ||
            obj instanceof WebGLFramebuffer ||
            obj instanceof WebGLProgram ||
            obj instanceof WebGLRenderbuffer ||
            obj instanceof WebGLShader ||
            obj instanceof WebGLTexture);
  }

  function checkResources(args) {
    for (var ii = 0; ii < args.length; ++ii) {
      var arg = args[ii];
      if (isWebGLObject(arg)) {
        return arg.__webglDebugContextLostId__ == contextId_;
      }
    }
    return true;
  }

  function clearErrors() {
    var k = Object.keys(glErrorShadow_);
    for (var ii = 0; ii < k.length; ++ii) {
      delete glErrorShadow_[k[ii]];
    }
  }

  function loseContextIfTime() {
    ++numCalls_;
    if (!contextLost_) {
      if (numCallsToLoseContext_ == numCalls_) {
        canvas.loseContext();
      }
    }
  }

  // Makes a function that simulates WebGL when out of context.
  function makeLostContextFunctionWrapper(ctx, functionName) {
    var f = ctx[functionName];
    return function() {
      // log("calling:" + functionName);
      // Only call the functions if the context is not lost.
      loseContextIfTime();
      if (!contextLost_) {
        //if (!checkResources(arguments)) {
        //  glErrorShadow_[wrappedContext_.INVALID_OPERATION] = true;
        //  return;
        //}
        var result = f.apply(ctx, arguments);
        return result;
      }
    };
  }

  function freeResources() {
    for (var ii = 0; ii < resourceDb_.length; ++ii) {
      var resource = resourceDb_[ii];
      if (resource instanceof WebGLBuffer) {
        unwrappedContext_.deleteBuffer(resource);
      } else if (resource instanceof WebGLFramebuffer) {
        unwrappedContext_.deleteFramebuffer(resource);
      } else if (resource instanceof WebGLProgram) {
        unwrappedContext_.deleteProgram(resource);
      } else if (resource instanceof WebGLRenderbuffer) {
        unwrappedContext_.deleteRenderbuffer(resource);
      } else if (resource instanceof WebGLShader) {
        unwrappedContext_.deleteShader(resource);
      } else if (resource instanceof WebGLTexture) {
        unwrappedContext_.deleteTexture(resource);
      }
      else if (isWebGL2RenderingContext) {
        if (resource instanceof WebGLQuery) {
          unwrappedContext_.deleteQuery(resource);
        } else if (resource instanceof WebGLSampler) {
          unwrappedContext_.deleteSampler(resource);
        } else if (resource instanceof WebGLSync) {
          unwrappedContext_.deleteSync(resource);
        } else if (resource instanceof WebGLTransformFeedback) {
          unwrappedContext_.deleteTransformFeedback(resource);
        } else if (resource instanceof WebGLVertexArrayObject) {
          unwrappedContext_.deleteVertexArray(resource);
        }
      }
    }
  }

  function makeWebGLContextEvent(statusMessage) {
    return {
      statusMessage: statusMessage,
      preventDefault: function() {
          canRestore_ = true;
        }
    };
  }

  return canvas;

  function makeLostContextSimulatingContext(ctx) {
    // copy all functions and properties to wrapper
    for (var propertyName in ctx) {
      if (typeof ctx[propertyName] == 'function') {
         wrappedContext_[propertyName] = makeLostContextFunctionWrapper(
             ctx, propertyName);
       } else {
         makePropertyWrapper(wrappedContext_, ctx, propertyName);
       }
    }

    // Wrap a few functions specially.
    wrappedContext_.getError = function() {
      loseContextIfTime();
      if (!contextLost_) {
        var err;
        while (err = unwrappedContext_.getError()) {
          glErrorShadow_[err] = true;
        }
      }
      for (var err in glErrorShadow_) {
        if (glErrorShadow_[err]) {
          delete glErrorShadow_[err];
          return err;
        }
      }
      return wrappedContext_.NO_ERROR;
    };

    var creationFunctions = [
      "createBuffer",
      "createFramebuffer",
      "createProgram",
      "createRenderbuffer",
      "createShader",
      "createTexture"
    ];
    if (isWebGL2RenderingContext) {
      creationFunctions.push(
        "createQuery",
        "createSampler",
        "fenceSync",
        "createTransformFeedback",
        "createVertexArray"
      );
    }
    for (var ii = 0; ii < creationFunctions.length; ++ii) {
      var functionName = creationFunctions[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return null;
          }
          var obj = f.apply(ctx, arguments);
          obj.__webglDebugContextLostId__ = contextId_;
          resourceDb_.push(obj);
          return obj;
        };
      }(ctx[functionName]);
    }

    var functionsThatShouldReturnNull = [
      "getActiveAttrib",
      "getActiveUniform",
      "getBufferParameter",
      "getContextAttributes",
      "getAttachedShaders",
      "getFramebufferAttachmentParameter",
      "getParameter",
      "getProgramParameter",
      "getProgramInfoLog",
      "getRenderbufferParameter",
      "getShaderParameter",
      "getShaderInfoLog",
      "getShaderSource",
      "getTexParameter",
      "getUniform",
      "getUniformLocation",
      "getVertexAttrib"
    ];
    if (isWebGL2RenderingContext) {
      functionsThatShouldReturnNull.push(
        "getInternalformatParameter",
        "getQuery",
        "getQueryParameter",
        "getSamplerParameter",
        "getSyncParameter",
        "getTransformFeedbackVarying",
        "getIndexedParameter",
        "getUniformIndices",
        "getActiveUniforms",
        "getActiveUniformBlockParameter",
        "getActiveUniformBlockName"
      );
    }
    for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {
      var functionName = functionsThatShouldReturnNull[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return null;
          }
          return f.apply(ctx, arguments);
        }
      }(wrappedContext_[functionName]);
    }

    var isFunctions = [
      "isBuffer",
      "isEnabled",
      "isFramebuffer",
      "isProgram",
      "isRenderbuffer",
      "isShader",
      "isTexture"
    ];
    if (isWebGL2RenderingContext) {
      isFunctions.push(
        "isQuery",
        "isSampler",
        "isSync",
        "isTransformFeedback",
        "isVertexArray"
      );
    }
    for (var ii = 0; ii < isFunctions.length; ++ii) {
      var functionName = isFunctions[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return false;
          }
          return f.apply(ctx, arguments);
        }
      }(wrappedContext_[functionName]);
    }

    wrappedContext_.checkFramebufferStatus = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.checkFramebufferStatus);

    wrappedContext_.getAttribLocation = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return -1;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.getAttribLocation);

    wrappedContext_.getVertexAttribOffset = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return 0;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.getVertexAttribOffset);

    wrappedContext_.isContextLost = function() {
      return contextLost_;
    };

    if (isWebGL2RenderingContext) {
      wrappedContext_.getFragDataLocation = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return -1;
          }
          return f.apply(ctx, arguments);
        };
      }(wrappedContext_.getFragDataLocation);

      wrappedContext_.clientWaitSync = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return wrappedContext_.WAIT_FAILED;
          }
          return f.apply(ctx, arguments);
        };
      }(wrappedContext_.clientWaitSync);

      wrappedContext_.getUniformBlockIndex = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return wrappedContext_.INVALID_INDEX;
          }
          return f.apply(ctx, arguments);
        };
      }(wrappedContext_.getUniformBlockIndex);
    }

    return wrappedContext_;
  }
}

return {
  /**
   * Initializes this module. Safe to call more than once.
   * @param {!WebGLRenderingContext} ctx A WebGL context. If
   *    you have more than one context it doesn't matter which one
   *    you pass in, it is only used to pull out constants.
   */
  'init': init,

  /**
   * Returns true or false if value matches any WebGL enum
   * @param {*} value Value to check if it might be an enum.
   * @return {boolean} True if value matches one of the WebGL defined enums
   */
  'mightBeEnum': mightBeEnum,

  /**
   * Gets an string version of an WebGL enum.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
   *
   * @param {number} value Value to return an enum for
   * @return {string} The string version of the enum.
   */
  'glEnumToString': glEnumToString,

  /**
   * Converts the argument of a WebGL function to a string.
   * Attempts to convert enum arguments to strings.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 2, 0, gl.TEXTURE_2D);
   *
   * would return 'TEXTURE_2D'
   *
   * @param {string} functionName the name of the WebGL function.
   * @param {number} numArgs The number of arguments
   * @param {number} argumentIndx the index of the argument.
   * @param {*} value The value of the argument.
   * @return {string} The value as a string.
   */
  'glFunctionArgToString': glFunctionArgToString,

  /**
   * Converts the arguments of a WebGL function to a string.
   * Attempts to convert enum arguments to strings.
   *
   * @param {string} functionName the name of the WebGL function.
   * @param {number} args The arguments.
   * @return {string} The arguments as a string.
   */
  'glFunctionArgsToString': glFunctionArgsToString,

  /**
   * Given a WebGL context returns a wrapped context that calls
   * gl.getError after every command and calls a function if the
   * result is not NO_ERROR.
   *
   * You can supply your own function if you want. For example, if you'd like
   * an exception thrown on any GL error you could do this
   *
   *    function throwOnGLError(err, funcName, args) {
   *      throw WebGLDebugUtils.glEnumToString(err) +
   *            " was caused by call to " + funcName;
   *    };
   *
   *    ctx = WebGLDebugUtils.makeDebugContext(
   *        canvas.getContext("webgl"), throwOnGLError);
   *
   * @param {!WebGLRenderingContext} ctx The webgl context to wrap.
   * @param {!function(err, funcName, args): void} opt_onErrorFunc The function
   *     to call when gl.getError returns an error. If not specified the default
   *     function calls console.log with a message.
   * @param {!function(funcName, args): void} opt_onFunc The
   *     function to call when each webgl function is called. You
   *     can use this to log all calls for example.
   */
  'makeDebugContext': makeDebugContext,

  /**
   * Given a canvas element returns a wrapped canvas element that will
   * simulate lost context. The canvas returned adds the following functions.
   *
   * loseContext:
   *   simulates a lost context event.
   *
   * restoreContext:
   *   simulates the context being restored.
   *
   * lostContextInNCalls:
   *   loses the context after N gl calls.
   *
   * getNumCalls:
   *   tells you how many gl calls there have been so far.
   *
   * setRestoreTimeout:
   *   sets the number of milliseconds until the context is restored
   *   after it has been lost. Defaults to 0. Pass -1 to prevent
   *   automatic restoring.
   *
   * @param {!Canvas} canvas The canvas element to wrap.
   */
  'makeLostContextSimulatingCanvas': makeLostContextSimulatingCanvas,

  /**
   * Resets a context to the initial state.
   * @param {!WebGLRenderingContext} ctx The webgl context to
   *     reset.
   */
  'resetToInitialState': resetToInitialState
};

}();

module.exports = WebGLDebugUtils;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(82)))

/***/ }),
/* 82 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ForwardingRenderBatch = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2RenderBatch2 = __webpack_require__(22);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A render batch that uses geometry provided from an external source
 *
 * @property {*} geometryProvider
 * @class
 */
var Tw2ForwardingRenderBatch = exports.Tw2ForwardingRenderBatch = function (_Tw2RenderBatch) {
    _inherits(Tw2ForwardingRenderBatch, _Tw2RenderBatch);

    function Tw2ForwardingRenderBatch() {
        _classCallCheck(this, Tw2ForwardingRenderBatch);

        var _this = _possibleConstructorReturn(this, (Tw2ForwardingRenderBatch.__proto__ || Object.getPrototypeOf(Tw2ForwardingRenderBatch)).call(this));

        _this.geometryProvider = null;
        return _this;
    }

    /**
     * Commits the batch for rendering
     * @param {string} technique - technique name
     */


    _createClass(Tw2ForwardingRenderBatch, [{
        key: 'Commit',
        value: function Commit(technique) {
            if (this.geometryProvider) {
                this.geometryProvider.Render(this, technique);
            }
        }
    }]);

    return Tw2ForwardingRenderBatch;
}(_Tw2RenderBatch2.Tw2RenderBatch);

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2GeometryLineBatch = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2GeometryBatch2 = __webpack_require__(23);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A render batch for line geometry
 *
 * @class
 */
var Tw2GeometryLineBatch = exports.Tw2GeometryLineBatch = function (_Tw2GeometryBatch) {
    _inherits(Tw2GeometryLineBatch, _Tw2GeometryBatch);

    function Tw2GeometryLineBatch() {
        _classCallCheck(this, Tw2GeometryLineBatch);

        return _possibleConstructorReturn(this, (Tw2GeometryLineBatch.__proto__ || Object.getPrototypeOf(Tw2GeometryLineBatch)).call(this));
    }

    /**
     * Commits the Geometry Line Batch for rendering
     * @param {string} technique - technique name
     */


    _createClass(Tw2GeometryLineBatch, [{
        key: 'Commit',
        value: function Commit(technique) {
            if (this.geometryRes && this.effect) {
                this.geometryRes.RenderLines(this.meshIx, this.start, this.count, this.effect, technique);
            }
        }
    }]);

    return Tw2GeometryLineBatch;
}(_Tw2GeometryBatch2.Tw2GeometryBatch);

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2InstancedMeshBatch = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2GeometryBatch2 = __webpack_require__(23);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A render batch for Instanced geometry
 *
 * @property {Tw2InstancedMesh} instanceMesh
 * @class
 */
var Tw2InstancedMeshBatch = exports.Tw2InstancedMeshBatch = function (_Tw2GeometryBatch) {
    _inherits(Tw2InstancedMeshBatch, _Tw2GeometryBatch);

    function Tw2InstancedMeshBatch() {
        _classCallCheck(this, Tw2InstancedMeshBatch);

        var _this = _possibleConstructorReturn(this, (Tw2InstancedMeshBatch.__proto__ || Object.getPrototypeOf(Tw2InstancedMeshBatch)).call(this));

        _this.instanceMesh = null;
        return _this;
    }

    /**
     * Commits the Tw2InstancedMeshBatch for rendering
     * @param {string} technique - technique name
     */


    _createClass(Tw2InstancedMeshBatch, [{
        key: 'Commit',
        value: function Commit(technique) {
            if (this.instanceMesh && this.effect) {
                this.instanceMesh.RenderAreas(this.meshIx, this.start, this.count, this.effect, technique);
            }
        }
    }]);

    return Tw2InstancedMeshBatch;
}(_Tw2GeometryBatch2.Tw2GeometryBatch);

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2CurveSet = __webpack_require__(87);

Object.keys(_Tw2CurveSet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2CurveSet[key];
    }
  });
});

var _Tw2ValueBinding = __webpack_require__(88);

Object.keys(_Tw2ValueBinding).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ValueBinding[key];
    }
  });
});

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2CurveSet = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2CurveSet
 *
 * @property {string|number} _id
 * @property {string} name
 * @property {Array.<Tw2Curve|Tw2CurveSequencer>} curves
 * @property {Array} bindings
 * @property {number} scale
 * @property {boolean} playOnLoad
 * @property {boolean} isPlaying
 * @property {number} scaledTime
 */
var Tw2CurveSet = exports.Tw2CurveSet = function () {
    function Tw2CurveSet() {
        _classCallCheck(this, Tw2CurveSet);

        this._id = _math.util.generateID();
        this.name = '';
        this.curves = [];
        this.bindings = [];
        this.scale = 1;
        this.playOnLoad = true;
        this.isPlaying = false;
        this.scaledTime = 0;
    }

    /**
     * Initializes the Tw2CurveSet
     */


    _createClass(Tw2CurveSet, [{
        key: 'Initialize',
        value: function Initialize() {
            if (this.playOnLoad) this.Play();
        }

        /**
         * Plays the Tw2CurveSet
         */

    }, {
        key: 'Play',
        value: function Play() {
            this.isPlaying = true;
            this.scaledTime = 0;
        }

        /**
         * Plays the Tw2CurveSet from a specific time
         * @param {number} [time=0]
         */

    }, {
        key: 'PlayFrom',
        value: function PlayFrom() {
            var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            this.isPlaying = true;
            this.scaledTime = time;
        }

        /**
         * Stops the Tw2CurveSet from playing
         */

    }, {
        key: 'Stop',
        value: function Stop() {
            this.isPlaying = false;
        }

        /**
         * Internal render/update function which is called every frame
         * @param {number} dt - Delta Time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            if (this.isPlaying) {
                this.scaledTime += dt * this.scale;

                for (var i = 0; i < this.curves.length; ++i) {
                    this.curves[i].UpdateValue(this.scaledTime);
                }

                for (var _i = 0; _i < this.bindings.length; ++_i) {
                    this.bindings[_i].CopyValue();
                }
            }
        }

        /**
         * Gets the maximum curve duration
         *
         * @returns {number}
         */

    }, {
        key: 'GetMaxCurveDuration',
        value: function GetMaxCurveDuration() {
            var length = 0;
            for (var i = 0; i < this.curves.length; ++i) {
                if ('GetLength' in this.curves[i]) {
                    length = Math.max(length, this.curves[i].GetLength());
                }
            }
            return length;
        }
    }]);

    return Tw2CurveSet;
}();

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ValueBinding = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _parameter = __webpack_require__(24);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2ValueBinding
 *
 * @property {string|number} _id
 * @property {string} name
 * @property {Object} sourceObject
 * @property {string} sourceAttribute
 * @property {?number} _sourceElement
 * @property {?boolean} sourceIsArray
 * @property {Object} destinationObject
 * @property {string} destinationAttribute
 * @property {?number} _destinationElement
 * @property {?boolean} destinationIsArray
 * @property {number} scale
 * @property {quat} offset
 * @property {null|Function} _copyFunc - The function to use when updating destination attributes
 */
var Tw2ValueBinding = exports.Tw2ValueBinding = function () {
    function Tw2ValueBinding() {
        _classCallCheck(this, Tw2ValueBinding);

        this._id = _math.util.generateID();
        this.name = '';
        this.sourceObject = null;
        this.sourceAttribute = '';
        this._sourceElement = null;
        this.sourceIsArray = null;
        this.destinationObject = null;
        this.destinationAttribute = '';
        this._destinationElement = null;
        this.destinationIsArray = null;
        this.scale = 1;
        this.offset = _math.quat.create();
        this._copyFunc = null;
    }

    /**
     * Initializes the Value Binding
     */


    _createClass(Tw2ValueBinding, [{
        key: 'Initialize',
        value: function Initialize() {
            if (!this.sourceObject || this.sourceAttribute === '') return;
            if (!this.destinationObject || this.destinationAttribute === '') return;

            var srcSwizzled = false,
                destSwizzled = false,
                srcSwizzle = this.sourceAttribute.substr(-2);

            if (srcSwizzle === '.x' || srcSwizzle === '.r') {
                srcSwizzled = true;
                this._sourceElement = 0;
                this.sourceAttribute = this.sourceAttribute.substr(0, this.sourceAttribute.length - 2);
            } else if (srcSwizzle === '.y' || srcSwizzle === '.g') {
                srcSwizzled = true;
                this._sourceElement = 1;
                this.sourceAttribute = this.sourceAttribute.substr(0, this.sourceAttribute.length - 2);
            } else if (srcSwizzle === '.z' || srcSwizzle === '.b') {
                srcSwizzled = true;
                this._sourceElement = 2;
                this.sourceAttribute = this.sourceAttribute.substr(0, this.sourceAttribute.length - 2);
            } else if (srcSwizzle === '.w' || srcSwizzle === '.a') {
                srcSwizzled = true;
                this._sourceElement = 3;
                this.sourceAttribute = this.sourceAttribute.substr(0, this.sourceAttribute.length - 2);
            } else if (this.sourceObject instanceof _parameter.Tw2Vector4Parameter) {
                if (this.sourceAttribute === 'v1') {
                    srcSwizzled = true;
                    this._sourceElement = 0;
                    this.sourceAttribute = 'value';
                } else if (this.sourceAttribute === 'v2') {
                    srcSwizzled = true;
                    this._sourceElement = 1;
                    this.sourceAttribute = 'value';
                } else if (this.sourceAttribute === 'v3') {
                    srcSwizzled = true;
                    this._sourceElement = 2;
                    this.sourceAttribute = 'value';
                } else if (this.sourceAttribute === 'v4') {
                    srcSwizzled = true;
                    this._sourceElement = 3;
                    this.sourceAttribute = 'value';
                }
            }

            var destSwizzle = this.destinationAttribute.substr(-2);
            if (destSwizzle === '.x' || destSwizzle === '.r') {
                destSwizzled = true;
                this._destinationElement = 0;
                this.destinationAttribute = this.destinationAttribute.substr(0, this.destinationAttribute.length - 2);
            } else if (destSwizzle === '.y' || destSwizzle === '.g') {
                destSwizzled = true;
                this._destinationElement = 1;
                this.destinationAttribute = this.destinationAttribute.substr(0, this.destinationAttribute.length - 2);
            } else if (destSwizzle === '.z' || destSwizzle === '.b') {
                destSwizzled = true;
                this._destinationElement = 2;
                this.destinationAttribute = this.destinationAttribute.substr(0, this.destinationAttribute.length - 2);
            } else if (destSwizzle === '.w' || destSwizzle === '.a') {
                destSwizzled = true;
                this._destinationElement = 3;
                this.destinationAttribute = this.destinationAttribute.substr(0, this.destinationAttribute.length - 2);
            } else if (this.destinationObject instanceof _parameter.Tw2Vector4Parameter) {
                if (this.destinationAttribute === 'v1') {
                    destSwizzled = true;
                    this._destinationElement = 0;
                    this.destinationAttribute = 'value';
                } else if (this.destinationAttribute === 'v2') {
                    destSwizzled = true;
                    this._destinationElement = 1;
                    this.destinationAttribute = 'value';
                } else if (this.destinationAttribute === 'v3') {
                    destSwizzled = true;
                    this._destinationElement = 2;
                    this.destinationAttribute = 'value';
                } else if (this.destinationAttribute === 'v4') {
                    destSwizzled = true;
                    this._destinationElement = 3;
                    this.destinationAttribute = 'value';
                }
            }

            if (!(this.sourceAttribute in this.sourceObject) || !(this.destinationAttribute in this.destinationObject)) {
                return;
            }

            this.sourceIsArray = _math.util.isArrayLike(this.sourceObject[this.sourceAttribute]);
            this.destinationIsArray = _math.util.isArrayLike(this.destinationObject[this.destinationAttribute]);

            if (this.sourceIsArray === this.destinationIsArray && _typeof(this.sourceObject[this.sourceAttribute]) === _typeof(this.destinationObject[this.destinationAttribute])) {
                if (this.sourceIsArray) {
                    if (srcSwizzled) {
                        if (destSwizzled) {
                            this._copyFunc = Tw2ValueBinding.CopyElementToElement;
                        } else {
                            this._copyFunc = Tw2ValueBinding.ReplicateElement;
                        }
                    } else {
                        if (this.sourceObject[this.sourceAttribute].length <= this.destinationObject[this.destinationAttribute].length) {
                            this._copyFunc = Tw2ValueBinding.CopyArray;
                        } else if (this.sourceObject[this.sourceAttribute].length === 16) {
                            this._copyFunc = Tw2ValueBinding.ExtractPos;
                        }
                    }
                } else {
                    this._copyFunc = Tw2ValueBinding.CopyValueToValue;
                }
            } else if (this.sourceIsArray && srcSwizzled && typeof this.destinationObject[this.destinationAttribute] === 'number') {
                this._copyFunc = Tw2ValueBinding.CopyElementToValue;
            } else if (this.destinationIsArray && typeof this.sourceObject[this.sourceAttribute] === 'number') {
                if (destSwizzled) {
                    this._copyFunc = Tw2ValueBinding.CopyValueToElement;
                } else {
                    this._copyFunc = Tw2ValueBinding.ReplicateValue;
                }
            } else if (typeof this.sourceObject[this.sourceAttribute] === 'number' && typeof this.destinationObject[this.destinationAttribute] === 'boolean') {
                this._copyFunc = Tw2ValueBinding.CopyFloatToBoolean;
            }
        }

        /**
         * CopyValue
         * @param {*} [controller=this]
         */

    }, {
        key: 'CopyValue',
        value: function CopyValue() {
            var controller = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;

            if (this._copyFunc) {
                this._copyFunc.call(this);
                if ('OnValueChanged' in this.destinationObject) {
                    this.destinationObject.OnValueChanged(controller, [this.destinationAttribute]);
                }
            }
        }

        /**
         * _CopyValueToValue
         */

    }], [{
        key: 'CopyValueToValue',
        value: function CopyValueToValue() {
            this.destinationObject[this.destinationAttribute] = this.sourceObject[this.sourceAttribute] * this.scale + this.offset[0];
        }

        /**
         * _CopyArray
         */

    }, {
        key: 'CopyArray',
        value: function CopyArray() {
            var count = Math.min(this.destinationObject[this.destinationAttribute].length, this.sourceObject[this.sourceAttribute].length);
            for (var i = 0; i < count; ++i) {
                this.destinationObject[this.destinationAttribute][i] = this.sourceObject[this.sourceAttribute][i] * this.scale + this.offset[i];
            }
        }

        /**
         * _CopyElementToElement
         */

    }, {
        key: 'CopyElementToElement',
        value: function CopyElementToElement() {
            this.destinationObject[this.destinationAttribute][this._destinationElement] = this.sourceObject[this.sourceAttribute][this._sourceElement] * this.scale + this.offset[0];
        }

        /**
         * _ReplicateValue
         */

    }, {
        key: 'ReplicateValue',
        value: function ReplicateValue() {
            for (var i = 0; i < this.destinationObject[this.destinationAttribute].length; ++i) {
                this.destinationObject[this.destinationAttribute][i] = this.sourceObject[this.sourceAttribute] * this.scale + this.offset[i];
            }
        }

        /**
         * _CopyArray
         */

    }, {
        key: 'ReplicateElement',
        value: function ReplicateElement() {
            for (var i = 0; i < this.destinationObject[this.destinationAttribute].length; ++i) {
                this.destinationObject[this.destinationAttribute][i] = this.sourceObject[this.sourceAttribute][this._sourceElement] * this.scale + this.offset[i];
            }
        }

        /**
         * _ExtractPos
         */

    }, {
        key: 'ExtractPos',
        value: function ExtractPos() {
            for (var i = 0; i < this.destinationObject[this.destinationAttribute].length; ++i) {
                this.destinationObject[this.destinationAttribute][i] = this.sourceObject[this.sourceAttribute][i + 12] * this.scale + this.offset[i];
            }
        }

        /**
         * _CopyElementToValue
         */

    }, {
        key: 'CopyElementToValue',
        value: function CopyElementToValue() {
            this.destinationObject[this.destinationAttribute] = this.sourceObject[this.sourceAttribute][this._sourceElement] * this.scale + this.offset[0];
        }

        /**
         * _CopyValueToElement
         */

    }, {
        key: 'CopyValueToElement',
        value: function CopyValueToElement() {
            this.destinationObject[this.destinationAttribute][this._destinationElement] = this.sourceObject[this.sourceAttribute] * this.scale + this.offset[0];
        }

        /**
         * _CopyFloatToBoolean
         */

    }, {
        key: 'CopyFloatToBoolean',
        value: function CopyFloatToBoolean() {
            this.destinationObject[this.destinationAttribute] = this.sourceObject[this.sourceAttribute] !== 0;
        }
    }]);

    return Tw2ValueBinding;
}();

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2FloatParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Parameter2 = __webpack_require__(7);

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2FloatParameter
 *
 * @param {string} [name='']
 * @param {number} [value=1]
 * @property {string} name
 * @property {number} value
 * @property {?Float32Array} constantBuffer
 * @property {?number} offset
 * @class
 */
var Tw2FloatParameter = exports.Tw2FloatParameter = function (_Tw2Parameter) {
    _inherits(Tw2FloatParameter, _Tw2Parameter);

    function Tw2FloatParameter() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

        _classCallCheck(this, Tw2FloatParameter);

        var _this = _possibleConstructorReturn(this, (Tw2FloatParameter.__proto__ || Object.getPrototypeOf(Tw2FloatParameter)).call(this, name));

        _this.value = _math.util.isArrayLike(value) ? value[0] : value;
        _this.constantBuffer = null;
        _this.offset = null;
        return _this;
    }

    /**
     * Sets the parameter's value
     * @param {number} value
     * @returns {boolean} true if updated
     */


    _createClass(Tw2FloatParameter, [{
        key: 'SetValue',
        value: function SetValue(value) {
            this.value = value;
            this.OnValueChanged();
        }

        /**
         * Gets the parameter's value
         * @returns {number}
         */

    }, {
        key: 'GetValue',
        value: function GetValue() {
            return this.value;
        }

        /**
         * Applies the parameter's value to a constant buffer
         * @param {Float32Array} constantBuffer
         * @param {number} offset
         */

    }, {
        key: 'Apply',
        value: function Apply(constantBuffer, offset) {
            constantBuffer[offset] = this.value;
        }

        /**
         * Checks if a value equals the parameter's value
         * @param {number} value
         * @returns {boolean}
         */

    }, {
        key: 'EqualsValue',
        value: function EqualsValue(value) {
            return this.value === value;
        }

        /**
         * Copies another float parameter's value
         * @param {Tw2FloatParameter} parameter
         * @param {boolean} [includeName]
         */

    }, {
        key: 'Copy',
        value: function Copy(parameter, includeName) {
            if (includeName) this.name = parameter.name;
            this.SetValue(parameter.GetValue());
        }

        /**
         * Checks if a value is a valid value
         * @param {number} value
         * @returns {boolean}
         */

    }], [{
        key: 'is',
        value: function is(value) {
            return typeof value === 'number';
        }
    }]);

    return Tw2FloatParameter;
}(_Tw2Parameter2.Tw2Parameter);

Tw2FloatParameter.size = 1;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2MatrixParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Parameter = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2MatrixParameter
 *
 * @param {string} [name='']
 * @param {mat4|Float32Array|Array} [value=mat4.create()]
 * @class
 */
var Tw2MatrixParameter = exports.Tw2MatrixParameter = function (_Tw2VectorParameter) {
    _inherits(Tw2MatrixParameter, _Tw2VectorParameter);

    function Tw2MatrixParameter() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _math.mat4.create();

        _classCallCheck(this, Tw2MatrixParameter);

        return _possibleConstructorReturn(this, (Tw2MatrixParameter.__proto__ || Object.getPrototypeOf(Tw2MatrixParameter)).call(this, name, value));
    }

    /**
     * Composes the parameter's value from components
     * @param {Tw2Vector4Parameter|quat} rotation
     * @param {Tw2Vector3Parameter|vec3} translation
     * @param {Tw2Vector3Parameter|vec3} scaling
     */


    _createClass(Tw2MatrixParameter, [{
        key: 'Compose',
        value: function Compose(rotation, translation, scaling) {
            if ('value' in rotation) rotation = rotation['value'];
            if ('value' in translation) translation = translation['value'];
            if ('value' in scaling) scaling = scaling['value'];

            _math.mat4.fromRotationTranslationScale(this.value, rotation, translation, scaling);
            this.OnValueChanged();
        }

        /**
         * Decomposes the parameter's value to components
         * @param {Tw2Vector4Parameter|quat} rotation
         * @param {Tw2Vector3Parameter|vec3} translation
         * @param {Tw2Vector3Parameter|vec3} scaling
         */

    }, {
        key: 'Decompose',
        value: function Decompose(rotation, translation, scaling) {
            _math.mat4.getRotation('value' in rotation ? rotation.value : rotation, this.value);
            _math.mat4.getTranslation('value' in translation ? translation.value : translation, this.value);
            _math.mat4.getScaling('value' in scaling ? scaling.value : scaling, this.value);

            if ('OnValueChanged' in rotation) rotation.OnValueChanged();
            if ('OnValueChanged' in translation) translation.OnValueChanged();
            if ('OnValueChanged' in scaling) scaling.OnValueChanged();
        }

        /**
         * Gets the matrices' translation x value
         * @returns {number}
         */

    }, {
        key: 'x',
        get: function get() {
            return this.GetIndexValue(12);
        }

        /**
         * Sets the matrices' translation x value
         * @param {number} val
         */
        ,
        set: function set(val) {
            this.SetIndexValue(12, val);
        }

        /**
         * Gets the matrices' translation y value
         * @returns {number}
         */

    }, {
        key: 'y',
        get: function get() {
            return this.GetIndexValue(13);
        }

        /**
         * Sets the matrices' translation y value
         * @param {number} val
         */
        ,
        set: function set(val) {
            this.SetIndexValue(13, val);
        }

        /**
         * Gets the matrices' translation z value
         * @returns {number}
         */

    }, {
        key: 'z',
        get: function get() {
            return this.GetIndexValue(14);
        }

        /**
         * Sets the matrices' translation z value
         * @param {number} val
         */
        ,
        set: function set(val) {
            this.SetIndexValue(14, val);
        }
    }]);

    return Tw2MatrixParameter;
}(_Tw2Parameter.Tw2VectorParameter);

Tw2MatrixParameter.constantBufferSize = 16;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2TransformParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _math = __webpack_require__(0);

var _Tw2Parameter2 = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2TransformParameter
 *
 * @param {string} [name='']
 * @parameter {string} name
 * @parameter {vec3} scaling=[1,1,1]
 * @parameter {quat} rotation=[0,0,0,1]
 * @parameter {vec3} translation=[0,0,0]
 * @parameter {mat4} transform
 * @parameter {mat4} transformTranspose
 * @class
 */
var Tw2TransformParameter = exports.Tw2TransformParameter = function (_Tw2Parameter) {
    _inherits(Tw2TransformParameter, _Tw2Parameter);

    function Tw2TransformParameter() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        _classCallCheck(this, Tw2TransformParameter);

        var _this = _possibleConstructorReturn(this, (Tw2TransformParameter.__proto__ || Object.getPrototypeOf(Tw2TransformParameter)).call(this, name));

        _this.scaling = _math.vec3.fromValues(1, 1, 1);
        _this.rotationCenter = _math.vec3.create();
        _this.rotation = _math.quat.create();
        _this.translation = _math.vec3.create();
        _this.transform = _math.mat4.create();
        _this.worldTransform = _math.mat4.create();
        _this.constantBuffer = null;
        _this.offset = null;
        return _this;
    }

    /**
     * Initializes the transform parameter
     */


    _createClass(Tw2TransformParameter, [{
        key: 'Initialize',
        value: function Initialize() {
            this.OnValueChanged();
        }

        /**
         * Gets the parameter's value
         * @param {boolean} [serialize]
         * @returns {Array|Float32Array|mat4}
         */

    }, {
        key: 'GetValue',
        value: function GetValue(serialize) {
            return serialize ? Array.from(this.transform) : new Float32Array(this.transform);
        }

        /**
         * Fire on value changes
         * @param {*} [controller]        - An optional argument to track the object that called this function
         * @param {string[]} [properties] - An option array containing the properties that were updated
         */

    }, {
        key: 'OnValueChanged',
        value: function OnValueChanged(controller, properties) {
            _math.mat4.fromRotationTranslationScaleOrigin(this.transform, this.rotation, this.translation, this.scaling, this.rotationCenter);
            _math.mat4.transpose(this.worldTransform, this.transform);
            _get(Tw2TransformParameter.prototype.__proto__ || Object.getPrototypeOf(Tw2TransformParameter.prototype), 'OnValueChanged', this).call(this, controller, properties);
        }

        /**
         * Binds the parameter to a constant buffer
         * @param {Float32Array} constantBuffer
         * @param {number} offset
         * @param {number} size
         * @returns {boolean}
         */

    }, {
        key: 'Bind',
        value: function Bind(constantBuffer, offset, size) {
            if (!this.constantBuffer && size >= this.size) {
                this.constantBuffer = constantBuffer;
                this.offset = offset;
                this.Apply(constantBuffer, offset, size);
                return true;
            }
            return false;
        }

        /**
         * Applies the parameter's value to a constant buffer
         * @param {Float32Array} constantBuffer
         * @param {number} offset
         * @param {number} size
         */

    }, {
        key: 'Apply',
        value: function Apply(constantBuffer, offset, size) {
            if (size >= this.constructor.constantBufferSize) {
                constantBuffer.set(this.worldTransform, offset);
            } else {
                constantBuffer.set(this.worldTransform.subarray(0, size), offset);
            }
        }

        /**
         * Copies another transform parameter's values
         * @param {Tw2TransformParameter} parameter
         * @param {boolean} [includeName]
         */

    }, {
        key: 'Copy',
        value: function Copy(parameter, includeName) {
            if (includeName) this.name = parameter.name;
            _math.quat.copy(this.rotation, parameter.rotation);
            _math.vec3.copy(this.translation, parameter.translation);
            _math.vec3.copy(this.scaling, parameter.scaling);
            _math.vec3.copy(this.rotationCenter, parameter.rotationCenter);
            this.OnValueChanged();
        }
    }]);

    return Tw2TransformParameter;
}(_Tw2Parameter2.Tw2Parameter);

/**
 * The parameter's constant buffer size
 * @type {number}
 */


Tw2TransformParameter.constantBufferSize = 16;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2VariableParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Store = __webpack_require__(16);

var _Tw2Parameter2 = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2VariableParameter
 *
 * @param {string} [name='']
 * @param {string} [variableName='']
 * @property {string} variableName
 * @class
 */
var Tw2VariableParameter = exports.Tw2VariableParameter = function (_Tw2Parameter) {
    _inherits(Tw2VariableParameter, _Tw2Parameter);

    function Tw2VariableParameter() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var variableName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

        _classCallCheck(this, Tw2VariableParameter);

        var _this = _possibleConstructorReturn(this, (Tw2VariableParameter.__proto__ || Object.getPrototypeOf(Tw2VariableParameter)).call(this, name));

        _this.variableName = variableName;
        return _this;
    }

    /**
     * Gets the linked variable
     * @returns {Tw2Parameter}
     */


    _createClass(Tw2VariableParameter, [{
        key: 'GetValue',


        /**
         * Gets the variable's value
         * @param {boolean} [serialize]
         * @returns {?*}
         */
        value: function GetValue(serialize) {
            return _Tw2Store.store.GetVariableValue(this.variableName, serialize);
        }

        /**
         * Apply
         * @param {*} a
         * @param {*} b
         * @param {*} c
         */

    }, {
        key: 'Apply',
        value: function Apply(a, b, c) {
            if (this.variable) {
                this.variable.Apply(a, b, c);
            }
        }

        /**
         * Not implemented for Variable Parameters
         * @returns {boolean} true if successful
         */

    }, {
        key: 'AddCallback',
        value: function AddCallback() {
            return false;
        }

        /**
         * Copies another variable parameter's value
         * @param {Tw2VariableParameter} parameter
         * @param {boolean} [includeName]
         */

    }, {
        key: 'Copy',
        value: function Copy(parameter, includeName) {
            if (includeName) this.name = parameter.name;
            this.variableName = parameter.variableName;
        }
    }, {
        key: 'variable',
        get: function get() {
            return _Tw2Store.store.GetVariable(this.variableName);
        }

        /**
         * Gets the linked variable's size
         * @returns {number}
         */

    }, {
        key: 'size',
        get: function get() {
            return this.variable ? this.variable.size : 0;
        }
    }]);

    return Tw2VariableParameter;
}(_Tw2Parameter2.Tw2Parameter);

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2Vector2Parameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Parameter = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2Vector2Parameter
 *
 * @param {string} [name='']
 * @param {vec2|Array|Float32Array} [value=vec2.fromValues(1,1)]
 * @class
 */
var Tw2Vector2Parameter = exports.Tw2Vector2Parameter = function (_Tw2VectorParameter) {
  _inherits(Tw2Vector2Parameter, _Tw2VectorParameter);

  function Tw2Vector2Parameter() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _math.vec2.fromValues(1, 1);

    _classCallCheck(this, Tw2Vector2Parameter);

    return _possibleConstructorReturn(this, (Tw2Vector2Parameter.__proto__ || Object.getPrototypeOf(Tw2Vector2Parameter)).call(this, name, value));
  }

  /**
   * Gets the first value index
   * @returns {number}
   */


  _createClass(Tw2Vector2Parameter, [{
    key: 'x',
    get: function get() {
      return this.GetIndexValue(0);
    }

    /**
     * Sets the first value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(0, val);
    }

    /**
     * Gets the second value index
     * @returns {number}
     */

  }, {
    key: 'y',
    get: function get() {
      return this.GetIndexValue(1);
    }

    /**
     * Sets the second value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(1, val);
    }
  }]);

  return Tw2Vector2Parameter;
}(_Tw2Parameter.Tw2VectorParameter);

/**
 * The parameter's constant buffer size
 * @type {number}
 */


Tw2Vector2Parameter.constantBufferSize = 2;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2Vector3Parameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Parameter = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2Vector3Parameter
 *
 * @param {string} [name='']
 * @param {vec3|Array|Float32Array} [value=vec3.fromValues(1,1,1)]
 * @class
 */
var Tw2Vector3Parameter = exports.Tw2Vector3Parameter = function (_Tw2VectorParameter) {
  _inherits(Tw2Vector3Parameter, _Tw2VectorParameter);

  function Tw2Vector3Parameter() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _math.vec3.fromValues(1, 1, 1);

    _classCallCheck(this, Tw2Vector3Parameter);

    return _possibleConstructorReturn(this, (Tw2Vector3Parameter.__proto__ || Object.getPrototypeOf(Tw2Vector3Parameter)).call(this, name, value));
  }

  /**
   * Gets the first value index
   * @returns {number}
   */


  _createClass(Tw2Vector3Parameter, [{
    key: 'x',
    get: function get() {
      return this.GetIndexValue(0);
    }

    /**
     * Sets the first value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(0, val);
    }

    /**
     * Gets the second value index
     * @returns {number}
     */

  }, {
    key: 'y',
    get: function get() {
      return this.GetIndexValue(1);
    }

    /**
     * Sets the second value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(1, val);
    }

    /**
     * Gets the third value index
     * @returns {number}
     */

  }, {
    key: 'z',
    get: function get() {
      return this.GetIndexValue(2);
    }

    /**
     * Sets the third value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(2, val);
    }
  }]);

  return Tw2Vector3Parameter;
}(_Tw2Parameter.Tw2VectorParameter);

/**
 * The parameter's constant buffer size
 * @type {number}
 */


Tw2Vector3Parameter.constantBufferSize = 3;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2Vector4Parameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Parameter = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2Vector4Parameter
 *
 * @param {string} [name='']
 * @param {vec4|Array|Float32Array} [value=vec4.fromValues(1,1,1,1)]
 * @class
 */
var Tw2Vector4Parameter = exports.Tw2Vector4Parameter = function (_Tw2VectorParameter) {
  _inherits(Tw2Vector4Parameter, _Tw2VectorParameter);

  function Tw2Vector4Parameter() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _math.vec4.fromValues(1, 1, 1, 1);

    _classCallCheck(this, Tw2Vector4Parameter);

    return _possibleConstructorReturn(this, (Tw2Vector4Parameter.__proto__ || Object.getPrototypeOf(Tw2Vector4Parameter)).call(this, name, value));
  }

  /**
   * Gets the first value index
   * @returns {number}
   */


  _createClass(Tw2Vector4Parameter, [{
    key: 'x',
    get: function get() {
      return this.GetIndexValue(0);
    }

    /**
     * Sets the first value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(0, val);
    }

    /**
     * Gets the second value index
     * @returns {number}
     */

  }, {
    key: 'y',
    get: function get() {
      return this.GetIndexValue(1);
    }

    /**
     * Sets the second value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(1, val);
    }

    /**
     * Gets the third value index
     * @returns {number}
     */

  }, {
    key: 'z',
    get: function get() {
      return this.GetIndexValue(2);
    }

    /**
     * Sets the third value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(2, val);
    }

    /**
     * Gets the fourth value index
     * @returns {number}
     */

  }, {
    key: 'w',
    get: function get() {
      return this.GetIndexValue(3);
    }

    /**
     * Sets the fourth value index
     * @param {number} val
     */
    ,
    set: function set(val) {
      this.SetIndexValue(3, val);
    }
  }]);

  return Tw2Vector4Parameter;
}(_Tw2Parameter.Tw2VectorParameter);

/**
 * The parameter's constant buffer size
 * @type {number}
 */


Tw2Vector4Parameter.constantBufferSize = 4;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2BasicPerObjectData = __webpack_require__(97);

Object.keys(_Tw2BasicPerObjectData).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2BasicPerObjectData[key];
    }
  });
});

var _Tw2PerObjectData = __webpack_require__(44);

Object.keys(_Tw2PerObjectData).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2PerObjectData[key];
    }
  });
});

var _Tw2RawData = __webpack_require__(25);

Object.keys(_Tw2RawData).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RawData[key];
    }
  });
});

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveBasicPerObjectData = exports.Tw2BasicPerObjectData = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Tw2Device = __webpack_require__(2);

var _Tw2PerObjectData2 = __webpack_require__(44);

var _Tw2RawData = __webpack_require__(25);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2BasicPerObjectData
 *
 * @param {RawDataObject} [rawDataObject]    - An optional object containing raw data declarations
 * @parameter {?Tw2RawData} perObjectFFEData - Fixed Function Emulation data
 * @class
 */
var Tw2BasicPerObjectData = exports.Tw2BasicPerObjectData = function (_Tw2PerObjectData) {
    _inherits(Tw2BasicPerObjectData, _Tw2PerObjectData);

    function Tw2BasicPerObjectData(rawDataObject) {
        _classCallCheck(this, Tw2BasicPerObjectData);

        var _this = _possibleConstructorReturn(this, (Tw2BasicPerObjectData.__proto__ || Object.getPrototypeOf(Tw2BasicPerObjectData)).call(this));

        _this.perObjectFFEData = null;

        if (rawDataObject) _this.DeclareFromObject(rawDataObject);
        return _this;
    }

    /**
     * Sets per object data to the device
     * @param constantBufferHandles
     */


    _createClass(Tw2BasicPerObjectData, [{
        key: 'SetPerObjectDataToDevice',
        value: function SetPerObjectDataToDevice(constantBufferHandles) {
            _get(Tw2BasicPerObjectData.prototype.__proto__ || Object.getPrototypeOf(Tw2BasicPerObjectData.prototype), 'SetPerObjectDataToDevice', this).call(this, constantBufferHandles);

            if (this.perObjectFFEData && constantBufferHandles[5]) {
                _Tw2Device.device.gl.uniform4fv(constantBufferHandles[5], this.perObjectFFEData.data);
            }
        }

        /**
         * Defines and creates raw data from an object
         * @param {RawDataObject} rawDataObject
         */

    }, {
        key: 'DeclareFromObject',
        value: function DeclareFromObject() {
            var rawDataObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            _get(Tw2BasicPerObjectData.prototype.__proto__ || Object.getPrototypeOf(Tw2BasicPerObjectData.prototype), 'DeclareFromObject', this).call(this, rawDataObject);

            if (rawDataObject.FFEData) {
                this.perObjectFFEData = new _Tw2RawData.Tw2RawData(rawDataObject.FFEData);
            }
        }
    }]);

    return Tw2BasicPerObjectData;
}(_Tw2PerObjectData2.Tw2PerObjectData);

exports.EveBasicPerObjectData = Tw2BasicPerObjectData;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2RuntimeInstanceData = __webpack_require__(99);

Object.keys(_Tw2RuntimeInstanceData).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RuntimeInstanceData[key];
    }
  });
});

var _Tw2VariableStore = __webpack_require__(117);

Object.keys(_Tw2VariableStore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2VariableStore[key];
    }
  });
});

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2RuntimeInstanceData = Tw2RuntimeInstanceData;

var _Tw2Device = __webpack_require__(2);

var _vertex = __webpack_require__(9);

var _particle = __webpack_require__(45);

/**
 * Tw2RuntimeInstanceData
 * @property {string} name
 * @property {number} count
 * @constructor
 */
function Tw2RuntimeInstanceData() {
    this.name = '';
    this.count = 0;

    var declaration = null;
    var vb = null;
    var vertexStride = 0;
    var count = 0;
    var data = null;
    var dataDirty = true;

    /**
     * GetMaxInstanceCount
     * @returns {number}
     * @method
     */
    this.GetMaxInstanceCount = function () {
        return data ? data.length : 1;
    };

    /**
     * SetElementLayout
     * @param decl
     * @method
     */
    this.SetElementLayout = function (decl) {
        if (vb) {
            _Tw2Device.device.gl.deleteBuffer(vb);
            vb = null;
        }

        vertexStride = 0;
        declaration = new _vertex.Tw2VertexDeclaration();

        for (var i = 0; i < decl.length; ++i) {
            var element = new _particle.Tw2ParticleElementDeclaration();
            element.elementType = decl[i][0];
            element.dimension = decl[i][2];
            element.usageIndex = decl[i][1];

            var d = element.GetDeclaration();
            d.offset = vertexStride * 4;
            declaration.elements.push(d);
            vertexStride += element.dimension;
        }

        declaration.RebuildHash();
    };

    /**
     * SetData
     * @param data_
     * @constructor
     */
    this.SetData = function (data_) {
        if (!declaration) {
            return;
        }
        data = data_;
        count = data.length;
        dataDirty = true;
        this.UpdateData();
    };

    /**
     * SetItemElement
     * @param index
     * @param elementIndex
     * @param value
     * @constructor
     */
    this.SetItemElement = function (index, elementIndex, value) {
        if (declaration.elements[elementIndex].elements > 1) {
            for (var i = 0; i < declaration.elements[elementIndex].elements; ++i) {
                data[index][elementIndex][i] = value[i];
            }
        } else {
            data[index][elementIndex] = value;
        }

        dataDirty = true;
    };

    /**
     * SetItemElementRef
     * @param index
     * @param elementIndex
     * @param value
     * @constructor
     */
    this.SetItemElementRef = function (index, elementIndex, value) {
        data[index][elementIndex] = value;
        dataDirty = true;
    };

    /**
     * GetItemElement
     * @param index
     * @param elementIndex
     * @returns {*}
     * @method
     */
    this.GetItemElement = function (index, elementIndex) {
        return data[index][elementIndex];
    };

    /**
     * UpdateData
     * @method
     */
    this.UpdateData = function () {
        if (!dataDirty || !declaration) {
            return;
        }

        var vbData = new Float32Array(data.length * vertexStride);
        var offset = 0;
        var i, j, k;

        for (i = 0; i < data.length; ++i) {
            for (j = 0; j < declaration.elements.length; ++j) {
                if (declaration.elements[j].elements === 1) {
                    vbData[offset++] = data[i][j];
                } else {
                    for (k = 0; k < declaration.elements[j].elements; ++k) {
                        vbData[offset++] = data[i][j][k];
                    }
                }
            }
        }

        if (!vb) {
            vb = _Tw2Device.device.gl.createBuffer();
        }

        _Tw2Device.device.gl.bindBuffer(_Tw2Device.device.gl.ARRAY_BUFFER, vb);
        _Tw2Device.device.gl.bufferData(_Tw2Device.device.gl.ARRAY_BUFFER, vbData, _Tw2Device.device.gl.STATIC_DRAW);
        _Tw2Device.device.gl.bindBuffer(_Tw2Device.device.gl.ARRAY_BUFFER, null);
        dataDirty = false;
    };

    /**
     * Unloads the webgl buffer
     * @method
     */
    this.Unload = function () {
        if (vb) {
            _Tw2Device.device.gl.deleteBuffer(vb);
            vb = null;
        }
    };

    /**
     * GetInstanceBuffer
     * @returns {WebglArrayBuffer}
     * @method
     */
    this.GetInstanceBuffer = function () {
        return vb;
    };

    /**
     * GetInstanceDeclaration
     * @returns {Tw2VertexDeclaration}
     * @method
     */
    this.GetInstanceDeclaration = function () {
        return declaration;
    };

    /**
     * GetInstanceStride
     * @returns {number}
     * @method
     */
    this.GetInstanceStride = function () {
        return vertexStride * 4;
    };

    /**
     * GetInstanceCount
     * @returns {number}
     * @method
     */
    this.GetInstanceCount = function () {
        return count;
    };
}

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2StaticEmitter = __webpack_require__(101);

Object.keys(_Tw2StaticEmitter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2StaticEmitter[key];
    }
  });
});

var _Tw2DynamicEmitter = __webpack_require__(102);

Object.keys(_Tw2DynamicEmitter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2DynamicEmitter[key];
    }
  });
});

var _Tw2GpuUniqueEmitter = __webpack_require__(103);

Object.keys(_Tw2GpuUniqueEmitter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2GpuUniqueEmitter[key];
    }
  });
});

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2StaticEmitter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(1);

var _Tw2ParticleEmitter2 = __webpack_require__(26);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2StaticEmitter
 *
 * @property {string} name
 * @property {string} geometryResourcePath
 * @property {Tw2GeometryRes} geometryResource
 * @property {Number} geometryIndex
 * @property {Boolean} _spawned
 * @inherits Tw2ParticleEmitter
 * @class
 */
var Tw2StaticEmitter = exports.Tw2StaticEmitter = function (_Tw2ParticleEmitter) {
    _inherits(Tw2StaticEmitter, _Tw2ParticleEmitter);

    function Tw2StaticEmitter() {
        _classCallCheck(this, Tw2StaticEmitter);

        var _this = _possibleConstructorReturn(this, (Tw2StaticEmitter.__proto__ || Object.getPrototypeOf(Tw2StaticEmitter)).call(this));

        _this.geometryResourcePath = '';
        _this.geometryResource = null;
        _this.geometryIndex = 0;
        _this._spawned = false;
        return _this;
    }

    /**
     * Initializes the particle emitter
     */


    _createClass(Tw2StaticEmitter, [{
        key: 'Initialize',
        value: function Initialize() {
            if (this.geometryResourcePath !== '') {
                this.geometryResource = _core.resMan.GetResource(this.geometryResourcePath);
                this.geometryResource.systemMirror = true;
                this.geometryResource.RegisterNotification(this);
            }
            this._spawned = false;
        }

        /**
         * Rebuilds cached data
         */

    }, {
        key: 'RebuildCachedData',
        value: function RebuildCachedData() {
            if (this.geometryResource && this.geometryResource.meshes.length) {
                if (!this.geometryResource.meshes[0].bufferData) {
                    this.geometryResource.systemMirror = true;
                    this.geometryResource.Reload();
                }
            }
        }

        /**
         * Per frame update
         */

    }, {
        key: 'Update',
        value: function Update() {
            if (!this._spawned && this.particleSystem && this.geometryResource && this.geometryResource.IsGood() && this.geometryResource.meshes.length > this.geometryIndex && this.geometryResource.meshes[this.geometryIndex].bufferData) {
                this._spawned = true;

                var mesh = this.geometryResource.meshes[this.geometryIndex],
                    elts = this.particleSystem.elements,
                    inputs = new Array(elts.length);

                for (var i = 0; i < elts.length; ++i) {
                    var d = elts[i].GetDeclaration(),
                        input = mesh.declaration.FindUsage(d.usage, d.usageIndex - 8);

                    if (input === null) {
                        _core.logger.log('res.error', {
                            log: 'error',
                            src: ['Tw2StaticEmitter', 'Update'],
                            msg: 'Input geometry mesh lacks element required by particle system',
                            path: this.geometryResource.path,
                            type: 'geometry.elements',
                            data: {
                                elementUsage: d.usage,
                                elementUsageIndex: d.usageIndex
                            }
                        });
                        return;
                    }

                    if (input.elements < d.elements) {
                        _core.logger.log('res.error', {
                            log: 'error',
                            src: ['Tw2StaticEmitter', 'Update'],
                            msg: 'Input geometry mesh elements do not have the required number of components',
                            path: this.geometryResource.path,
                            type: 'geometry.elementcomponents',
                            data: {
                                inputCount: input.elements,
                                elementCount: d.elements,
                                elementUsage: d.usage,
                                elementUsageIndex: d.usageIndex
                            }
                        });
                        return;
                    }

                    inputs[i] = input.offset / 4;
                }

                var vertexCount = mesh.bufferData.length / mesh.declaration.stride * 4;
                for (var _i = 0; _i < vertexCount; ++_i) {
                    var index = this.particleSystem.BeginSpawnParticle();
                    if (index === null) break;

                    for (var j = 0; j < this.particleSystem._elements.length; ++j) {
                        var e = this.particleSystem._elements[j];
                        for (var k = 0; k < e.dimension; ++k) {
                            e.buffer[e.instanceStride * index + e.startOffset + k] = mesh.bufferData[inputs[j] + k + _i * mesh.declaration.stride / 4];
                        }
                    }
                    this.particleSystem.EndSpawnParticle();
                }
            }
        }
    }]);

    return Tw2StaticEmitter;
}(_Tw2ParticleEmitter2.Tw2ParticleEmitter);

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2DynamicEmitter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2ParticleEmitter2 = __webpack_require__(26);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2DynamicEmitter
 *
 * @property {string} name
 * @property {number} rate
 * @property {boolean} isValid
 * @property {number} _accumulatedRate
 * @property {Array<Tw2ParticleAttributeGenerator>}} generators
 * @inherits Tw2ParticleEmitter
 * @class
 */
var Tw2DynamicEmitter = exports.Tw2DynamicEmitter = function (_Tw2ParticleEmitter) {
    _inherits(Tw2DynamicEmitter, _Tw2ParticleEmitter);

    function Tw2DynamicEmitter() {
        _classCallCheck(this, Tw2DynamicEmitter);

        var _this = _possibleConstructorReturn(this, (Tw2DynamicEmitter.__proto__ || Object.getPrototypeOf(Tw2DynamicEmitter)).call(this));

        _this.rate = 0;
        _this.isValid = false;
        _this._accumulatedRate = 0;
        _this.generators = [];
        return _this;
    }

    /**
     * Initializes the particle emitter
     */


    _createClass(Tw2DynamicEmitter, [{
        key: 'Initialize',
        value: function Initialize() {
            this.Rebind();
        }

        /**
         * Per frame update
         * @param {number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            this.SpawnParticles(null, null, Math.min(dt, 0.1));
        }

        /**
         * Rebinds the emitter's generators to it's particle system
         */

    }, {
        key: 'Rebind',
        value: function Rebind() {
            this.isValid = false;
            if (!this.particleSystem) return;

            for (var i = 0; i < this.generators.length; ++i) {
                if (!this.generators[i].Bind(this.particleSystem)) return;
            }

            this.isValid = true;
        }

        /**
         * Spawn particles
         * @param position
         * @param velocity
         * @param rateModifier
         */

    }, {
        key: 'SpawnParticles',
        value: function SpawnParticles(position, velocity, rateModifier) {
            if (!this.isValid) return;

            this._accumulatedRate += this.rate * rateModifier;
            var count = Math.floor(this._accumulatedRate);
            this._accumulatedRate -= count;

            for (var i = 0; i < count; ++i) {
                var index = this.particleSystem.BeginSpawnParticle();
                if (index === null) break;

                for (var j = 0; j < this.generators.length; ++j) {
                    this.generators[j].Generate(position, velocity, index);
                }

                this.particleSystem.EndSpawnParticle();
            }
        }
    }]);

    return Tw2DynamicEmitter;
}(_Tw2ParticleEmitter2.Tw2ParticleEmitter);

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tr2GpuUniqueEmitter = exports.Tw2GpuUniqueEmitter = undefined;

var _math = __webpack_require__(0);

var _Tw2ParticleEmitter2 = __webpack_require__(26);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tr2GpuUniqueEmitter - not implemented yet
 *
 * @property {number} angle
 * @property {number} innerAngle
 * @property {number} drag
 * @property {number} rate
 * @property {number} radius
 * @property {number} gravity
 * @property {number} maxSpeed
 * @property {number} minSpeed
 * @property {number} minLifeTime
 * @property {number} maxLifeTime
 * @property {number} sizeVariance
 * @property {vec3} attractorPosition
 * @property {number} attractorStrength
 * @property {number} textureIndex
 * @property {number} turbulenceAmplitude
 * @property {number} turbulenceFrequency
 * @property {vec3} sizes
 * @property {vec4} color0
 * @property {vec4} color1
 * @property {vec4} color2
 * @property {vec4} color3
 * @class
 */
var Tw2GpuUniqueEmitter = exports.Tw2GpuUniqueEmitter = function (_Tw2ParticleEmitter) {
    _inherits(Tw2GpuUniqueEmitter, _Tw2ParticleEmitter);

    function Tw2GpuUniqueEmitter() {
        _classCallCheck(this, Tw2GpuUniqueEmitter);

        var _this = _possibleConstructorReturn(this, (Tw2GpuUniqueEmitter.__proto__ || Object.getPrototypeOf(Tw2GpuUniqueEmitter)).call(this));

        _this.angle = 0;
        _this.innerAngle = 0;
        _this.drag = 0;
        _this.rate = 0;
        _this.radius = 0;
        _this.gravity = 0;
        _this.maxSpeed = 0;
        _this.minSpeed = 0;
        _this.minLifeTime = 0;
        _this.maxLifeTime = 0;
        _this.sizeVariance = 0;
        _this.attractorPosition = _math.vec3.create();
        _this.attractorStrength = 0;
        _this.turbulenceAmplitude = 0;
        _this.turbulenceFrequency = 0;
        _this.textureIndex = 0;
        _this.sizes = _math.vec3.create();
        _this.position = _math.vec3.create();
        _this.color0 = _math.vec4.create();
        _this.color1 = _math.vec4.create();
        _this.color2 = _math.vec4.create();
        _this.color3 = _math.vec4.create();

        //this.maxDisplacement=null;
        //this.emissionDensity=null;
        //this.velocityStretchRotation=null;
        //this.inheritVelocity=null;
        return _this;
    }

    return Tw2GpuUniqueEmitter;
}(_Tw2ParticleEmitter2.Tw2ParticleEmitter);

// Temporary alias


exports.Tr2GpuUniqueEmitter = Tw2GpuUniqueEmitter;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2ParticleAttractorForce = __webpack_require__(105);

Object.keys(_Tw2ParticleAttractorForce).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleAttractorForce[key];
    }
  });
});

var _Tw2ParticleDirectForce = __webpack_require__(106);

Object.keys(_Tw2ParticleDirectForce).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleDirectForce[key];
    }
  });
});

var _Tw2ParticleDragForce = __webpack_require__(107);

Object.keys(_Tw2ParticleDragForce).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleDragForce[key];
    }
  });
});

var _Tw2ParticleFluidDragForce = __webpack_require__(108);

Object.keys(_Tw2ParticleFluidDragForce).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleFluidDragForce[key];
    }
  });
});

var _Tw2ParticleSpring = __webpack_require__(109);

Object.keys(_Tw2ParticleSpring).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleSpring[key];
    }
  });
});

var _Tw2ParticleTurbulenceForce = __webpack_require__(110);

Object.keys(_Tw2ParticleTurbulenceForce).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ParticleTurbulenceForce[key];
    }
  });
});

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleAttractorForce = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleForce2 = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ParticleAttractorForce
 *
 * @property {number} magnitude
 * @property {vec3} position
 * @property {vec3} _tempVec
 * @inherits Tw2ParticleForce
 * @class
 */
var Tw2ParticleAttractorForce = exports.Tw2ParticleAttractorForce = function (_Tw2ParticleForce) {
    _inherits(Tw2ParticleAttractorForce, _Tw2ParticleForce);

    function Tw2ParticleAttractorForce() {
        _classCallCheck(this, Tw2ParticleAttractorForce);

        var _this = _possibleConstructorReturn(this, (Tw2ParticleAttractorForce.__proto__ || Object.getPrototypeOf(Tw2ParticleAttractorForce)).call(this));

        _this.magnitude = 0;
        _this.position = _math.vec3.create();
        return _this;
    }

    /**
     * ApplyForce
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     */


    _createClass(Tw2ParticleAttractorForce, [{
        key: 'ApplyForce',
        value: function ApplyForce(position, velocity, force) {
            var vec3_0 = _Tw2ParticleForce2.Tw2ParticleForce.global.vec3_0;

            vec3_0[0] = this.position[0] - position.buffer[position.offset];
            vec3_0[1] = this.position[1] - position.buffer[position.offset + 1];
            vec3_0[2] = this.position[2] - position.buffer[position.offset + 2];

            _math.vec3.normalize(vec3_0, vec3_0);
            _math.vec3.scale(vec3_0, vec3_0, this.magnitude);
            _math.vec3.add(force, force, vec3_0);
        }
    }]);

    return Tw2ParticleAttractorForce;
}(_Tw2ParticleForce2.Tw2ParticleForce);

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleDirectForce = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleForce2 = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ParticleDirectForce
 *
 * @property {vec3} force
 * @inherits Tw2ParticleForce
 * @class
 */
var Tw2ParticleDirectForce = exports.Tw2ParticleDirectForce = function (_Tw2ParticleForce) {
    _inherits(Tw2ParticleDirectForce, _Tw2ParticleForce);

    function Tw2ParticleDirectForce() {
        _classCallCheck(this, Tw2ParticleDirectForce);

        var _this = _possibleConstructorReturn(this, (Tw2ParticleDirectForce.__proto__ || Object.getPrototypeOf(Tw2ParticleDirectForce)).call(this));

        _this.force = _math.vec3.create();
        return _this;
    }

    /**
     * ApplyForce
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     */


    _createClass(Tw2ParticleDirectForce, [{
        key: 'ApplyForce',
        value: function ApplyForce(position, velocity, force) {
            _math.vec3.add(force, force, this.force);
        }
    }]);

    return Tw2ParticleDirectForce;
}(_Tw2ParticleForce2.Tw2ParticleForce);

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleDragForce = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2ParticleForce2 = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ParticleDragForce
 *
 * @property {number} drag
 * @inherits Tw2ParticleForce
 * @class
 */
var Tw2ParticleDragForce = exports.Tw2ParticleDragForce = function (_Tw2ParticleForce) {
    _inherits(Tw2ParticleDragForce, _Tw2ParticleForce);

    function Tw2ParticleDragForce() {
        _classCallCheck(this, Tw2ParticleDragForce);

        var _this = _possibleConstructorReturn(this, (Tw2ParticleDragForce.__proto__ || Object.getPrototypeOf(Tw2ParticleDragForce)).call(this));

        _this.drag = 0.1;
        return _this;
    }

    /**
     * Applies forces
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     */


    _createClass(Tw2ParticleDragForce, [{
        key: 'ApplyForce',
        value: function ApplyForce(position, velocity, force) {
            force[0] += velocity.buffer[velocity.offset] * -this.drag;
            force[1] += velocity.buffer[velocity.offset + 1] * -this.drag;
            force[2] += velocity.buffer[velocity.offset + 2] * -this.drag;
        }
    }]);

    return Tw2ParticleDragForce;
}(_Tw2ParticleForce2.Tw2ParticleForce);

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleFluidDragForce = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleForce2 = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ParticleFluidDragForce
 *
 * @property {number} drag
 * @property {vec3} _tempVec
 * @property {vec3} _tempVec2
 * @inherits Tw2ParticleForce
 * @class
 */
var Tw2ParticleFluidDragForce = exports.Tw2ParticleFluidDragForce = function (_Tw2ParticleForce) {
    _inherits(Tw2ParticleFluidDragForce, _Tw2ParticleForce);

    function Tw2ParticleFluidDragForce() {
        _classCallCheck(this, Tw2ParticleFluidDragForce);

        var _this = _possibleConstructorReturn(this, (Tw2ParticleFluidDragForce.__proto__ || Object.getPrototypeOf(Tw2ParticleFluidDragForce)).call(this));

        _this.drag = 0.1;
        return _this;
    }

    /**
     * Applies forces
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     * @param {number} dt - delta time
     * @param { number} mass
     */


    _createClass(Tw2ParticleFluidDragForce, [{
        key: 'ApplyForce',
        value: function ApplyForce(position, velocity, force, dt, mass) {
            var vec3_0 = _Tw2ParticleForce2.Tw2ParticleForce.global.vec3_0,
                vec3_1 = _Tw2ParticleForce2.Tw2ParticleForce.global.vec3_1,
                speed = Math.sqrt(velocity.buffer[velocity.offset] * velocity.buffer[velocity.offset] + velocity.buffer[velocity.offset + 1] * velocity.buffer[velocity.offset + 1] + velocity.buffer[velocity.offset + 2] * velocity.buffer[velocity.offset + 2]);

            vec3_0[0] = velocity.buffer[velocity.offset] * -speed * this.drag;
            vec3_0[1] = velocity.buffer[velocity.offset + 1] * -speed * this.drag;
            vec3_0[2] = velocity.buffer[velocity.offset + 2] * -speed * this.drag;

            _math.vec3.scale(vec3_1, vec3_0, dt * mass);
            vec3_1[0] += velocity.buffer[velocity.offset];
            vec3_1[1] += velocity.buffer[velocity.offset + 1];
            vec3_1[2] += velocity.buffer[velocity.offset + 2];

            var dot = velocity.buffer[velocity.offset] * vec3_1[0] + velocity.buffer[velocity.offset + 1] * vec3_1[1] + velocity.buffer[velocity.offset + 2] * vec3_1[2];

            if (dot < 0) {
                force[0] = -velocity.buffer[velocity.offset] / dt / mass;
                force[1] = -velocity.buffer[velocity.offset + 1] / dt / mass;
                force[2] = -velocity.buffer[velocity.offset + 2] / dt / mass;
            } else {
                _math.vec3.copy(force, vec3_0);
            }
        }
    }]);

    return Tw2ParticleFluidDragForce;
}(_Tw2ParticleForce2.Tw2ParticleForce);

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleSpring = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleForce2 = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ParticleSpring
 *
 * @property {number} springConstant
 * @property {vec3} position
 * @inherits Tw2ParticleForce
 * @class
 */
var Tw2ParticleSpring = exports.Tw2ParticleSpring = function (_Tw2ParticleForce) {
    _inherits(Tw2ParticleSpring, _Tw2ParticleForce);

    function Tw2ParticleSpring() {
        _classCallCheck(this, Tw2ParticleSpring);

        var _this = _possibleConstructorReturn(this, (Tw2ParticleSpring.__proto__ || Object.getPrototypeOf(Tw2ParticleSpring)).call(this));

        _this.springConstant = 0;
        _this.position = _math.vec3.create();
        return _this;
    }

    /**
     * Applies forces
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     */


    _createClass(Tw2ParticleSpring, [{
        key: 'ApplyForce',
        value: function ApplyForce(position, velocity, force) {
            force[0] += (this.position[0] - position.buffer[position.offset]) * this.springConstant;
            force[1] += (this.position[1] - position.buffer[position.offset + 1]) * this.springConstant;
            force[2] += (this.position[2] - position.buffer[position.offset + 2]) * this.springConstant;
        }
    }]);

    return Tw2ParticleSpring;
}(_Tw2ParticleForce2.Tw2ParticleForce);

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleTurbulenceForce = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleForce2 = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ParticleTurbulenceForce
 *
 * @property {number} noiseLevel
 * @property {number} noiseRatio
 * @property {vec3} amplitude
 * @property {quat} frequency
 * @property {number} _time
 * @inherits Tw2ParticleForce
 * @class
 */
var Tw2ParticleTurbulenceForce = exports.Tw2ParticleTurbulenceForce = function (_Tw2ParticleForce) {
    _inherits(Tw2ParticleTurbulenceForce, _Tw2ParticleForce);

    function Tw2ParticleTurbulenceForce() {
        _classCallCheck(this, Tw2ParticleTurbulenceForce);

        var _this = _possibleConstructorReturn(this, (Tw2ParticleTurbulenceForce.__proto__ || Object.getPrototypeOf(Tw2ParticleTurbulenceForce)).call(this));

        _this.noiseLevel = 3;
        _this.noiseRatio = 0.5;
        _this.amplitude = _math.vec3.fromValues(1, 1, 1);
        _this.frequency = _math.vec4.fromValues(1, 1, 1, 1);
        _this._time = 0;
        return _this;
    }

    /**
     * ApplyForce
     * @param {Tw2ParticleElement} position
     * @param {Tw2ParticleElement} velocity
     * @param {Tw2ParticleElement} force
     */


    _createClass(Tw2ParticleTurbulenceForce, [{
        key: 'ApplyForce',
        value: function ApplyForce(position, velocity, force) {
            if (this.noiseLevel === 0) return;

            var pos_0 = position.buffer[position.offset] * this.frequency[0],
                pos_1 = position.buffer[position.offset + 1] * this.frequency[1],
                pos_2 = position.buffer[position.offset + 2] * this.frequency[2],
                pos_3 = this._time * this.frequency[3];

            var sum = 0,
                power = 0.5,
                frequency = 1 / this.noiseRatio;

            var out = _math.vec4.set(_Tw2ParticleForce2.Tw2ParticleForce.global.vec4_0, 0, 0, 0, 0);

            for (var i = 0; i < this.noiseLevel; ++i) {
                _math.noise.turbulence(out, pos_0, pos_1, pos_2, pos_3, power);
                sum += power;
                pos_0 *= frequency;
                pos_1 *= frequency;
                pos_2 *= frequency;
                pos_3 *= frequency;
                power *= this.noiseRatio;
            }

            force[0] += out[0] * this.amplitude[0] * sum;
            force[1] += out[1] * this.amplitude[1] * sum;
            force[2] += out[2] * this.amplitude[2] * sum;
        }

        /**
         * Per frame update (Called before ApplyForce)
         * @param {number} dt - delta Time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            this._time += dt;
        }
    }]);

    return Tw2ParticleTurbulenceForce;
}(_Tw2ParticleForce2.Tw2ParticleForce);

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2RandomIntegerAttributeGenerator = __webpack_require__(112);

Object.keys(_Tw2RandomIntegerAttributeGenerator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RandomIntegerAttributeGenerator[key];
    }
  });
});

var _Tw2RandomUniformAttributeGenerator = __webpack_require__(113);

Object.keys(_Tw2RandomUniformAttributeGenerator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RandomUniformAttributeGenerator[key];
    }
  });
});

var _Tw2SphereShapeAttributeGenerator = __webpack_require__(114);

Object.keys(_Tw2SphereShapeAttributeGenerator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2SphereShapeAttributeGenerator[key];
    }
  });
});

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2RandomIntegerAttributeGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleElement = __webpack_require__(18);

var _Tw2ParticleAttributeGenerator = __webpack_require__(27);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2RandomIntegerAttributeGenerator
 *
 * @property {number} elementType
 * @property {string} customName
 * @property {vec4} minRange
 * @property {vec4} maxRange
 * @property {Tw2ParticleElement} _element
 * @inherits Tw2ParticleAttributeGenerator
 * @class
 */
var Tw2RandomIntegerAttributeGenerator = exports.Tw2RandomIntegerAttributeGenerator = function (_Tw2ParticleAttribute) {
    _inherits(Tw2RandomIntegerAttributeGenerator, _Tw2ParticleAttribute);

    function Tw2RandomIntegerAttributeGenerator() {
        _classCallCheck(this, Tw2RandomIntegerAttributeGenerator);

        var _this = _possibleConstructorReturn(this, (Tw2RandomIntegerAttributeGenerator.__proto__ || Object.getPrototypeOf(Tw2RandomIntegerAttributeGenerator)).call(this));

        _this.elementType = _Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.CUSTOM;
        _this.customName = '';
        _this.minRange = _math.vec4.create();
        _this.maxRange = _math.vec4.create();
        _this._element = null;
        return _this;
    }

    /**
     * Binds a particle system element to the generator
     * @param {Tw2ParticleSystem} ps
     * @returns {boolean} True if successfully bound
     */


    _createClass(Tw2RandomIntegerAttributeGenerator, [{
        key: 'Bind',
        value: function Bind(ps) {
            for (var i = 0; i < ps._elements.length; ++i) {
                if (ps._elements[i].elementType === this.elementType && (this.elementType !== _Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.CUSTOM || ps._elements[i].customName === this.customName)) {
                    this._element = ps._elements[i];
                    return true;
                }
            }
            return false;
        }

        /**
         * Generates the attributes
         * @param {Tw2ParticleElement} position
         * @param {Tw2ParticleElement} velocity
         * @param {number} index
         */

    }, {
        key: 'Generate',
        value: function Generate(position, velocity, index) {
            for (var i = 0; i < this._element.dimension; ++i) {
                this._element.buffer[this._element.instanceStride * index + this._element.startOffset + i] = Math.floor(this.minRange[i] + Math.random() * (this.maxRange[i] - this.minRange[i]) + 0.5);
            }
        }
    }]);

    return Tw2RandomIntegerAttributeGenerator;
}(_Tw2ParticleAttributeGenerator.Tw2ParticleAttributeGenerator);

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2RandomUniformAttributeGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleElement = __webpack_require__(18);

var _Tw2ParticleAttributeGenerator = __webpack_require__(27);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2RandomUniformAttributeGenerator
 *
 * @property {number} elementType
 * @property {string} customName
 * @property {vec4} minRange
 * @property {vec4} maxRange
 * @property {Tw2ParticleElement} _element
 * @inherits Tw2ParticleAttributeGenerator
 * @class
 */
var Tw2RandomUniformAttributeGenerator = exports.Tw2RandomUniformAttributeGenerator = function (_Tw2ParticleAttribute) {
    _inherits(Tw2RandomUniformAttributeGenerator, _Tw2ParticleAttribute);

    function Tw2RandomUniformAttributeGenerator() {
        _classCallCheck(this, Tw2RandomUniformAttributeGenerator);

        var _this = _possibleConstructorReturn(this, (Tw2RandomUniformAttributeGenerator.__proto__ || Object.getPrototypeOf(Tw2RandomUniformAttributeGenerator)).call(this));

        _this.elementType = _Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.CUSTOM;
        _this.customName = '';
        _this.minRange = _math.vec4.create();
        _this.maxRange = _math.vec4.create();
        _this._element = null;
        return _this;
    }

    /**
     * Binds a particle system element to the generator
     * @param {Tw2ParticleSystem} ps
     * @returns {boolean} True if successfully bound
     */


    _createClass(Tw2RandomUniformAttributeGenerator, [{
        key: 'Bind',
        value: function Bind(ps) {
            for (var i = 0; i < ps._elements.length; ++i) {
                if (ps._elements[i].elementType === this.elementType && (this.elementType !== _Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.CUSTOM || ps._elements[i].customName === this.customName)) {
                    this._element = ps._elements[i];
                    return true;
                }
            }
            return false;
        }

        /**
         * Generates the attributes
         * @param {Tw2ParticleElement} position
         * @param {Tw2ParticleElement} velocity
         * @param {number} index
         */

    }, {
        key: 'Generate',
        value: function Generate(position, velocity, index) {
            for (var i = 0; i < this._element.dimension; ++i) {
                this._element.buffer[this._element.instanceStride * index + this._element.startOffset + i] = this.minRange[i] + Math.random() * (this.maxRange[i] - this.minRange[i]);
            }
        }
    }]);

    return Tw2RandomUniformAttributeGenerator;
}(_Tw2ParticleAttributeGenerator.Tw2ParticleAttributeGenerator);

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2SphereShapeAttributeGenerator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2ParticleElement = __webpack_require__(18);

var _Tw2ParticleAttributeGenerator = __webpack_require__(27);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2SphereShapeAttributeGenerator
 *
 * @property {number} minRadius
 * @property {number} maxRadius
 * @property {number} minPhi
 * @property {number} maxPhi
 * @property {number} minTheta
 * @property {number} maxTheta
 * @property {boolean} controlPosition
 * @property {boolean} controlVelocity
 * @property {number} minSpeed
 * @property {number} maxSpeed
 * @property {number} parentVelocityFactor
 * @property {vec3} position
 * @property {quat} rotation
 * @property {?Tw2ParticleElement} _position
 * @property {?Tw2ParticleElement}_velocity
 * @inherits Tw2ParticleAttributeGenerator
 */
var Tw2SphereShapeAttributeGenerator = exports.Tw2SphereShapeAttributeGenerator = function (_Tw2ParticleAttribute) {
    _inherits(Tw2SphereShapeAttributeGenerator, _Tw2ParticleAttribute);

    function Tw2SphereShapeAttributeGenerator() {
        _classCallCheck(this, Tw2SphereShapeAttributeGenerator);

        var _this = _possibleConstructorReturn(this, (Tw2SphereShapeAttributeGenerator.__proto__ || Object.getPrototypeOf(Tw2SphereShapeAttributeGenerator)).call(this));

        _this.minRadius = 0;
        _this.maxRadius = 0;
        _this.minPhi = 0;
        _this.maxPhi = 360;
        _this.minTheta = 0;
        _this.maxTheta = 360;
        _this.controlPosition = true;
        _this.controlVelocity = true;
        _this.minSpeed = 0;
        _this.maxSpeed = 0;
        _this.parentVelocityFactor = 1;
        _this.position = _math.vec3.create();
        _this.rotation = _math.quat.create();
        _this._position = null;
        _this._velocity = null;
        return _this;
    }

    /**
     * Binds a particle system element to the generator
     * @param {Tw2ParticleSystem} ps
     * @returns {boolean} True if successfully bound
     */


    _createClass(Tw2SphereShapeAttributeGenerator, [{
        key: 'Bind',
        value: function Bind(ps) {
            this._position = null;
            this._velocity = null;

            for (var i = 0; i < ps._elements.length; ++i) {
                if (ps._elements[i].elementType === _Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION && this.controlPosition) {
                    this._position = ps._elements[i];
                } else if (ps._elements[i].elementType === _Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.VELOCITY && this.controlVelocity) {
                    this._velocity = ps._elements[i];
                }
            }
            return (!this.controlPosition || this._position !== null) && (!this.controlVelocity || this._velocity !== null);
        }

        /**
         * Generates the attributes
         * @param {Tw2ParticleElement} position
         * @param {Tw2ParticleElement} velocity
         * @param {number} index
         */

    }, {
        key: 'Generate',
        value: function Generate(position, velocity, index) {
            var phi = (this.minPhi + Math.random() * (this.maxPhi - this.minPhi)) / 180 * Math.PI,
                theta = (this.minTheta + Math.random() * (this.maxTheta - this.minTheta)) / 180 * Math.PI,
                rv = _Tw2ParticleAttributeGenerator.Tw2ParticleAttributeGenerator.global.vec3_0;

            rv[0] = Math.sin(phi) * Math.cos(theta);
            rv[1] = -Math.cos(phi);
            rv[2] = Math.sin(phi) * Math.sin(theta);
            _math.vec3.transformQuat(rv, rv, this.rotation);

            if (this._velocity) {
                var speed = this.minSpeed + Math.random() * (this.maxSpeed - this.minSpeed),
                    offset = this._velocity.instanceStride * index + this._velocity.startOffset;

                this._velocity.buffer[offset] = rv[0] * speed;
                this._velocity.buffer[offset + 1] = rv[1] * speed;
                this._velocity.buffer[offset + 2] = rv[2] * speed;

                if (velocity) {
                    this._velocity.buffer[offset] += velocity.buffer[velocity.offset] * this.parentVelocityFactor;
                    this._velocity.buffer[offset + 1] += velocity.buffer[velocity.offset + 1] * this.parentVelocityFactor;
                    this._velocity.buffer[offset + 2] += velocity.buffer[velocity.offset + 2] * this.parentVelocityFactor;
                }
            }

            if (this._position) {
                _math.vec3.scale(rv, rv, this.minRadius + Math.random() * (this.maxRadius - this.minRadius));
                _math.vec3.add(rv, rv, this.position);

                if (position) {
                    rv[0] += position.buffer[position.offset];
                    rv[1] += position.buffer[position.offset + 1];
                    rv[2] += position.buffer[position.offset + 2];
                }

                var _offset = this._position.instanceStride * index + this._position.startOffset;
                this._position.buffer[_offset] = rv[0];
                this._position.buffer[_offset + 1] = rv[1];
                this._position.buffer[_offset + 2] = rv[2];
            }
        }
    }]);

    return Tw2SphereShapeAttributeGenerator;
}(_Tw2ParticleAttributeGenerator.Tw2ParticleAttributeGenerator);

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ParticleSystem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _Tw2ParticleElement = __webpack_require__(18);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2ParticleSystem
 *
 * @property {number|string} id
 * @property {string} name
 * @property {number} aliveCount
 * @property {number} maxParticleCount
 * @property {*} emitParticleOnDeathEmitter
 * @property {*} emitParticleDuringLifeEmitter
 * @property {Array.<Tw2ParticleElement>} elements
 * @property {boolean} isValid
 * @property {boolean} requiresSorting
 * @property {boolean} updateSimulation
 * @property {boolean} applyForce
 * @property {boolean} applyAging
 * @property {boolean} isGlobal
 * @property {Array<Tw2ParticleForce>} forces
 * @property {Array<Tw2ParticleConstraint>} constraints
 * @property {boolean} updateBoundingBox
 * @property {vec3} aabbMin
 * @property {vec3} aabbMax
 * @property {number} peakAliveCount
 * @property {boolean} bufferDirty
 * @property {WebGLBuffer} _vb
 * @property {Tw2VertexDeclaration} _declaration
 * @property {Array<Tw2ParticleElement>} _stdElements
 * @property {Array<Tw2ParticleElement>} _elements
 * @property {Array} instanceStride
 * @property {Array} vertexStride
 * @property {Array} buffers
 * @class
 */
var Tw2ParticleSystem = exports.Tw2ParticleSystem = function () {
    function Tw2ParticleSystem() {
        _classCallCheck(this, Tw2ParticleSystem);

        this._id = _math.util.generateID();
        this.name = '';
        this.aliveCount = 0;
        this.maxParticleCount = 0;
        this.emitParticleOnDeathEmitter = null;
        this.emitParticleDuringLifeEmitter = null;
        this.elements = [];
        this.isValid = false;
        this.requiresSorting = false;
        this.updateSimulation = true;
        this.applyForce = true;
        this.applyAging = true;
        this.isGlobal = false;
        this.forces = [];
        this.constraints = [];
        this.updateBoundingBox = false;
        this.aabbMin = _math.vec3.create();
        this.aabbMax = _math.vec3.create();
        this.peakAliveCount = 0;

        this.bufferDirty = false;

        this._vb = null;
        this._declaration = null;

        this._stdElements = [null, null, null, null];
        this._elements = [];
        this.instanceStride = [null, null];
        this.vertexStride = [null, null];
        this.buffers = [null, null];

        Tw2ParticleSystem.init();
    }

    /**
     * Initializes the Particle System
     */


    _createClass(Tw2ParticleSystem, [{
        key: 'Initialize',
        value: function Initialize() {
            this.UpdateElementDeclaration();
        }

        /**
         * Updates Element Declarations
         */

    }, {
        key: 'UpdateElementDeclaration',
        value: function UpdateElementDeclaration() {
            this.isValid = false;

            if (this._vb) {
                _core.device.gl.deleteBuffer(this._vb);
                this._vb = null;
            }

            this._declaration = null;
            this.aliveCount = 0;

            if (this.elements.length === 0) return;

            this._stdElements = [null, null, null, null];
            this._elements = [];
            this.instanceStride = [0, 0];
            this.vertexStride = [0, 0];
            this._declaration = new _core.Tw2VertexDeclaration();
            this.buffers = [null, null];

            for (var i = 0; i < this.elements.length; ++i) {
                var bufferIndex = this.elements[i].usedByGPU ? 0 : 1,
                    el = new _Tw2ParticleElement.Tw2ParticleElement(this.elements[i]);
                //el.buffer = this.buffers[bufferIndex];

                el.startOffset = this.vertexStride[bufferIndex];
                el.offset = el.startOffset;
                if (this.elements[i].elementType !== _Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.CUSTOM) {
                    this._stdElements[this.elements[i].elementType] = el;
                }
                this.vertexStride[bufferIndex] += el.dimension;
                this._elements.push(el);
                if (bufferIndex === 0) {
                    var d = this.elements[i].GetDeclaration();
                    d.offset = el.startOffset * 4;
                    this._declaration.elements.push(d);
                }
            }

            this._declaration.RebuildHash();

            for (var _i = 0; _i < this._elements.length; ++_i) {
                var _bufferIndex = this._elements[_i].usedByGPU ? 0 : 1;
                this._elements[_i].vertexStride = this.vertexStride[_bufferIndex];
            }

            this.instanceStride[0] = this.vertexStride[0] * 4;
            this.instanceStride[1] = this.vertexStride[1] * 4;

            for (var _i2 = 0; _i2 < this._elements.length; ++_i2) {
                var _bufferIndex2 = this._elements[_i2].usedByGPU ? 0 : 1;
                this._elements[_i2].instanceStride = this.instanceStride[_bufferIndex2];
            }

            this.buffers = [null, null];
            if (this.instanceStride[0] && this.maxParticleCount) {
                this.buffers[0] = new Float32Array(this.instanceStride[0] * this.maxParticleCount);
                this._vb = _core.device.gl.createBuffer();
                _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._vb);
                _core.device.gl.bufferData(_core.device.gl.ARRAY_BUFFER, this.buffers[0].length, _core.device.gl.DYNAMIC_DRAW);
                _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, null);
            }

            if (this.instanceStride[1]) {
                this.buffers[1] = new Float32Array(this.instanceStride[1] * this.maxParticleCount);
            }

            for (var _i3 = 0; _i3 < this._elements.length; ++_i3) {
                var _bufferIndex3 = this._elements[_i3].usedByGPU ? 0 : 1;
                this._elements[_i3].buffer = this.buffers[_bufferIndex3];
            }

            if (this.requiresSorting) {
                this._sortedIndexes = new Array(this.maxParticleCount);
                this._sortedBuffer = new Float32Array(this.instanceStride[0] * this.maxParticleCount);
                this._distancesBuffer = new Float32Array(this.maxParticleCount);
            }

            this.isValid = true;
            this.bufferDirty = true;
        }

        /**
         * Checks if an element type exists
         * @param {number} type
         * @returns {boolean}
         */

    }, {
        key: 'HasElement',
        value: function HasElement(type) {
            return this._stdElements[type] !== null;
        }

        /**
         * Gets an element by it's type
         * @param {number} type
         * @returns {Tw2ParticleElement}
         */

    }, {
        key: 'GetElement',
        value: function GetElement(type) {
            if (this._stdElements[type]) {
                this._stdElements[type].offset = this._stdElements[type].startOffset;
            }
            return this._stdElements[type];
        }

        /**
         * Begins particle spawning
         * @returns {?number}
         */

    }, {
        key: 'BeginSpawnParticle',
        value: function BeginSpawnParticle() {
            if (!this.isValid || this.aliveCount >= this.maxParticleCount) return null;
            return this.aliveCount++;
        }

        /**
         * Ends particle spawning
         */

    }, {
        key: 'EndSpawnParticle',
        value: function EndSpawnParticle() {
            this.bufferDirty = true;
        }

        /**
         * Per frame update
         * @param {number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            dt = Math.min(dt, 0.1);

            if (this.applyAging && this.HasElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.LIFETIME)) {
                var lifetime = this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.LIFETIME),
                    position = this.emitParticleOnDeathEmitter ? this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION) : null,
                    velocity = this.emitParticleOnDeathEmitter ? this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.VELOCITY) : null;

                for (var i = 0; i < this.aliveCount; ++i) {
                    lifetime.buffer[lifetime.offset] += dt / lifetime.buffer[lifetime.offset + 1];
                    if (lifetime.buffer[lifetime.offset] > 1) {
                        if (this.emitParticleOnDeathEmitter) {
                            this.emitParticleOnDeathEmitter.SpawnParticles(position, velocity, 1);
                        }

                        this.aliveCount--;
                        if (i < this.aliveCount) {
                            for (var j = 0; j < 2; ++j) {
                                if (this.buffers[j]) {
                                    this.buffers[j].set(this.buffers[j].subarray(this.instanceStride[j] * this.aliveCount, this.instanceStride[j] * this.aliveCount + this.instanceStride[j]), i * this.instanceStride[j]);
                                }
                            }
                            --i;
                            this.bufferDirty = true;
                        }
                    } else {
                        lifetime.offset += lifetime.instanceStride;
                        if (position) position.offset += position.instanceStride;
                        if (velocity) velocity.offset += velocity.instanceStride;
                    }
                }
                lifetime.dirty = true;
            }

            var vec3_0 = Tw2ParticleSystem.global.vec3_0;

            if (this.updateSimulation && this.HasElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION) && this.HasElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.VELOCITY)) {
                var hasForces = this.applyForce && this.forces.length;
                for (var _i4 = 0; _i4 < this.forces.length; ++_i4) {
                    this.forces[_i4].Update(dt);
                }

                var _position = this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION),
                    _velocity = this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.VELOCITY),
                    mass = hasForces ? this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.MASS) : null;

                for (var _i5 = 0; _i5 < this.aliveCount; ++_i5) {
                    if (hasForces) {
                        var amass = mass ? mass.buffer[mass.offset] : 1,
                            force = _math.vec3.set(vec3_0, 0, 0, 0);

                        for (var _j = 0; _j < this.forces.length; ++_j) {
                            this.forces[_j].ApplyForce(_position, _velocity, force, dt, amass);
                        }

                        if (mass) _math.vec3.scale(force, force, 1 / mass.buffer[mass.offset]);

                        _velocity.buffer[_velocity.offset] += force[0] * dt;
                        _velocity.buffer[_velocity.offset + 1] += force[1] * dt;
                        _velocity.buffer[_velocity.offset + 2] += force[2] * dt;
                    }

                    _position.buffer[_position.offset] += _velocity.buffer[_velocity.offset] * dt;
                    _position.buffer[_position.offset + 1] += _velocity.buffer[_velocity.offset + 1] * dt;
                    _position.buffer[_position.offset + 2] += _velocity.buffer[_velocity.offset + 2] * dt;

                    if (this.emitParticleDuringLifeEmitter) {
                        this.emitParticleDuringLifeEmitter.SpawnParticles(_position, _velocity, dt);
                    }

                    _position.offset += _position.instanceStride;
                    _velocity.offset += _velocity.instanceStride;

                    if (mass) mass.offset += mass.instanceStride;
                }
                _position.dirty = true;
                _velocity.dirty = true;
            }

            if (this.updateSimulation && this.constraints.length) {
                for (var _i6 = 0; _i6 < this.constraints.length; ++_i6) {
                    this.constraints[_i6].ApplyConstraint(this.buffers, this.instanceStride, this.aliveCount, dt);
                }
            }

            if (this.updateBoundingBox) {
                this.GetBoundingBox(this.aabbMin, this.aabbMax);
            }

            if (this.emitParticleDuringLifeEmitter && !(this.HasElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION) && this.HasElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.VELOCITY)) && this.updateSimulation) {
                var _position2 = this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION),
                    _velocity2 = this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.VELOCITY);

                for (var _i7 = 0; _i7 < this.aliveCount; ++_i7) {
                    this.emitParticleDuringLifeEmitter.SpawnParticles(_position2, _velocity2, 1);
                    if (_position2) _position2.offset += _position2.instanceStride;
                    if (_velocity2) _velocity2.offset += _velocity2.instanceStride;
                }
            }

            for (var _i8 = 0; _i8 < this._elements.length; ++_i8) {
                var el = this._elements[_i8];
                el.offset = el.startOffset;
                if (el.dirty) {
                    this.bufferDirty = true;
                    el.dirty = false;
                }
            }
        }

        /**
         * Gets bounding box
         * @param {vec3} aabbMin
         * @param {vec3} aabbMax
         * @returns {boolean}
         */

    }, {
        key: 'GetBoundingBox',
        value: function GetBoundingBox(aabbMin, aabbMax) {
            if (this.aliveCount && this.HasElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION)) {
                var position = this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION);
                aabbMin[0] = position.buffer[position.offset];
                aabbMin[1] = position.buffer[position.offset + 1];
                aabbMin[2] = position.buffer[position.offset + 2];
                aabbMax[0] = position.buffer[position.offset];
                aabbMax[1] = position.buffer[position.offset + 1];
                aabbMax[2] = position.buffer[position.offset + 2];
                for (var i = 0; i < this.aliveCount; ++i) {
                    aabbMin[0] = Math.min(aabbMin[0], position.buffer[position.offset]);
                    aabbMin[1] = Math.min(aabbMin[1], position.buffer[position.offset + 1]);
                    aabbMin[2] = Math.min(aabbMin[2], position.buffer[position.offset + 2]);
                    aabbMax[0] = Math.max(aabbMax[0], position.buffer[position.offset]);
                    aabbMax[1] = Math.max(aabbMax[1], position.buffer[position.offset + 1]);
                    aabbMax[2] = Math.max(aabbMax[2], position.buffer[position.offset + 2]);
                    position.offset += position.instanceStride;
                }
                return true;
            }
            return false;
        }

        /**
         * _Sort
         * @private
         */

    }, {
        key: '_Sort',
        value: function _Sort() {
            var eye = _math.mat4.multiply(Tw2ParticleSystem.global.mat4_0, _core.device.projection, _core.device.view),
                //device.viewInverse;
            position = this.GetElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION),
                count = this.aliveCount,
                distances = this._distancesBuffer;

            for (var i = 0; i < count; ++i) {
                var o0 = position.offset + position.instanceStride * i;
                var dd = position.buffer[o0] - eye[12],
                    l0 = dd * dd;

                dd = position.buffer[o0 + 1] - eye[13];
                l0 += dd * dd;
                dd = position.buffer[o0 + 2] - eye[14];
                l0 += dd * dd;
                distances[i] = l0;
            }

            /**
             * sortItems
             * @param a
             * @param b
             * @returns {number}
             * @private
             */
            function sortItems(a, b) {
                if (a >= count && b >= count) {
                    if (a < b) return -1;
                    if (a > b) return 1;
                    return 0;
                }

                if (a >= count) return 1;
                if (b >= count) return -1;

                var l0 = distances[a],
                    l1 = distances[b];

                if (l0 < l1) return 1;
                if (l0 > l1) return -1;
                return 0;
            }

            for (var _i9 = 0; _i9 < this.maxParticleCount; ++_i9) {
                this._sortedIndexes[_i9] = _i9;
            }

            this._sortedIndexes.sort(sortItems);
        }

        /**
         * Updates and gets the particle system's InstanceBuffer
         * @returns {?WebGLBuffer}
         */

    }, {
        key: 'GetInstanceBuffer',
        value: function GetInstanceBuffer() {
            if (this.aliveCount === 0) return undefined;

            var d = _core.device;
            if (this.requiresSorting && this.HasElement(_Tw2ParticleElement.Tw2ParticleElementDeclaration.Type.POSITION) && this.buffers) {
                this._Sort();

                var stride = this.instanceStride[0],
                    gpuBuffer = this.buffers[0];

                for (var i = 0; i < this.aliveCount; ++i) {
                    var toOffset = i * stride,
                        fromOffset = this._sortedIndexes[i] * stride;

                    for (var j = 0; j < stride; ++j) {
                        this._sortedBuffer[toOffset + j] = gpuBuffer[j + fromOffset];
                    }
                }

                d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._vb);
                d.gl.bufferSubData(d.gl.ARRAY_BUFFER, 0, this._sortedBuffer.subarray(0, this.vertexStride[0] * this.aliveCount));
                this.bufferDirty = false;
            } else if (this.bufferDirty) {
                d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._vb);
                d.gl.bufferSubData(d.gl.ARRAY_BUFFER, 0, this.buffers[0].subarray(0, this.vertexStride[0] * this.aliveCount));
                this.bufferDirty = false;
            }

            return this._vb;
        }

        /**
         * Gets the particle system's InstanceDeclaration
         * @returns {Tw2VertexDeclaration}
         */

    }, {
        key: 'GetInstanceDeclaration',
        value: function GetInstanceDeclaration() {
            return this._declaration;
        }

        /**
         * Gets the particle system's InstanceStride
         * @returns {number}
         */

    }, {
        key: 'GetInstanceStride',
        value: function GetInstanceStride() {
            return this.instanceStride[0];
        }

        /**
         * Gets the particle system's InstanceCount
         * @returns {number}
         */

    }, {
        key: 'GetInstanceCount',
        value: function GetInstanceCount() {
            return this.aliveCount;
        }

        /**
         * Initializes class globals
         */

    }], [{
        key: 'init',
        value: function init() {
            if (!Tw2ParticleSystem.global) {
                Tw2ParticleSystem.global = {
                    vec3_0: _math.vec3.create(),
                    mat4_0: _math.mat4.create()
                };
            }
        }
    }]);

    return Tw2ParticleSystem;
}();

/**
 * Class globals
 */


Tw2ParticleSystem.global = null;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2VariableStore = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _index = __webpack_require__(24);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2VariableStore
 * @property {Object.< string, Parameter>} _variables
 * @constructor
 */
var Tw2VariableStore = exports.Tw2VariableStore = function () {
    function Tw2VariableStore() {
        _classCallCheck(this, Tw2VariableStore);

        this._variables = {};
    }

    /**
     * Registers a variable
     * @param {string} name
     * @param {string|number|Float32Array|vec3|mat4} value
     * @param {Parameter} type
     * @returns {Parameter}
     * @constructor
     */


    _createClass(Tw2VariableStore, [{
        key: 'RegisterVariableWithType',
        value: function RegisterVariableWithType(name, value, type) {
            return this._variables[name] = new type(name, value);
        }

        /**
         * Registers a variable without a value
         * @param {string} name
         * @param {Parameter} type
         * @returns {Parameter}
         * @constructor
         */

    }, {
        key: 'RegisterType',
        value: function RegisterType(name, type) {
            return this._variables[name] = new type(name);
        }

        /**
         * Registers a variable without a type
         * @param {string} name
         * @param {string|number|Float32Array} value
         * @returns {Parameter}
         */

    }, {
        key: 'RegisterVariable',
        value: function RegisterVariable(name, value) {
            var Type = Tw2VariableStore.GetTw2ParameterType(value);
            return Type ? this.RegisterVariableWithType(name, value, Type) : null;
        }

        /**
         * Gets A Tw2 parameter constructor from a supplied value
         * @param {Number|String|Array.<Number>|Float32Array} value
         * @returns {null|Parameter}
         */

    }], [{
        key: 'GetTw2ParameterType',
        value: function GetTw2ParameterType(value) {
            if (_math.util.isArrayLike(value)) {
                switch (value.length) {
                    case 16:
                        return _index.Tw2MatrixParameter;

                    case 4:
                        return _index.Tw2Vector4Parameter;

                    case 3:
                        return _index.Tw2Vector3Parameter;

                    case 2:
                        return _index.Tw2Vector2Parameter;

                    case 1:
                        return _index.Tw2FloatParameter;
                }
            } else if (typeof value === 'number') {
                return _index.Tw2FloatParameter;
            } else if (typeof value === 'string') {
                return _index.Tw2TextureParameter;
            }
        }
    }]);

    return Tw2VariableStore;
}();

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2BlendShapeData = undefined;

var _vertex = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2BlendShapeData
 *
 * @property {String} name
 * @property {Tw2VertexDeclaration} declaration
 * @property {Array} buffers
 * @property indexes
 * @property weightProxy
 */
var Tw2BlendShapeData = exports.Tw2BlendShapeData = function Tw2BlendShapeData() {
    _classCallCheck(this, Tw2BlendShapeData);

    this.name = '';
    this.declaration = new _vertex.Tw2VertexDeclaration();
    this.buffers = [];
    this.indexes = null;
    this.weightProxy = null;
};

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2GeometryAnimation
 *
 * @property {string} name
 * @property {number} duration
 * @property {Array.<Tw2GeometryTrackGroup>} trackGroups
 */
var Tw2GeometryAnimation = exports.Tw2GeometryAnimation = function Tw2GeometryAnimation() {
    _classCallCheck(this, Tw2GeometryAnimation);

    this.name = '';
    this.duration = 0;
    this.trackGroups = [];
};

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2GeometryBone = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2GeometryBone
 *
 * @property {string} name
 * @property {number} parentIndex
 * @property {vec3} position
 * @property {quat} orientation
 * @property {mat3} scaleShear
 * @property {mat4} localTransform
 * @property {mat4} worldTransform
 * @property {mat4} worldTransformInv
 */
var Tw2GeometryBone = exports.Tw2GeometryBone = function () {
    function Tw2GeometryBone() {
        _classCallCheck(this, Tw2GeometryBone);

        this.name = '';
        this.parentIndex = -1;
        this.position = _math.vec3.create();
        this.orientation = _math.quat.create();
        this.scaleShear = _math.mat3.create();
        this.localTransform = _math.mat4.create();
        this.worldTransform = _math.mat4.create();
        this.worldTransformInv = _math.mat4.create();
    }

    /**
     * Updates the Bone's transform
     * @returns {mat4}
     */


    _createClass(Tw2GeometryBone, [{
        key: 'UpdateTransform',
        value: function UpdateTransform() {
            _math.mat4.fromMat3(this.localTransform, this.scaleShear);
            _math.quat.normalize(this.orientation, this.orientation);
            var rm = _math.mat4.fromQuat(Tw2GeometryBone.global.mat4_0, this.orientation);
            _math.mat4.multiply(this.localTransform, this.localTransform, rm);
            this.localTransform[12] = this.position[0];
            this.localTransform[13] = this.position[1];
            this.localTransform[14] = this.position[2];
            return this.localTransform;
        }
    }]);

    return Tw2GeometryBone;
}();

/**
 * Class global variables and scratch
 */


Tw2GeometryBone.global = {
    mat4_0: _math.mat4.create()
};

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2GeometryCurve
 *
 * @property {number} dimension
 * @property {number} degree
 * @property {Float32Array} knots
 * @property {Float32Array} controls
 */
var Tw2GeometryCurve = exports.Tw2GeometryCurve = function Tw2GeometryCurve() {
    _classCallCheck(this, Tw2GeometryCurve);

    this.dimension = 0;
    this.degree = 0;
    this.knots = null;
    this.controls = null;
};

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2GeometryMesh = undefined;

var _math = __webpack_require__(0);

var _vertex = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2GeometryMesh
 *
 * @property {string} name
 * @property {Tw2VertexDeclaration} declaration
 * @property {Array.<Tw2GeometryMeshArea>} areas
 * @property {WebGLBuffer} buffer
 * @property {number} bufferLength
 * @property bufferData
 * @property {WebGLBuffer} indexes
 * @property indexData
 * @property {number} indexType
 * @property {vec3} minBounds
 * @property {vec3} maxBounds
 * @property {vec3} boundsSpherePosition
 * @property {number} boundsSphereRadius
 * @property {Array} bones
 * @property {Array.<string>} boneBindings
 */
var Tw2GeometryMesh = exports.Tw2GeometryMesh = function Tw2GeometryMesh() {
    _classCallCheck(this, Tw2GeometryMesh);

    this.name = '';
    this.declaration = new _vertex.Tw2VertexDeclaration();
    this.areas = [];
    this.buffer = null;
    this.bufferLength = 0;
    this.bufferData = null;
    this.indexes = null;
    this.indexData = null;
    this.indexType = 0;
    this.minBounds = _math.vec3.create();
    this.maxBounds = _math.vec3.create();
    this.boundsSpherePosition = _math.vec3.create();
    this.boundsSphereRadius = 0;
    this.bones = [];
    this.boneBindings = [];
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2GeometryMeshArea = undefined;

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2GeometryMeshArea
 *
 * @property {string} name
 * @property {number} start
 * @property {number} count
 * @property {vec3} minBounds
 * @property {vec3} maxBounds
 * @property {vec3} boundsSpherePosition
 * @property {number} boundsSphereRadius
 */
var Tw2GeometryMeshArea = exports.Tw2GeometryMeshArea = function Tw2GeometryMeshArea() {
    _classCallCheck(this, Tw2GeometryMeshArea);

    this.name = '';
    this.start = 0;
    this.count = 0;
    this.minBounds = _math.vec3.create();
    this.maxBounds = _math.vec3.create();
    this.boundsSpherePosition = _math.vec3.create();
    this.boundsSphereRadius = 0;
};

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2GeometryMeshBinding
 *
 * @property {Tw2GeometryMesh} mesh
 * @property {Array.<Tw2GeometryBone>} bones
 */
var Tw2GeometryMeshBinding = exports.Tw2GeometryMeshBinding = function Tw2GeometryMeshBinding() {
    _classCallCheck(this, Tw2GeometryMeshBinding);

    this.mesh = null;
    this.bones = [];
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2GeometryModel
 *
 * @property {string} name
 * @property {Array.<Tw2GeometryMeshBinding>} meshBindings
 * @property {Tw2GeometrySkeleton} skeleton
 */
var Tw2GeometryModel = exports.Tw2GeometryModel = function () {
    function Tw2GeometryModel() {
        _classCallCheck(this, Tw2GeometryModel);

        this.name = '';
        this.meshBindings = [];
        this.skeleton = null;
    }

    /**
     * Finds a bone by it's name
     * @param {string} name
     * @returns {Tw2GeometryBone|null}
     */


    _createClass(Tw2GeometryModel, [{
        key: 'FindBoneByName',
        value: function FindBoneByName(name) {
            if (!this.skeleton) {
                return null;
            }

            for (var i = 0; i < this.skeleton.bones.length; ++i) {
                if (this.skeleton.bones[i].name === name) {
                    return this.skeleton.bones[i];
                }
            }

            return null;
        }
    }]);

    return Tw2GeometryModel;
}();

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2GeometrySkeleton
 *
 * @property {Array.<Tw2GeometryBone>} bones
 */
var Tw2GeometrySkeleton = exports.Tw2GeometrySkeleton = function Tw2GeometrySkeleton() {
    _classCallCheck(this, Tw2GeometrySkeleton);

    this.bones = [];
};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2GeometryTrackGroup
 *
 * @property {string} name
 * @property {Tw2GeometryModel} model
 * @property {Array.<Tw2GeometryTransformTrack>} transformTracks
 */
var Tw2GeometryTrackGroup = exports.Tw2GeometryTrackGroup = function Tw2GeometryTrackGroup() {
    _classCallCheck(this, Tw2GeometryTrackGroup);

    this.name = '';
    this.model = null;
    this.transformTracks = [];
};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2GeometryTransformTrack
 *
 * @property {string} name
 * @property {Tw2GeometryCurve} position
 * @property {Tw2GeometryCurve} orientation
 * @property scaleShear
 */
var Tw2GeometryTransformTrack = exports.Tw2GeometryTransformTrack = function Tw2GeometryTransformTrack() {
    _classCallCheck(this, Tw2GeometryTransformTrack);

    this.name = '';
    this.position = null;
    this.orientation = null;
    this.scaleShear = null;
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2InstancedMesh = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Tw2ResMan = __webpack_require__(6);

var _math = __webpack_require__(0);

var _batch = __webpack_require__(20);

var _Tw2Mesh2 = __webpack_require__(48);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2InstancedMesh
 *
 * @property instanceGeometryResource
 * @property {string} instanceGeometryResPath
 * @property {number} instanceMeshIndex
 * @property {vec3} minBounds
 * @property {vec3} maxBounds
 * @class
 */
var Tw2InstancedMesh = exports.Tw2InstancedMesh = function (_Tw2Mesh) {
    _inherits(Tw2InstancedMesh, _Tw2Mesh);

    function Tw2InstancedMesh() {
        _classCallCheck(this, Tw2InstancedMesh);

        var _this = _possibleConstructorReturn(this, (Tw2InstancedMesh.__proto__ || Object.getPrototypeOf(Tw2InstancedMesh)).call(this));

        _this.instanceGeometryResource = null;
        _this.instanceGeometryResPath = '';
        _this.instanceMeshIndex = 0;
        _this.minBounds = _math.vec3.create();
        _this.maxBounds = _math.vec3.create();
        return _this;
    }

    /**
     * Initializes the instanced mesh
     */


    _createClass(Tw2InstancedMesh, [{
        key: 'Initialize',
        value: function Initialize() {
            _get(Tw2InstancedMesh.prototype.__proto__ || Object.getPrototypeOf(Tw2InstancedMesh.prototype), 'Initialize', this).call(this);
            if (this.instanceGeometryResPath !== '') {
                this.instanceGeometryResource = _Tw2ResMan.resMan.GetResource(this.instanceGeometryResPath);
            }
        }

        /**
         * Checks if the instances meshes' resources are good
         * @returns {boolean}
         */

    }, {
        key: 'IsGood',
        value: function IsGood() {
            var instanced = this.instanceGeometryResource,
                isResGood = _get(Tw2InstancedMesh.prototype.__proto__ || Object.getPrototypeOf(Tw2InstancedMesh.prototype), 'IsGood', this).call(this),
                isInstancedResGood = !instanced ? false : instanced.IsGood ? instanced.IsGood() : true;

            return isResGood && isInstancedResGood;
        }

        /**
         * Gets mesh resources
         * @param {Array} [out=[]] - Optional receiving array
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            _get(Tw2InstancedMesh.prototype.__proto__ || Object.getPrototypeOf(Tw2InstancedMesh.prototype), 'GetResources', this).call(this, out);
            if (this.instanceGeometryResource && 'GetResources' in this.instanceGeometryResource) {
                this.instanceGeometryResource.GetResources(out);
            }
            return out;
        }

        /**
         * RenderAreas
         * @param {number} meshIx
         * @param {number} start
         * @param {number} count
         * @param {Tw2Effect} effect
         * @param {string} technique
         */

    }, {
        key: 'RenderAreas',
        value: function RenderAreas(meshIx, start, count, effect, technique) {
            if (!this.IsGood()) return;

            var buffer = this.instanceGeometryResource.GetInstanceBuffer(this.instanceMeshIndex);
            if (buffer) {
                this.geometryResource.RenderAreasInstanced(meshIx, start, count, effect, technique, buffer, this.instanceGeometryResource.GetInstanceDeclaration(this.instanceMeshIndex), this.instanceGeometryResource.GetInstanceStride(this.instanceMeshIndex), this.instanceGeometryResource.GetInstanceCount(this.instanceMeshIndex));
            }
        }

        /**
         * Gets area batches
         * @param {Tw2InstancedMesh} mesh
         * @param {Array.<Tw2MeshArea>} areas
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }], [{
        key: 'GetAreaBatches',
        value: function GetAreaBatches(mesh, areas, mode, accumulator, perObjectData) {
            for (var i = 0; i < areas.length; ++i) {
                var area = areas[i];
                if (area.effect && area.display) {
                    var batch = new _batch.Tw2InstancedMeshBatch();
                    batch.renderMode = mode;
                    batch.perObjectData = perObjectData;
                    batch.instanceMesh = mesh;
                    batch.meshIx = area.meshIndex;
                    batch.start = area.index;
                    batch.count = area.count;
                    batch.effect = area.effect;
                    accumulator.Commit(batch);
                }
            }
        }
    }]);

    return Tw2InstancedMesh;
}(_Tw2Mesh2.Tw2Mesh);

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2MeshLineArea = undefined;

var _batch = __webpack_require__(20);

var _Tw2MeshArea2 = __webpack_require__(49);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2MeshLineArea
 *
 * @class
 */
var Tw2MeshLineArea = exports.Tw2MeshLineArea = function (_Tw2MeshArea) {
  _inherits(Tw2MeshLineArea, _Tw2MeshArea);

  function Tw2MeshLineArea() {
    _classCallCheck(this, Tw2MeshLineArea);

    return _possibleConstructorReturn(this, (Tw2MeshLineArea.__proto__ || Object.getPrototypeOf(Tw2MeshLineArea)).call(this));
  }

  return Tw2MeshLineArea;
}(_Tw2MeshArea2.Tw2MeshArea);

/**
 * Render Batch Constructor
 * @type {Tw2RenderBatch}
 */


Tw2MeshLineArea.batchType = _batch.Tw2GeometryLineBatch;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2Animation = __webpack_require__(50);

Object.keys(_Tw2Animation).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Animation[key];
    }
  });
});

var _Tw2AnimationController = __webpack_require__(132);

Object.keys(_Tw2AnimationController).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2AnimationController[key];
    }
  });
});

var _Tw2Bone = __webpack_require__(52);

Object.keys(_Tw2Bone).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Bone[key];
    }
  });
});

var _Tw2Model = __webpack_require__(53);

Object.keys(_Tw2Model).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Model[key];
    }
  });
});

var _Tw2Track = __webpack_require__(54);

Object.keys(_Tw2Track).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2Track[key];
    }
  });
});

var _Tw2TrackGroup = __webpack_require__(55);

Object.keys(_Tw2TrackGroup).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2TrackGroup[key];
    }
  });
});

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2AnimationController = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _resource = __webpack_require__(28);

var _Tw2Animation = __webpack_require__(50);

var _Tw2Bone = __webpack_require__(52);

var _Tw2Model = __webpack_require__(53);

var _Tw2Track = __webpack_require__(54);

var _Tw2TrackGroup = __webpack_require__(55);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2AnimationController
 *
 * @param {Tw2GeometryRes} [geometryResource]
 * @property {Array.<Tw2GeometryRes>} geometryResources
 * @property {Array.<Tw2Model>} models
 * @property {Array.<Tw2Animation>} animations
 * @property {Array} meshBindings
 * @property {boolean} loaded
 * @property {boolean} update
 * @property _geometryResource
 * @property {Array} pendingCommands
 * @property {Function} [onLoaded] an optional callback fired when any commands are cleared
 * @class
 */
var Tw2AnimationController = exports.Tw2AnimationController = function () {
    function Tw2AnimationController(geometryResource) {
        _classCallCheck(this, Tw2AnimationController);

        this.geometryResources = [];
        this.models = [];
        this.animations = [];
        this.meshBindings = [];
        this.loaded = false;
        this.update = true;
        this.pendingCommands = [];
        this.onPendingCleared = null;
        this._geometryResource = null;

        if (geometryResource) {
            this.SetGeometryResource(geometryResource);
        }
    }

    /**
     * Gets a loaded Tw2Animation by it's name
     * @returns {?{ string: Tw2Animation}} an object containing animation names and animations, or null if not loaded
     */


    _createClass(Tw2AnimationController, [{
        key: 'GetAnimationsByName',
        value: function GetAnimationsByName() {
            if (!this.loaded) return null;

            var animations = {};
            for (var i = 0; i < this.animations.length; i++) {
                animations[this.animations[i].animationRes.name] = this.animations[i];
            }
            return animations;
        }

        /**
         * Gets a loaded Tw2Animation by it's name
         * @param {String} name
         * @returns {?Tw2Animation} Returns the animation if found
         */

    }, {
        key: 'GetAnimation',
        value: function GetAnimation(name) {
            for (var i = 0; i < this.animations.length; i++) {
                if (this.animations[i].animationRes.name === name) {
                    return this.animations[i];
                }
            }
            return null;
        }

        /**
         * Resets a Tw2Animation by it's name
         * @param {String} name
         * @return {boolean}
         */

    }, {
        key: 'ResetAnimation',
        value: function ResetAnimation(name) {
            var animation = this.GetAnimation(name);
            if (animation) {
                animation.time = 0;
                animation.isPlaying = false;
                animation.callback = null;
                return true;
            }
        }

        /**
         * Plays a specific animation by it's name
         * @param {string} name - Animation's Name
         * @param {boolean} [cycle]
         * @param {Function} [callback] - Optional callback which is fired once the animation has completed
         * @return {boolean}
         */

    }, {
        key: 'PlayAnimation',
        value: function PlayAnimation(name, cycle, callback) {
            if (this.animations.length === 0) {
                this.pendingCommands.push({
                    'func': this.PlayAnimation,
                    'args': [name, cycle, callback]
                });
                return true;
            }

            var animation = this.GetAnimation(name);
            if (animation) {
                animation.time = 0;
                animation.isPlaying = true;

                if (typeof cycle !== 'undefined') {
                    animation.cycle = cycle;
                }

                if (callback) {
                    animation.callback = callback;
                }

                return true;
            }
        }

        /**
         * Plays a specific animation from a specific time
         * @param {string} name - Animation's Name
         * @param {number} from - Time to play from
         * @param {boolean} [cycle]
         * @param {Function} [callback] - Optional callback which is fired once the animation has completed
         * @returns {boolean}
         */

    }, {
        key: 'PlayAnimationFrom',
        value: function PlayAnimationFrom(name, from, cycle, callback) {
            if (this.animations.length === 0) {
                this.pendingCommands.push({
                    'func': this.PlayAnimationFrom,
                    'args': [name, from, cycle, callback]
                });
                return true;
            }

            var animation = this.GetAnimation(name);
            if (animation) {
                animation.time = Math.max(Math.min(from, animation.animationRes.duration), 0);
                animation.isPlaying = true;

                if (typeof cycle !== 'undefined') {
                    animation.cycle = cycle;
                }

                if (callback) {
                    animation.callback = callback;
                }

                return true;
            }
        }

        /**
         * Gets an array of all the currently playing animations by name
         * @returns {Array}
         */

    }, {
        key: 'GetPlayingAnimations',
        value: function GetPlayingAnimations() {
            var result = [];
            for (var i = 0; i < this.animations.length; i++) {
                if (this.animations[i].isPlaying) {
                    result.push(this.animations[i].animationRes.name);
                }
            }
            return result;
        }

        /**
         * Stops an animation or an array of animations from playing
         * @param {String| Array.<string>} names - Animation Name, or Array of Animation Names
         */

    }, {
        key: 'StopAnimation',
        value: function StopAnimation(names) {
            if (this.animations.length === 0) {
                this.pendingCommands.push({
                    'func': this.StopAnimation,
                    'args': names
                });
                return;
            }

            if (typeof names === 'string' || names instanceof String) {
                names = [names];
            }

            var toStop = {};
            for (var n = 0; n < names.length; n++) {
                toStop[names[n]] = true;
            }

            for (var i = 0; i < this.animations.length; ++i) {
                if (this.animations[i].animationRes.name in toStop) {
                    this.animations[i].isPlaying = false;
                }
            }
        }

        /**
         * Stops all animations from playing
         */

    }, {
        key: 'StopAllAnimations',
        value: function StopAllAnimations() {
            if (this.animations.length === 0) {
                this.pendingCommands.push({
                    'func': this.StopAllAnimations,
                    'args': null
                });
                return;
            }

            for (var i = 0; i < this.animations.length; ++i) {
                this.animations[i].isPlaying = false;
            }
        }

        /**
         * Stops all but the supplied list of animations
         * @param {String| Array.<string>} names - Animation Names
         */

    }, {
        key: 'StopAllAnimationsExcept',
        value: function StopAllAnimationsExcept(names) {
            if (this.animations.length === 0) {
                this.pendingCommands.push({
                    'func': this.StopAllAnimationsExcept,
                    'args': names
                });
                return;
            }

            if (typeof names === 'string' || names instanceof String) {
                names = [names];
            }

            var keepAnimating = {};
            for (var n = 0; n < names.length; n++) {
                keepAnimating[names[n]] = true;
            }

            for (var i = 0; i < this.animations.length; ++i) {
                if (!(this.animations[i].animationRes.name in keepAnimating)) {
                    this.animations[i].isPlaying = false;
                }
            }
        }

        /**
         * Clears any existing resources and loads the supplied geometry resource
         * @param {Tw2GeometryRes} geometryResource
         */

    }, {
        key: 'SetGeometryResource',
        value: function SetGeometryResource(geometryResource) {
            this.models = [];
            this.animations = [];
            this.meshBindings = [];

            for (var i = 0; i < this.geometryResources.length; ++i) {
                this.geometryResources[i].UnregisterNotification(this);
            }

            this.loaded = false;
            this.geometryResources = [];

            if (geometryResource) {
                this.geometryResources.push(geometryResource);
                geometryResource.RegisterNotification(this);
            }
        }

        /**
         * Adds a Geometry Resource
         * @param {Tw2GeometryRes} geometryResource
         */

    }, {
        key: 'AddGeometryResource',
        value: function AddGeometryResource(geometryResource) {
            for (var i = 0; i < this.geometryResources.length; ++i) {
                if (this.geometryResources[i] === geometryResource) {
                    return;
                }
            }
            this.geometryResources.push(geometryResource);
            geometryResource.RegisterNotification(this);
        }

        /**
         * Adds animations from a resource
         * @param {Tw2GeometryRes} resource
         */

    }, {
        key: 'AddAnimationsFromRes',
        value: function AddAnimationsFromRes(resource) {
            for (var i = 0; i < resource.animations.length; ++i) {
                var animation = null;
                for (var j = 0; j < this.animations.length; ++j) {
                    if (this.animations[j].animationRes === resource.animations[i]) {
                        animation = this.animations[i];
                        break;
                    }
                }

                if (!animation) {
                    animation = new _Tw2Animation.Tw2Animation();
                    animation.animationRes = resource.animations[i];
                    this.animations.push(animation);
                }

                for (var _j = 0; _j < animation.animationRes.trackGroups.length; ++_j) {
                    var found = false;
                    for (var k = 0; k < animation.trackGroups.length; ++k) {
                        if (animation.trackGroups[k].trackGroupRes === animation.animationRes.trackGroups[_j]) {
                            found = true;
                            break;
                        }
                    }

                    if (found) {
                        continue;
                    }

                    var model = null;
                    for (var _k = 0; _k < this.models.length; ++_k) {
                        if (this.models[_k].modelRes.name === animation.animationRes.trackGroups[_j].name) {
                            model = this.models[_k];
                            break;
                        }
                    }

                    if (model !== null) {
                        var group = new _Tw2TrackGroup.Tw2TrackGroup();
                        group.trackGroupRes = animation.animationRes.trackGroups[_j];
                        for (var _k2 = 0; _k2 < group.trackGroupRes.transformTracks.length; ++_k2) {
                            for (var m = 0; m < model.bones.length; ++m) {
                                if (model.bones[m].boneRes.name === group.trackGroupRes.transformTracks[_k2].name) {
                                    var track = new _Tw2Track.Tw2Track();
                                    track.trackRes = group.trackGroupRes.transformTracks[_k2];
                                    track.bone = model.bones[m];
                                    group.transformTracks.push(track);
                                    break;
                                }
                            }
                        }
                        animation.trackGroups.push(group);
                    }
                }
            }
        }

        /**
         * Resets the bone transforms
         */

    }, {
        key: 'ResetBoneTransforms',
        value: function ResetBoneTransforms() {
            for (var i = 0; i < this.models.length; ++i) {
                for (var j = 0; j < this.models[i].bones.length; ++j) {
                    var bone = this.models[i].bones[j],
                        boneRes = bone.boneRes;

                    _math.mat4.copy(bone.localTransform, boneRes.localTransform);

                    if (boneRes.parentIndex !== -1) {
                        _math.mat4.multiply(bone.worldTransform, bone.localTransform, this.models[i].bones[bone.boneRes.parentIndex].worldTransform);
                    } else {
                        _math.mat4.set(bone.worldTransform, bone.localTransform);
                    }
                    _math.mat4.identity(bone.offsetTransform);
                }
            }

            var id = _math.mat4.identity(Tw2AnimationController.scratch.mat4_0);
            for (var _i = 0; _i < this.meshBindings.length; ++_i) {
                for (var _j2 = 0; _j2 < this.meshBindings[_i].length; ++_j2) {
                    for (var k = 0; k * 16 < this.meshBindings[_i][_j2].length; ++k) {
                        for (var m = 0; m < 16; ++m) {
                            this.meshBindings[_i][_j2][k * 16 + m] = id[m];
                        }
                    }
                }
            }
        }

        /**
         * GetBoneMatrices
         * @param {number} meshIndex
         * @param {Tw2GeometryRes} [geometryResource=this.geometryResources[0]]
         * @returns {Float32Array}
         */

    }, {
        key: 'GetBoneMatrices',
        value: function GetBoneMatrices(meshIndex, geometryResource) {
            if (this.geometryResources.length === 0) {
                return new Float32Array();
            }

            if (!geometryResource) {
                geometryResource = this.geometryResources[0];
            }

            var meshBindings = Tw2AnimationController.FindMeshBindings(this, geometryResource);
            if (meshBindings && meshIndex < meshBindings.length) {
                return meshBindings[meshIndex];
            }
            return new Float32Array();
        }

        /**
         * FindModelForMesh
         * @param {number} meshIndex
         * @param {Tw2GeometryRes} [geometryResource=this.geometryResources[0]]
         * @returns {Tw2Model|null} Returns the Tw2Model for the mesh if found and is good, else returns null
         */

    }, {
        key: 'FindModelForMesh',
        value: function FindModelForMesh(meshIndex, geometryResource) {
            if (this.geometryResources.length === 0) {
                return null;
            }

            if (!geometryResource) {
                geometryResource = this.geometryResources[0];
            }

            if (!geometryResource.IsGood()) {
                return null;
            }

            var mesh = geometryResource.meshes[meshIndex];
            for (var i = 0; i < this.models.length; ++i) {
                for (var j = 0; j < this.models[i].modelRes.meshBindings.length; ++i) {
                    if (this.models[i].modelRes.meshBindings[j].mesh === mesh) {
                        return this.models[i];
                    }
                }
            }
            return null;
        }

        /**
         * Gets all animation controller res objects
         * @param {Array} [out=[]] - Optional receiving array
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            for (var i = 0; i < this.geometryResources.length; i++) {
                if (!out.includes(this.geometryResources[i])) {
                    out.push(this.geometryResources[i]);
                }
            }
            return out;
        }

        /**
         * Rebuilds the cached data for a resource (unless it doesn't exist or is already good)
         * @param {Tw2GeometryRes} resource
         */

    }, {
        key: 'RebuildCachedData',
        value: function RebuildCachedData(resource) {
            var found = false;
            for (var i = 0; i < this.geometryResources.length; ++i) {
                if (this.geometryResources[i] === resource) {
                    found = true;
                    break;
                }
            }

            if (!found) {
                return;
            }

            for (var _i2 = 0; _i2 < this.geometryResources.length; ++_i2) {
                if (!this.geometryResources[_i2].IsGood()) {
                    return;
                }
            }

            for (var _i3 = 0; _i3 < this.geometryResources.length; ++_i3) {
                Tw2AnimationController.DoRebuildCachedData(this, this.geometryResources[_i3]);
            }
        }

        /**
         * Internal render/update function which is called every frame
         * @param {number} dt - Delta Time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            if (!this.models || !this.update) {
                return;
            }

            for (var i = 0; i < this.geometryResources.length; ++i) {
                this.geometryResources[i].KeepAlive();
            }

            var g = Tw2AnimationController.scratch,
                rotationMat = g.mat4_0,
                orientation = g.quat_0,
                position = g.vec3_0,
                scale = g.mat3_0;

            //var updateBones = false;
            for (var _i4 = 0; _i4 < this.animations.length; ++_i4) {
                var animation = this.animations[_i4];
                if (animation.isPlaying) {
                    var res = animation.animationRes;
                    animation.time += dt * animation.timeScale;
                    if (animation.time > res.duration) {
                        if (animation.callback) {
                            animation.callback(this, animation);
                        }

                        if (animation.cycle) {
                            animation.time = animation.time % res.duration;
                        } else {
                            animation.isPlaying = false;
                            animation.time = res.duration;
                        }
                    }

                    for (var j = 0; j < animation.trackGroups.length; ++j) {
                        for (var k = 0; k < animation.trackGroups[j].transformTracks.length; ++k) {
                            var track = animation.trackGroups[j].transformTracks[k];
                            if (track.trackRes.position) {
                                _math.curve.evaluate(track.trackRes.position, animation.time, position, animation.cycle, res.duration);
                            } else {
                                position[0] = position[1] = position[2] = 0;
                            }
                            if (track.trackRes.orientation) {
                                _math.curve.evaluate(track.trackRes.orientation, animation.time, orientation, animation.cycle, res.duration);
                                _math.quat.normalize(orientation, orientation);
                            } else {
                                _math.quat.identity(orientation);
                            }
                            if (track.trackRes.scaleShear) {
                                _math.curve.evaluate(track.trackRes.scaleShear, animation.time, scale, animation.cycle, res.duration);
                            } else {
                                _math.mat3.identity(scale);
                            }

                            _math.mat4.fromMat3(track.bone.localTransform, scale);
                            _math.mat4.multiply(track.bone.localTransform, track.bone.localTransform, _math.mat4.fromQuat(rotationMat, orientation));
                            track.bone.localTransform[12] = position[0];
                            track.bone.localTransform[13] = position[1];
                            track.bone.localTransform[14] = position[2];
                        }
                    }
                }
            }

            for (var _i5 = 0; _i5 < this.models.length; ++_i5) {
                for (var _j3 = 0; _j3 < this.models[_i5].bones.length; ++_j3) {
                    var bone = this.models[_i5].bones[_j3];
                    if (bone.boneRes.parentIndex !== -1) {
                        _math.mat4.multiply(bone.worldTransform, this.models[_i5].bones[bone.boneRes.parentIndex].worldTransform, bone.localTransform);
                    } else {
                        _math.mat4.copy(bone.worldTransform, bone.localTransform);
                    }
                    _math.mat4.multiply(bone.offsetTransform, bone.worldTransform, bone.boneRes.worldTransformInv);
                    if (bone.bindingArrays) {
                        for (var a = 0; a < bone.bindingArrays.length; ++a) {
                            bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 0] = bone.offsetTransform[0];
                            bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 1] = bone.offsetTransform[4];
                            bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 2] = bone.offsetTransform[8];
                            bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 3] = bone.offsetTransform[12];

                            bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 4] = bone.offsetTransform[1];
                            bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 5] = bone.offsetTransform[5];
                            bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 6] = bone.offsetTransform[9];
                            bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 7] = bone.offsetTransform[13];

                            bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 8] = bone.offsetTransform[2];
                            bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 9] = bone.offsetTransform[6];
                            bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 10] = bone.offsetTransform[10];
                            bone.bindingArrays[a].array[bone.bindingArrays[a].offset + 11] = bone.offsetTransform[14];
                        }
                    }
                }
            }
        }

        /**
         * RenderDebugInfo
         * TODO: Fix commented out code
         * @param {function} debugHelper
         */

    }, {
        key: 'RenderDebugInfo',
        value: function RenderDebugInfo(debugHelper) {
            /*for (var i = 0; i < this.geometryResources.length; ++i)
             {
             this.geometryResources[i].RenderDebugInfo(debugHelper);
             }*/
            for (var i = 0; i < this.models.length; ++i) {
                for (var j = 0; j < this.models[i].bones.length; ++j) {
                    var b0 = this.models[i].bones[j];
                    if (b0.boneRes.parentIndex >= 0) {
                        var b1 = this.models[i].bones[b0.boneRes.parentIndex];
                        debugHelper['AddLine']([b0.worldTransform[12], b0.worldTransform[13], b0.worldTransform[14]], [b1.worldTransform[12], b1.worldTransform[13], b1.worldTransform[14]]);
                    }
                }
            }
        }

        /**
         * Adds a model resource to an animation controller
         * @param {Tw2AnimationController} animationController
         * @param {Tw2GeometryModel} modelRes
         * @returns {null|Tw2Model} Returns a newly created Tw2Model if the model resource doesn't already exist, and null if it does
         */

    }], [{
        key: 'AddModel',
        value: function AddModel(animationController, modelRes) {
            for (var i = 0; i < animationController.models.length; ++i) {
                if (animationController.models[i].modelRes.name === modelRes.name) {
                    return null;
                }
            }

            var model = new _Tw2Model.Tw2Model();
            model.modelRes = modelRes;
            var skeleton = modelRes.skeleton;
            if (skeleton !== null) {
                for (var j = 0; j < skeleton.bones.length; ++j) {
                    var bone = new _Tw2Bone.Tw2Bone();
                    bone.boneRes = skeleton.bones[j];
                    model.bones.push(bone);
                    model.bonesByName[bone.boneRes.name] = bone;
                }
            }
            animationController.models.push(model);
            return model;
        }

        /**
         * Finds a mesh binding for a supplied resource from an animation controller
         * @param {Tw2AnimationController} animationController
         * @param {Tw2GeometryRes} resource
         * @returns {Object|null} Returns the mesh binding of a resource if it exists, null if it doesn't
         * @private
         */

    }, {
        key: 'FindMeshBindings',
        value: function FindMeshBindings(animationController, resource) {
            for (var i = 0; i < animationController.meshBindings.length; ++i) {
                if (animationController.meshBindings[i].resource === resource) {
                    return animationController.meshBindings[i];
                }
            }
            return null;
        }

        /**
         * DoRebuildCachedData
         * @param {Tw2AnimationController) animationController
         * @param {Tw2GeometryRes} resource
         */

    }, {
        key: 'DoRebuildCachedData',
        value: function DoRebuildCachedData(animationController, resource) {
            var newModels = [];
            if (resource.meshes.length) {
                for (var i = 0; i < resource.models.length; ++i) {
                    var model = Tw2AnimationController.AddModel(animationController, resource.models[i]);
                    if (model) {
                        newModels.push(model);
                    }
                }
            }

            for (var _i6 = 0; _i6 < animationController.geometryResources.length; ++_i6) {
                animationController.AddAnimationsFromRes(animationController.geometryResources[_i6]);
            }

            if (resource.models.length === 0) {
                for (var _i7 = 0; _i7 < resource.meshes.length; ++_i7) {
                    _resource.Tw2GeometryRes.BindMeshToModel(resource.meshes[_i7], animationController.geometryResources[0].models[0], resource);
                }
                resource.models.push(animationController.geometryResources[0].models[0]);
            }

            for (var _i8 = 0; _i8 < resource.models.length; ++_i8) {
                var _model = null;
                for (var j = 0; j < animationController.models.length; ++j) {
                    if (animationController.models[j].modelRes.name === resource.models[_i8].name) {
                        _model = animationController.models[j];
                        break;
                    }
                }

                if (_model === null) {
                    continue;
                }

                for (var _j4 = 0; _j4 < resource.models[_i8].meshBindings.length; ++_j4) {
                    var meshIx = resource.meshes.indexOf(resource.models[_i8].meshBindings[_j4].mesh);
                    var meshBindings = Tw2AnimationController.FindMeshBindings(animationController, resource);

                    if (meshBindings === null) {
                        meshBindings = [];
                        meshBindings.resource = resource;
                        animationController.meshBindings.push(meshBindings);
                    }

                    meshBindings[meshIx] = new Float32Array(resource.models[_i8].meshBindings[_j4].bones.length * 12);
                    for (var k = 0; k < resource.models[_i8].meshBindings[_j4].bones.length; ++k) {
                        for (var n = 0; n < _model.bones.length; ++n) {
                            if (_model.bones[n].boneRes.name === resource.models[_i8].meshBindings[_j4].bones[k].name) {
                                if (!_model.bones[n].bindingArrays) {
                                    _model.bones[n].bindingArrays = [];
                                }

                                _model.bones[n].bindingArrays[_model.bones[n].bindingArrays.length] = {
                                    'array': meshBindings[meshIx],
                                    'offset': k * 12
                                };
                                //meshBindings[meshIx][k] = model.bones[n].offsetTransform;
                                break;
                            }
                        }
                    }
                }
            }

            if (resource.meshes.length && resource.models.length) {
                animationController.ResetBoneTransforms();
            }

            animationController.loaded = true;
            if (animationController.animations.length) {
                if (animationController.pendingCommands.length) {
                    for (var _i9 = 0; _i9 < animationController.pendingCommands.length; ++_i9) {
                        if (!animationController.pendingCommands[_i9].args) {
                            animationController.pendingCommands[_i9].func.apply(animationController);
                        } else {
                            animationController.pendingCommands[_i9].func.apply(animationController, animationController.pendingCommands[_i9].args);
                        }
                    }
                }
                animationController.pendingCommands = [];
                if (animationController.onPendingCleared) animationController.onPendingCleared(animationController);
            }
        }
    }]);

    return Tw2AnimationController;
}();

/**
 * Scratch variables
 */


Tw2AnimationController.scratch = {
    vec3_0: _math.vec3.create(),
    quat_0: _math.quat.create(),
    mat3_0: _math.mat3.create(),
    mat4_0: _math.mat4.create()
};

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2EffectRes = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Logger = __webpack_require__(4);

var _reader = __webpack_require__(29);

var _Tw2Resource2 = __webpack_require__(12);

var _Tw2Shader = __webpack_require__(134);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2EffectRes
 *
 * @property {Array} passes
 * @inherits Tw2Resource
 */
var Tw2EffectRes = exports.Tw2EffectRes = function (_Tw2Resource) {
    _inherits(Tw2EffectRes, _Tw2Resource);

    function Tw2EffectRes() {
        _classCallCheck(this, Tw2EffectRes);

        var _this = _possibleConstructorReturn(this, (Tw2EffectRes.__proto__ || Object.getPrototypeOf(Tw2EffectRes)).call(this));

        _this.passes = [];
        _this.annotations = {};
        _this.permutations = [];
        _this.offsets = [];
        _this.reader = null;
        _this.version = 0;
        _this.stringTable = '';
        _this.shaders = {};
        return _this;
    }

    /**
     * Prepares the effect
     * - Creates Shaders
     * - Sets shadow states for shaders
     * - Parses Jessica shader annotations
     * @param data
     */


    _createClass(Tw2EffectRes, [{
        key: 'Prepare',
        value: function Prepare(data) {
            this.permutations = [];
            this.offsets = [];
            this.passes = [];
            this.annotations = {};
            this.reader = null;
            this.version = 0;
            this.stringTable = '';
            this.shaders = {};

            var reader = new _reader.Tw2BinaryReader(new Uint8Array(data));
            var stringTable = '';

            /**
             * ReadString
             * @returns {string}
             * @private
             */
            function ReadString() {
                var offset = reader.ReadUInt32();
                var end = offset;
                while (stringTable.charCodeAt(end)) {
                    ++end;
                }
                return stringTable.substr(offset, end - offset);
            }

            var version = reader.ReadUInt32();
            if (version < 2 || version > 7) {
                _Tw2Logger.logger.log('res.error', {
                    log: 'error',
                    src: ['Tw2EffectRes', 'CreateProgram'],
                    msg: 'Invalid version of effect file',
                    type: 'shader.effectversion',
                    path: this.path,
                    value: version
                });

                this.PrepareFinished(false);
                return;
            }

            var headerSize = void 0,
                stringTableSize = void 0;

            if (version < 5) {
                headerSize = reader.ReadUInt32();
                if (headerSize === 0) {
                    _Tw2Logger.logger.log('res.error', {
                        log: 'error',
                        src: ['Tw2EffectRes', 'CreateProgram'],
                        msg: 'File contains no compiled effects',
                        path: this.path,
                        type: 'shader.effectheadersize',
                        value: 0
                    });

                    this.PrepareFinished(false);
                    return;
                }

                /* let permutation = */
                reader.ReadUInt32();
                var offset = reader.ReadUInt32();
                reader.cursor = 2 * 4 + headerSize * 3 * 4;
                stringTableSize = reader.ReadUInt32();
                this.stringTableOffset = reader.cursor;
                stringTable = String.fromCharCode.apply(null, reader.data.subarray(reader.cursor, reader.cursor + stringTableSize));
                reader.cursor = offset;
            } else {
                stringTableSize = reader.ReadUInt32();
                this.stringTableOffset = reader.cursor;
                stringTable = String.fromCharCode.apply(null, reader.data.subarray(reader.cursor, reader.cursor + stringTableSize));
                reader.cursor += stringTableSize;
                var permutationCount = reader.ReadUInt8();
                for (var perm = 0; perm < permutationCount; ++perm) {
                    var permutation = {
                        name: ReadString(),
                        defaultOption: reader.ReadUInt8(),
                        description: ReadString(),
                        type: reader.ReadUInt8(),
                        options: {},
                        optionCount: reader.ReadUInt8()
                    };
                    for (var j = 0; j < permutation.optionCount; ++j) {
                        permutation.options[ReadString()] = j;
                    }
                    this.permutations.push(permutation);
                }

                headerSize = reader.ReadUInt32();
                if (headerSize === 0) {
                    _Tw2Logger.logger.log('res.error', {
                        log: 'error',
                        src: ['Tw2EffectRes', 'CreateProgram'],
                        msg: 'File contains no compiled effects',
                        path: this.path,
                        type: 'shader.effectheadersize',
                        value: 0
                    });

                    this.PrepareFinished(false);
                    return;
                }
                for (var i = 0; i < headerSize; ++i) {
                    this.offsets.push({
                        index: reader.ReadUInt32(),
                        offset: reader.ReadUInt32(),
                        size: reader.ReadUInt32()
                    });
                }

                reader.ReadUInt32();
                reader.cursor = reader.ReadUInt32();
            }
            this.reader = reader;
            this.version = version;
            this.stringTable = stringTable;

            this.PrepareFinished(true);
        }

        /**
         * Gets/creates a shader for the given permutation options
         *
         * @param {Object.<string, string>} options - Permutation options
         * @returns {Tw2Shader|null}
         */

    }, {
        key: 'GetShader',
        value: function GetShader(options) {
            if (!this.IsGood()) {
                return null;
            }

            var index = 0;
            var multiplier = 1;

            for (var i = 0; i < this.permutations.length; ++i) {
                var permutation = this.permutations[i];
                var value = permutation.defaultOption;
                if (options.hasOwnProperty(permutation.name)) {
                    var valueName = options[permutation.name];
                    if (!permutation.options.hasOwnProperty(valueName)) {
                        _Tw2Logger.logger.log('res.error', {
                            log: 'error',
                            src: ['Tw2EffectRes', 'GetShader'],
                            msg: 'Invalid shader permutation value',
                            path: this.path,
                            name: permutation.name,
                            value: valueName
                        });
                        return null;
                    }
                    value = permutation.options[valueName];
                }
                index += value * multiplier;
                multiplier *= permutation.optionCount;
            }

            if (this.shaders.hasOwnProperty(index)) {
                return this.shaders[index];
            }

            this.reader.cursor = this.offsets[index].offset;
            var shader = null;
            try {
                shader = new _Tw2Shader.Tw2Shader(this.reader, this.version, this.stringTable, this.stringTableOffset);
            } catch (error) {
                return null;
            }
            this.shaders[index] = shader;
            return shader;
        }
    }]);

    return Tw2EffectRes;
}(_Tw2Resource2.Tw2Resource);

/**
 * Request Response Type
 * @type {string}
 */


Tw2EffectRes.prototype.requestResponseType = 'arraybuffer';

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Shader = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Device = __webpack_require__(2);

var _global = __webpack_require__(17);

var _vertex = __webpack_require__(9);

var _math = __webpack_require__(0);

var _sampler = __webpack_require__(21);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2Shader
 *
 * @property {Object.<string, Object>} techniques
 * @property {Object.<string, Array>} annotations
 * @class
 */
var Tw2Shader = exports.Tw2Shader = function () {
    function Tw2Shader(reader, version, stringTable, stringTableOffset, path) {
        _classCallCheck(this, Tw2Shader);

        /**
         * ReadString
         * @returns {string}
         * @private
         */
        function ReadString() {
            var offset = reader.ReadUInt32();
            var end = offset;
            while (stringTable.charCodeAt(end)) {
                ++end;
            }
            return stringTable.substr(offset, end - offset);
        }

        this.techniques = {};
        this.annotations = {};

        var d = _Tw2Device.device;

        var techniqueCount = 1;
        if (version > 6) {
            techniqueCount = reader.ReadUInt8();
        }
        for (var t = 0; t < techniqueCount; ++t) {
            var technique = {
                name: 'Main',
                passes: []
            };
            if (version > 6) {
                technique.name = ReadString();
            }
            this.techniques[technique.name] = technique;

            var passCount = reader.ReadUInt8();
            for (var passIx = 0; passIx < passCount; ++passIx) {
                var pass = {};
                pass.stages = [{}, {}];
                var stageCount = reader.ReadUInt8();
                var validShadowShader = true;

                for (var stageIx = 0; stageIx < stageCount; ++stageIx) {
                    var stage = {};
                    stage.inputDefinition = new _vertex.Tw2VertexDeclaration();
                    stage.constants = [];
                    stage.textures = [];
                    stage.samplers = [];

                    var stageType = reader.ReadUInt8(),
                        inputCount = reader.ReadUInt8();

                    for (var inputIx = 0; inputIx < inputCount; ++inputIx) {
                        var usage = reader.ReadUInt8();
                        /* let registerIndex = */
                        reader.ReadUInt8();
                        var usageIndex = reader.ReadUInt8();
                        /* let usedMask = */
                        reader.ReadUInt8();
                        stage.inputDefinition.elements[inputIx] = new _vertex.Tw2VertexElement(usage, usageIndex, 0);
                    }
                    stage.inputDefinition.RebuildHash();

                    var shaderSize = void 0,
                        shaderCode = void 0,
                        shadowShaderSize = void 0,
                        shadowShaderCode = void 0;

                    if (version < 5) {
                        shaderSize = reader.ReadUInt32();
                        shaderCode = reader.data.subarray(reader.cursor, reader.cursor + shaderSize);
                        reader.cursor += shaderSize;

                        shadowShaderSize = reader.ReadUInt32();
                        shadowShaderCode = reader.data.subarray(reader.cursor, reader.cursor + shadowShaderSize);
                        reader.cursor += shadowShaderSize;
                    } else {
                        shaderSize = reader.ReadUInt32();
                        var so = reader.ReadUInt32();
                        shaderCode = stringTable.substr(so, shaderSize);
                        shadowShaderSize = reader.ReadUInt32();
                        so = reader.ReadUInt32();
                        shadowShaderCode = stringTable.substr(so, shadowShaderSize);
                    }

                    stage.shader = Tw2Shader.CompileShader(stageType, '', shaderCode, path);
                    if (stage.shader === null) {
                        throw new Error();
                    }

                    if (validShadowShader) {
                        if (shadowShaderSize === 0) {
                            stage.shadowShader = Tw2Shader.CompileShader(stageType, '\n#define PS\n', shaderCode, path);
                        } else {
                            stage.shadowShader = Tw2Shader.CompileShader(stageType, '', shadowShaderCode, path);
                        }

                        if (stage.shadowShader === null) {
                            validShadowShader = false;
                        }
                    } else {
                        stage.shadowShader = null;
                    }

                    if (version >= 3) {
                        reader.ReadUInt32();
                        reader.ReadUInt32();
                        reader.ReadUInt32();
                    }

                    stage.constantSize = 0;
                    var constantCount = reader.ReadUInt32();
                    for (var constantIx = 0; constantIx < constantCount; ++constantIx) {
                        var constant = {};
                        constant.name = ReadString();
                        constant.offset = reader.ReadUInt32() / 4;
                        constant.size = reader.ReadUInt32() / 4;
                        constant.type = reader.ReadUInt8();
                        constant.dimension = reader.ReadUInt8();
                        constant.elements = reader.ReadUInt32();
                        constant.isSRGB = reader.ReadUInt8();
                        constant.isAutoregister = reader.ReadUInt8();
                        stage.constants[constantIx] = constant;

                        if (Tw2Shader.ConstantIgnore.includes(constant.name)) continue;

                        var last = constant.offset + constant.size;
                        if (last > stage.constantSize) stage.constantSize = last;
                    }

                    var constantValueSize = reader.ReadUInt32() / 4;
                    stage.constantValues = new Float32Array(constantValueSize);
                    if (version < 5) {
                        for (var i = 0; i < constantValueSize; ++i) {
                            stage.constantValues[i] = reader.ReadFloat32();
                        }
                    } else {
                        var co = reader.ReadUInt32(),
                            bo = reader.cursor;

                        reader.cursor = stringTableOffset + co;
                        for (var _i = 0; _i < constantValueSize; ++_i) {
                            stage.constantValues[_i] = reader.ReadFloat32();
                        }
                        reader.cursor = bo;
                    }
                    stage.constantSize = Math.max(stage.constantSize, constantValueSize);

                    var textureCount = reader.ReadUInt8();
                    for (var textureIx = 0; textureIx < textureCount; ++textureIx) {
                        var texture = {};
                        texture.registerIndex = reader.ReadUInt8();
                        texture.name = ReadString();
                        texture.type = reader.ReadUInt8();
                        texture.isSRGB = reader.ReadUInt8();
                        texture.isAutoregister = reader.ReadUInt8();
                        stage.textures.push(texture);
                    }

                    var samplerCount = reader.ReadUInt8();
                    for (var samplerIx = 0; samplerIx < samplerCount; ++samplerIx) {
                        var registerIndex = reader.ReadUInt8(),
                            samplerName = version >= 4 ? ReadString() : '';

                        reader.ReadUInt8(); // comparison

                        var minFilter = reader.ReadUInt8(),
                            magFilter = reader.ReadUInt8(),
                            mipFilter = reader.ReadUInt8(),
                            addressU = reader.ReadUInt8(),
                            addressV = reader.ReadUInt8(),
                            addressW = reader.ReadUInt8();

                        reader.ReadFloat32(); // mipLODBias

                        var maxAnisotropy = reader.ReadUInt8();

                        reader.ReadUInt8(); //comparisonFunc

                        var borderColor = _math.quat.create();
                        borderColor[0] = reader.ReadFloat32();
                        borderColor[1] = reader.ReadFloat32();
                        borderColor[2] = reader.ReadFloat32();
                        borderColor[3] = reader.ReadFloat32();

                        reader.ReadFloat32(); //minLOD
                        reader.ReadFloat32(); //maxLOD

                        if (version < 4) reader.ReadUInt8();

                        var sampler = new _sampler.Tw2SamplerState();
                        sampler.registerIndex = registerIndex;
                        sampler.name = samplerName;

                        if (minFilter === 1) {
                            switch (mipFilter) {
                                case 0:
                                    sampler.minFilter = d.gl.NEAREST;
                                    break;

                                case 1:
                                    sampler.minFilter = d.gl.NEAREST_MIPMAP_NEAREST;
                                    break;

                                default:
                                    sampler.minFilter = d.gl.NEAREST_MIPMAP_LINEAR;
                            }
                            sampler.minFilterNoMips = d.gl.NEAREST;
                        } else {
                            switch (mipFilter) {
                                case 0:
                                    sampler.minFilter = d.gl.LINEAR;
                                    break;

                                case 1:
                                    sampler.minFilter = d.gl.LINEAR_MIPMAP_NEAREST;
                                    break;

                                default:
                                    sampler.minFilter = d.gl.LINEAR_MIPMAP_LINEAR;
                            }
                            sampler.minFilterNoMips = d.gl.LINEAR;
                        }

                        sampler.magFilter = magFilter === 1 ? d.gl.NEAREST : d.gl.LINEAR;
                        sampler.addressU = d.wrapModes[addressU];
                        sampler.addressV = d.wrapModes[addressV];
                        sampler.addressW = d.wrapModes[addressW];

                        if (minFilter === 3 || magFilter === 3 || mipFilter === 3) {
                            sampler.anisotropy = Math.max(maxAnisotropy, 1);
                        }

                        for (var n = 0; n < stage.textures.length; ++n) {
                            if (stage.textures[n].registerIndex === sampler.registerIndex) {
                                sampler.samplerType = stage.textures[n].type === 4 ? d.gl.TEXTURE_CUBE_MAP : d.gl.TEXTURE_2D;
                                sampler.isVolume = stage.textures[n].type === 3;
                                break;
                            }
                        }

                        sampler.ComputeHash();
                        stage.samplers.push(sampler);
                    }

                    if (version >= 3) reader.ReadUInt8();

                    pass.stages[stageType] = stage;
                }

                pass.states = [];
                var stateCount = reader.ReadUInt8();
                for (var stateIx = 0; stateIx < stateCount; ++stateIx) {
                    var state = reader.ReadUInt32(),
                        value = reader.ReadUInt32();

                    pass.states.push({
                        'state': state,
                        'value': value
                    });
                }

                pass.shaderProgram = Tw2Shader.CreateProgram(pass.stages[0].shader, pass.stages[1].shader, pass, path);
                if (pass.shaderProgram === null) {
                    throw new Error();
                }

                if (validShadowShader) {
                    pass.shadowShaderProgram = Tw2Shader.CreateProgram(pass.stages[0].shadowShader, pass.stages[1].shadowShader, pass, path);
                    if (pass.shadowShaderProgram === null) {
                        pass.shadowShaderProgram = pass.shaderProgram;
                    }
                } else {
                    pass.shadowShaderProgram = pass.shaderProgram;
                }

                technique.passes[passIx] = pass;
            }
        }
        var parameterCount = reader.ReadUInt16();
        for (var paramIx = 0; paramIx < parameterCount; ++paramIx) {
            var name = ReadString(),
                annotations = [],
                annotationCount = reader.ReadUInt8();

            for (var annotationIx = 0; annotationIx < annotationCount; ++annotationIx) {
                annotations[annotationIx] = {};
                annotations[annotationIx].name = ReadString();
                annotations[annotationIx].type = reader.ReadUInt8();
                switch (annotations[annotationIx].type) {
                    case 0:
                        annotations[annotationIx].value = reader.ReadUInt32() !== 0;
                        break;

                    case 1:
                        annotations[annotationIx].value = reader.ReadInt32();
                        break;

                    case 2:
                        annotations[annotationIx].value = reader.ReadFloat32();
                        break;

                    default:
                        annotations[annotationIx].value = ReadString();
                }
            }
            this.annotations[name] = annotations;
        }
    }

    /**
     * Applies an Effect Pass
     * @param {String} technique - technique name
     * @param {number} pass - effect.passes index
     */


    _createClass(Tw2Shader, [{
        key: 'ApplyPass',
        value: function ApplyPass(technique, pass) {
            var d = _Tw2Device.device;
            pass = this.techniques[technique].passes[pass];

            for (var i = 0; i < pass.states.length; ++i) {
                d.SetRenderState(pass.states[i].state, pass.states[i].value);
            }

            if (d.IsAlphaTestEnabled()) {
                d.gl.useProgram(pass.shadowShaderProgram.program);
                d.shadowHandles = pass.shadowShaderProgram;
            } else {
                d.gl.useProgram(pass.shaderProgram.program);
                d.shadowHandles = null;
            }
        }

        /**
         * Finds out if a parameter name is a valid shader input
         * @param {string} name - An Effect Parameter name
         * @returns {Boolean}
         */

    }, {
        key: 'IsValidParameter',
        value: function IsValidParameter(name) {
            return name in this.annotations;
        }

        /**
         * Returns an array of valid parameter names for a specific annotation group
         * - Compatible with pre V5 shaders
         * @param {string} groupName - The name of an annotation group
         * @returns {Array.< string >}
         */

    }, {
        key: 'GetParametersByGroup',
        value: function GetParametersByGroup(groupName) {
            var parameters = [];
            for (var param in this.annotations) {
                if (this.annotations.hasOwnProperty(param)) {
                    for (var i = 0; i < this.annotations[param].length; i++) {
                        if (this.annotations[param][i].name.toLowerCase() === 'group' && this.annotations[param][i].value.toLowerCase() === groupName.toLowerCase()) {
                            parameters.push(param);
                        }
                    }
                }
            }
            return parameters;
        }

        /**
         * Compiles shader
         * @param {number} stageType
         * @param {string} prefix
         * @param shaderCode
         * @param {string} path - Shader path
         * @returns {*}
         */

    }], [{
        key: 'CompileShader',
        value: function CompileShader(stageType, prefix, shaderCode, path) {
            var d = _Tw2Device.device,
                shader = d.gl.createShader(stageType === 0 ? d.gl.VERTEX_SHADER : d.gl.FRAGMENT_SHADER);

            if (d.ext.ShaderBinary) {
                d.ext.ShaderBinary['shaderBinary'](shader, shaderCode);
            } else {
                var source = prefix + (typeof shaderCode === 'string' ? shaderCode : String.fromCharCode.apply(null, shaderCode));
                source = source.substr(0, source.length - 1);
                d.gl.shaderSource(shader, source);
                d.gl.compileShader(shader);
            }

            if (!d.gl.getShaderParameter(shader, d.gl.COMPILE_STATUS)) {
                _global.logger.log('res.error', {
                    log: 'error',
                    src: ['Tw2Shader', 'CompileShader'],
                    msg: 'Error compiling shader',
                    path: path,
                    type: 'shader.compile',
                    value: stageType === 0 ? 'VERTEX' : 'FRAGMENT',
                    data: _Tw2Device.device.gl.getShaderInfoLog(shader)
                });
                return null;
            }
            return shader;
        }

        /**
         * Creates shader program
         * @param vertexShader
         * @param fragmentShader
         * @param pass
         * @param {string} path - Shader path
         * @returns {*}
         */

    }, {
        key: 'CreateProgram',
        value: function CreateProgram(vertexShader, fragmentShader, pass, path) {
            var d = _Tw2Device.device,
                program = {};

            program.program = d.gl.createProgram();
            d.gl.attachShader(program.program, vertexShader);
            d.gl.attachShader(program.program, fragmentShader);
            d.gl.linkProgram(program.program);

            if (!d.gl.getProgramParameter(program.program, d.gl.LINK_STATUS)) {
                _global.logger.log('res.error', {
                    log: 'error',
                    src: ['Tw2Shader', 'CreateProgram'],
                    msg: 'Error linking shaders',
                    path: path,
                    type: 'shader.linkstatus',
                    data: _Tw2Device.device.gl.getProgramInfoLog(program.program)
                });
                return null;
            }

            d.gl.useProgram(program.program);
            program.constantBufferHandles = [];
            for (var j = 0; j < 16; ++j) {
                program.constantBufferHandles[j] = d.gl.getUniformLocation(program.program, 'cb' + j);
            }

            program.samplerHandles = [];
            for (var _j = 0; _j < 16; ++_j) {
                program.samplerHandles[_j] = d.gl.getUniformLocation(program.program, 's' + _j);
                d.gl.uniform1i(program.samplerHandles[_j], _j);
            }

            for (var _j2 = 0; _j2 < 16; ++_j2) {
                program.samplerHandles[_j2 + 12] = d.gl.getUniformLocation(program.program, 'vs' + _j2);
                d.gl.uniform1i(program.samplerHandles[_j2 + 12], _j2 + 12);
            }

            program.input = new _vertex.Tw2VertexDeclaration();
            for (var _j3 = 0; _j3 < pass.stages[0].inputDefinition.elements.length; ++_j3) {
                var location = d.gl.getAttribLocation(program.program, 'attr' + _j3);
                if (location >= 0) {
                    var el = new _vertex.Tw2VertexElement(pass.stages[0].inputDefinition.elements[_j3].usage, pass.stages[0].inputDefinition.elements[_j3].usageIndex);
                    el.location = location;
                    program.input.elements.push(el);
                }
            }
            program.input.RebuildHash();

            program.shadowStateInt = d.gl.getUniformLocation(program.program, 'ssi');
            program.shadowStateFloat = d.gl.getUniformLocation(program.program, 'ssf');
            program.shadowStateYFlip = d.gl.getUniformLocation(program.program, 'ssyf');
            d.gl.uniform3f(program.shadowStateYFlip, 0, 0, 1);
            program.volumeSlices = [];
            for (var _j4 = 0; _j4 < pass.stages[1].samplers.length; ++_j4) {
                if (pass.stages[1].samplers[_j4].isVolume) {
                    program.volumeSlices[pass.stages[1].samplers[_j4].registerIndex] = d.gl.getUniformLocation(program.program, 's' + pass.stages[1].samplers[_j4].registerIndex + 'sl');
                }
            }
            return program;
        }
    }]);

    return Tw2Shader;
}();

/**
 * Constant names that are ignored
 * @type {string[]}
 */


Tw2Shader.ConstantIgnore = ['PerFrameVS', 'PerObjectVS', 'PerFramePS', 'PerObjectPS'];

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2GeometryRes = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Device = __webpack_require__(2);

var _Tw2Logger = __webpack_require__(4);

var _reader = __webpack_require__(29);

var _vertex = __webpack_require__(9);

var _Tw2Resource2 = __webpack_require__(12);

var _geometry = __webpack_require__(46);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2GeometryRes
 *
 * @property {Array} meshes
 * @property {vec3} minBounds
 * @property {vec3} maxBounds
 * @property {vec3} boundsSpherePosition
 * @property {number} boundsSphereRadius
 * @property {Array} models
 * @property {Array} animations
 * @property {Boolean} systemMirror
 * @inherit Tw2Resource
 */
var Tw2GeometryRes = exports.Tw2GeometryRes = function (_Tw2Resource) {
    _inherits(Tw2GeometryRes, _Tw2Resource);

    function Tw2GeometryRes() {
        _classCallCheck(this, Tw2GeometryRes);

        var _this = _possibleConstructorReturn(this, (Tw2GeometryRes.__proto__ || Object.getPrototypeOf(Tw2GeometryRes)).call(this));

        _this.meshes = [];
        _this.minBounds = _math.vec3.create();
        _this.maxBounds = _math.vec3.create();
        _this.boundsSpherePosition = _math.vec3.create();
        _this.boundsSphereRadius = 0;
        _this.models = [];
        _this.animations = [];
        _this.systemMirror = false;
        return _this;
    }

    /**
     * GetInstanceBuffer
     * @param {number} meshIndex
     * @returns {*}
     */


    _createClass(Tw2GeometryRes, [{
        key: 'GetInstanceBuffer',
        value: function GetInstanceBuffer(meshIndex) {
            return meshIndex < this.meshes.length ? this.meshes[meshIndex].buffer : undefined;
        }

        /**
         * GetInstanceDeclaration
         * @param {number} meshIndex
         * @returns {Tw2VertexDeclaration}
         */

    }, {
        key: 'GetInstanceDeclaration',
        value: function GetInstanceDeclaration(meshIndex) {
            return this.meshes[meshIndex].declaration;
        }

        /**
         * GetInstanceStride
         * @param {number} meshIndex
         * @returns {number}
         */

    }, {
        key: 'GetInstanceStride',
        value: function GetInstanceStride(meshIndex) {
            return this.meshes[meshIndex].declaration.stride;
        }

        /**
         * GetInstanceCount
         * @param {number} meshIndex
         * @returns {number}
         */

    }, {
        key: 'GetInstanceCount',
        value: function GetInstanceCount(meshIndex) {
            return this.meshes[meshIndex].bufferLength * 4 / this.meshes[meshIndex].declaration.stride;
        }

        /**
         * Prepare
         * @param data
         */

    }, {
        key: 'Prepare',
        value: function Prepare(data) {
            var d = _Tw2Device.device,
                reader = new _reader.Tw2BinaryReader(new Uint8Array(data));

            /* let fileVersion = */
            reader.ReadUInt8();
            var meshCount = reader.ReadUInt8();
            for (var meshIx = 0; meshIx < meshCount; ++meshIx) {
                var mesh = new _geometry.Tw2GeometryMesh();
                mesh.name = reader.ReadString();
                var buffer = Tw2GeometryRes.ReadVertexBuffer(reader, mesh.declaration);

                if (buffer) {
                    mesh.bufferLength = buffer.length;
                    mesh.buffer = d.gl.createBuffer();
                    d.gl.bindBuffer(d.gl.ARRAY_BUFFER, mesh.buffer);
                    d.gl.bufferData(d.gl.ARRAY_BUFFER, buffer, d.gl.STATIC_DRAW);
                } else {
                    mesh.buffer = null;
                }

                var indexes = Tw2GeometryRes.ReadIndexBuffer(reader);
                if (indexes) {
                    mesh.indexes = d.gl.createBuffer();
                    mesh.indexType = indexes.BYTES_PER_ELEMENT === 2 ? d.gl.UNSIGNED_SHORT : d.gl.UNSIGNED_INT;
                    d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);
                    d.gl.bufferData(d.gl.ELEMENT_ARRAY_BUFFER, indexes, d.gl.STATIC_DRAW);
                } else {
                    mesh.indexes = null;
                }

                var areaCount = reader.ReadUInt8();
                for (var i = 0; i < areaCount; ++i) {
                    mesh.areas[i] = new _geometry.Tw2GeometryMeshArea();
                    mesh.areas[i].name = reader.ReadString();
                    mesh.areas[i].start = reader.ReadUInt32() * indexes.BYTES_PER_ELEMENT;
                    mesh.areas[i].count = reader.ReadUInt32() * 3;
                    mesh.areas[i].minBounds = _math.vec3.fromValues(reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32());
                    mesh.areas[i].maxBounds = _math.vec3.fromValues(reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32());
                }

                var boneBindingCount = reader.ReadUInt8();
                mesh.boneBindings = [];
                for (var _i = 0; _i < boneBindingCount; ++_i) {
                    mesh.boneBindings[_i] = reader.ReadString();
                }

                var annotationSetCount = reader.ReadUInt16();
                if (annotationSetCount || this.systemMirror) {
                    mesh.bufferData = buffer;
                    mesh.indexData = indexes;
                }

                if (annotationSetCount) {
                    mesh.blendShapes = [];
                    for (var _i2 = 0; _i2 < annotationSetCount; ++_i2) {
                        mesh.blendShapes[_i2] = new _geometry.Tw2BlendShapeData();
                        mesh.blendShapes[_i2].name = reader.ReadString();
                        mesh.blendShapes[_i2].buffer = Tw2GeometryRes.ReadVertexBuffer(reader, mesh.blendShapes[_i2].declaration);
                        mesh.blendShapes[_i2].indexes = Tw2GeometryRes.ReadIndexBuffer(reader);
                    }
                }

                this.meshes[meshIx] = mesh;
            }

            var modelCount = reader.ReadUInt8();
            for (var modelIx = 0; modelIx < modelCount; ++modelIx) {
                var model = new _geometry.Tw2GeometryModel();
                model.name = reader.ReadString();
                model.skeleton = new _geometry.Tw2GeometrySkeleton();
                var boneCount = reader.ReadUInt8();

                for (var _i3 = 0; _i3 < boneCount; ++_i3) {
                    var bone = new _geometry.Tw2GeometryBone();
                    bone.name = reader.ReadString();
                    var flags = reader.ReadUInt8();
                    bone.parentIndex = reader.ReadUInt8();
                    if (bone.parentIndex === 255) bone.parentIndex = -1;

                    if ((flags & 1) != 0) {
                        _math.vec3.set(bone.position, reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32());
                    } else {
                        _math.vec3.set(bone.position, 0, 0, 0);
                    }

                    if ((flags & 2) != 0) {
                        _math.quat.set(bone.orientation, reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32());
                    } else {
                        _math.quat.identity(bone.orientation);
                    }

                    if ((flags & 4) != 0) {
                        for (var k = 0; k < 9; ++k) {
                            bone.scaleShear[k] = reader.ReadFloat32();
                        }
                    } else {
                        _math.mat3.identity(bone.scaleShear);
                    }
                    model.skeleton.bones[_i3] = bone;
                }

                for (var _i4 = 0; _i4 < model.skeleton.bones.length; ++_i4) {
                    model.skeleton.bones[_i4].UpdateTransform();
                    if (model.skeleton.bones[_i4].parentIndex !== -1) {
                        _math.mat4.multiply(model.skeleton.bones[_i4].worldTransform, model.skeleton.bones[model.skeleton.bones[_i4].parentIndex].worldTransform, model.skeleton.bones[_i4].localTransform);
                    } else {
                        _math.mat4.copy(model.skeleton.bones[_i4].worldTransform, model.skeleton.bones[_i4].localTransform);
                    }
                    _math.mat4.invert(model.skeleton.bones[_i4].worldTransformInv, model.skeleton.bones[_i4].worldTransform);
                }

                var meshBindingCount = reader.ReadUInt8();
                for (var _i5 = 0; _i5 < meshBindingCount; ++_i5) {
                    var _mesh = reader.ReadUInt8();
                    if (_mesh < this.meshes.length) {
                        Tw2GeometryRes.BindMeshToModel(this.meshes[_mesh], model, this);
                    }
                }
                this.models[this.models.length] = model;
            }

            var animationCount = reader.ReadUInt8();
            for (var _i6 = 0; _i6 < animationCount; ++_i6) {
                var animation = new _geometry.Tw2GeometryAnimation();
                animation.name = reader.ReadString();
                animation.duration = reader.ReadFloat32();
                var groupCount = reader.ReadUInt8();
                for (var j = 0; j < groupCount; ++j) {
                    var group = new _geometry.Tw2GeometryTrackGroup();
                    group.name = reader.ReadString();
                    for (var m = 0; m < this.models.length; ++m) {
                        if (this.models[m].name === group.name) {
                            group.model = this.models[m];
                            break;
                        }
                    }

                    var transformTrackCount = reader.ReadUInt8();
                    for (var _k = 0; _k < transformTrackCount; ++_k) {
                        var track = new _geometry.Tw2GeometryTransformTrack();
                        track.name = reader.ReadString();
                        track.orientation = Tw2GeometryRes.ReadCurve(reader);
                        track.position = Tw2GeometryRes.ReadCurve(reader);
                        track.scaleShear = Tw2GeometryRes.ReadCurve(reader);

                        if (track.orientation) {
                            var lastX = 0;
                            var lastY = 0;
                            var lastZ = 0;
                            var lastW = 0;
                            for (var n = 0; n < track.orientation.controls.length; n += 4) {
                                var x = track.orientation.controls[n];
                                var y = track.orientation.controls[n + 1];
                                var z = track.orientation.controls[n + 2];
                                var w = track.orientation.controls[n + 3];
                                if (lastX * x + lastY * y + lastZ * z + lastW * w < 0) {
                                    track.orientation.controls[n] = -x;
                                    track.orientation.controls[n + 1] = -y;
                                    track.orientation.controls[n + 2] = -z;
                                    track.orientation.controls[n + 3] = -w;
                                }
                                lastX = x;
                                lastY = y;
                                lastZ = z;
                                lastW = w;
                            }
                        }
                        group.transformTracks[group.transformTracks.length] = track;
                    }
                    animation.trackGroups[animation.trackGroups.length] = group;
                }
                this.animations[this.animations.length] = animation;
            }

            this.PrepareFinished(true);
        }

        /**
         * BindMeshToModel
         * @param {Tw2GeometryMesh} mesh
         * @param {Tw2GeometryModel} model
         * @param {Tw2GeometryRes} res
         */

    }, {
        key: 'RenderAreasInstanced',


        /**
         * RenderAreasInstanced
         * @param {number} meshIx
         * @param {number} start
         * @param {number} count
         * @param {Tw2Effect} effect
         * @param {string} technique
         * @param instanceVB
         * @param instanceDecl
         * @param instanceStride
         * @param instanceCount
         * @returns {Boolean}
         */
        value: function RenderAreasInstanced(meshIx, start, count, effect, technique, instanceVB, instanceDecl, instanceStride, instanceCount) {
            this.KeepAlive();
            if (!this.IsGood() || !effect.IsGood() || meshIx >= this.meshes.length) return false;

            var d = _Tw2Device.device,
                mesh = this.meshes[meshIx],
                passCount = effect.GetPassCount(technique);

            d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);

            for (var pass = 0; pass < passCount; ++pass) {
                effect.ApplyPass(technique, pass);
                var passInput = effect.GetPassInput(technique, pass);
                if (passInput.elements.length === 0) continue;

                d.gl.bindBuffer(d.gl.ARRAY_BUFFER, mesh.buffer);
                mesh.declaration.SetPartialDeclaration(passInput, mesh.declaration.stride);
                d.gl.bindBuffer(d.gl.ARRAY_BUFFER, instanceVB);
                var resetData = instanceDecl.SetPartialDeclaration(passInput, instanceStride, 8, 1);
                d.ApplyShadowState();

                for (var i = 0; i < count; ++i) {
                    if (i + start < mesh.areas.length) {
                        var area = mesh.areas[i + start],
                            areaStart = area.start,
                            acount = area.count;

                        while (i + 1 < count) {
                            area = mesh.areas[i + 1 + start];
                            if (area.start !== areaStart + acount * 2) break;
                            acount += area.count;
                            ++i;
                        }
                        d.ext.drawElementsInstanced(d.gl.TRIANGLES, acount, mesh.indexType, areaStart, instanceCount);
                    }
                }
                instanceDecl.ResetInstanceDivisors(resetData);
            }
            return true;
        }

        /**
         * RenderAreas
         * @param {number} meshIx
         * @param {number} start
         * @param {number} count
         * @param {Tw2Effect} effect
         * @param {string} technique
         * @returns {Boolean}
         */

    }, {
        key: 'RenderAreas',
        value: function RenderAreas(meshIx, start, count, effect, technique) {
            this.KeepAlive();
            if (!this.IsGood() || !effect.IsGood() || meshIx >= this.meshes.length) return false;

            var d = _Tw2Device.device,
                mesh = this.meshes[meshIx] || this.meshes[0],
                passCount = effect.GetPassCount(technique);

            d.gl.bindBuffer(d.gl.ARRAY_BUFFER, mesh.buffer);
            d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);

            for (var pass = 0; pass < passCount; ++pass) {
                effect.ApplyPass(technique, pass);
                var passInput = effect.GetPassInput(technique, pass);
                if (!mesh.declaration.SetDeclaration(passInput, mesh.declaration.stride)) {
                    _Tw2Logger.logger.log('res.error', {
                        log: 'error',
                        src: ['Tw2GeometryRes', 'RenderLines'],
                        msg: 'Error binding mesh to effect',
                        path: this.path,
                        type: 'geometry.meshbind',
                        data: {
                            pass: pass,
                            passInput: passInput,
                            meshStride: mesh.declaration.stride
                        }
                    });
                    return false;
                }

                d.ApplyShadowState();

                for (var i = 0; i < count; ++i) {
                    if (i + start < mesh.areas.length) {
                        var area = mesh.areas[i + start],
                            areaStart = area.start,
                            acount = area.count;

                        while (i + 1 < count) {
                            area = mesh.areas[i + 1 + start];
                            if (area.start !== areaStart + acount * 2) break;
                            acount += area.count;
                            ++i;
                        }
                        d.gl.drawElements(d.gl.TRIANGLES, acount, mesh.indexType, areaStart);
                    }
                }
            }
            return true;
        }

        /**
         * RenderLines
         * @param {number} meshIx
         * @param {number} start
         * @param {number} count
         * @param {Tw2Effect} effect
         * @param {string} technique
         * @returns {Boolean}
         */

    }, {
        key: 'RenderLines',
        value: function RenderLines(meshIx, start, count, effect, technique) {
            this.KeepAlive();
            if (!this.IsGood() || !effect.IsGood() || meshIx >= this.meshes.length) return false;

            var d = _Tw2Device.device,
                mesh = this.meshes[meshIx],
                passCount = effect.GetPassCount(technique);

            d.gl.bindBuffer(d.gl.ARRAY_BUFFER, mesh.buffer);
            d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);

            for (var pass = 0; pass < passCount; ++pass) {
                effect.ApplyPass(technique, pass);
                var passInput = effect.GetPassInput(technique, pass);
                if (!mesh.declaration.SetDeclaration(passInput, mesh.declaration.stride)) {
                    _Tw2Logger.logger.log('res.error', {
                        log: 'error',
                        src: ['Tw2GeometryRes', 'RenderLines'],
                        msg: 'Error binding mesh to effect',
                        path: this.path,
                        type: 'geometry.meshbind',
                        data: {
                            pass: pass,
                            passInput: passInput,
                            meshStride: mesh.declaration.stride
                        }
                    });
                    return false;
                }

                d.ApplyShadowState();

                for (var i = 0; i < count; ++i) {
                    if (i + start < mesh.areas.length) {
                        var area = mesh.areas[i + start],
                            areaStart = area.start,
                            acount = area.count;

                        while (i + 1 < count) {
                            area = mesh.areas[i + 1 + start];
                            if (area.start !== areaStart + acount * 2) break;
                            acount += area.count;
                            ++i;
                        }
                        d.gl.drawElements(d.gl.LINES, acount, mesh.indexType, areaStart);
                    }
                }
            }
            return true;
        }

        /**
         * RenderDebugInfo
         * @param {function} debugHelper
         * @returns {Boolean}
         */

    }, {
        key: 'RenderDebugInfo',
        value: function RenderDebugInfo(debugHelper) {
            if (!this.IsGood()) return false;

            for (var i = 0; i < this.models.length; ++i) {
                if (this.models[i].skeleton) {
                    for (var j = 0; j < this.models[i].skeleton.bones.length; ++j) {
                        var b0 = this.models[i].skeleton.bones[j];
                        if (b0.parentIndex >= 0) {
                            var b1 = this.models[i].skeleton.bones[b0.parentIndex];
                            debugHelper['AddLine']([b0.worldTransform[12], b0.worldTransform[13], b0.worldTransform[14]], [b1.worldTransform[12], b1.worldTransform[13], b1.worldTransform[14]], [0, 0.7, 0, 1], [0, 0.7, 0, 1]);
                        }
                    }
                }
            }
        }

        /**
         * Unloads webgl and javascript resources
         * @returns {Boolean}
         */

    }, {
        key: 'Unload',
        value: function Unload() {
            for (var i = 0; i < this.meshes.length; ++i) {
                if (this.meshes[i].buffer) {
                    _Tw2Device.device.gl.deleteBuffer(this.meshes[i].buffer);
                    this.meshes[i].buffer = null;
                }

                if (this.meshes[i].indexes) {
                    _Tw2Device.device.gl.deleteBuffer(this.meshes[i].indexes);
                    this.meshes[i].indexes = null;
                }
            }

            this._isPurged = true;
            this._isGood = false;
            return true;
        }

        /**
         * ReadVertexBuffer
         * @param {Tw2BinaryReader} reader
         * @param {Tw2VertexDeclaration} declaration
         * @returns {?Float32Array}
         */

    }], [{
        key: 'BindMeshToModel',
        value: function BindMeshToModel(mesh, model, res) {
            var binding = new _geometry.Tw2GeometryMeshBinding();
            binding.mesh = mesh;
            for (var b = 0; b < binding.mesh.boneBindings.length; ++b) {
                var name = binding.mesh.boneBindings[b],
                    bone = model.FindBoneByName(name);

                if (!bone) {
                    _Tw2Logger.logger.log('res.error', {
                        log: 'error',
                        src: ['Tw2GeometryRes', 'BindMeshToModel'],
                        msg: 'Mesh has invalid bone name for model',
                        path: res.path,
                        type: 'geometry.invalidbone',
                        data: {
                            mesh: binding.mesh.name,
                            bone: name,
                            model: model.name
                        }
                    });
                } else {
                    binding.bones[binding.bones.length] = bone;
                }
            }
            model.meshBindings[model.meshBindings.length] = binding;
        }
    }, {
        key: 'ReadVertexBuffer',
        value: function ReadVertexBuffer(reader, declaration) {
            var declCount = reader.ReadUInt8();
            var vertexSize = 0;

            for (var declIx = 0; declIx < declCount; ++declIx) {
                var element = new _vertex.Tw2VertexElement();
                element.usage = reader.ReadUInt8();
                element.usageIndex = reader.ReadUInt8();
                element.fileType = reader.ReadUInt8();
                element.type = _Tw2Device.device.gl.FLOAT;
                element.elements = (element.fileType >> 5) + 1;
                element.offset = vertexSize * 4;
                declaration.elements[declIx] = element;
                vertexSize += element.elements;
            }
            declaration.RebuildHash();
            declaration.stride = vertexSize * 4;

            var vertexCount = reader.ReadUInt32();
            if (vertexCount === 0) return null;

            var buffer = new Float32Array(vertexSize * vertexCount);
            var index = 0;
            for (var vtxIx = 0; vtxIx < vertexCount; ++vtxIx) {
                for (var _declIx = 0; _declIx < declCount; ++_declIx) {
                    var el = declaration.elements[_declIx];
                    switch (el.fileType & 0xf) {
                        case 0:
                            if ((el.fileType & 0x10) != 0) {
                                for (var i = 0; i < el.elements; ++i) {
                                    buffer[index++] = reader.ReadInt8() / 127.0;
                                }
                            } else {
                                for (var _i7 = 0; _i7 < el.elements; ++_i7) {
                                    buffer[index++] = reader.ReadInt8();
                                }
                            }
                            break;

                        case 1:
                            if ((el.fileType & 0x10) != 0) {
                                for (var _i8 = 0; _i8 < el.elements; ++_i8) {
                                    buffer[index++] = reader.ReadInt8() / 32767.0;
                                }
                            } else {
                                for (var _i9 = 0; _i9 < el.elements; ++_i9) {
                                    buffer[index++] = reader.ReadInt16();
                                }
                            }
                            break;

                        case 2:
                            for (var _i10 = 0; _i10 < el.elements; ++_i10) {
                                buffer[index++] = reader.ReadInt32();
                            }
                            break;

                        case 3:
                            for (var _i11 = 0; _i11 < el.elements; ++_i11) {
                                buffer[index++] = reader.ReadFloat16();
                            }
                            break;

                        case 4:
                            for (var _i12 = 0; _i12 < el.elements; ++_i12) {
                                buffer[index++] = reader.ReadFloat32();
                            }
                            break;

                        case 8:
                            if ((el.fileType & 0x10) != 0) {
                                for (var _i13 = 0; _i13 < el.elements; ++_i13) {
                                    buffer[index++] = reader.ReadUInt8() / 255.0;
                                }
                            } else {
                                for (var _i14 = 0; _i14 < el.elements; ++_i14) {
                                    buffer[index++] = reader.ReadUInt8();
                                }
                            }
                            break;

                        case 9:
                            if ((el.fileType & 0x10) != 0) {
                                for (var _i15 = 0; _i15 < declaration.elements[_declIx].elements; ++_i15) {
                                    buffer[index++] = reader.ReadUInt8() / 65535.0;
                                }
                            } else {
                                for (var _i16 = 0; _i16 < el.elements; ++_i16) {
                                    buffer[index++] = reader.ReadUInt16();
                                }
                            }
                            break;

                        case 10:
                            for (var _i17 = 0; _i17 < el.elements; ++_i17) {
                                buffer[index++] = reader.ReadUInt32();
                            }
                            break;

                        default:
                            _Tw2Logger.logger.log('res.error', {
                                log: 'error',
                                src: ['Tw2GeometryRes', 'ReadVertexBuffer'],
                                msg: 'Error loading wbg data',
                                path: self.path,
                                type: 'geometry.filetype',
                                value: el.fileType & 0xf
                            });
                            throw 1;
                    }
                }
            }
            return buffer;
        }

        /**
         * ReadIndexBuffer
         * @property {Tw2BinaryReader}
         * @returns {Uint16Array|Uint32Array}
         * @private
         */

    }, {
        key: 'ReadIndexBuffer',
        value: function ReadIndexBuffer(reader) {
            var ibType = reader.ReadUInt8(),
                indexCount = reader.ReadUInt32();

            if (ibType === 0) {
                var indexes = new Uint16Array(indexCount);
                for (var i = 0; i < indexCount; ++i) {
                    indexes[i] = reader.ReadUInt16();
                }
                return indexes;
            } else {
                var _indexes = new Uint32Array(indexCount);
                for (var _i18 = 0; _i18 < indexCount; ++_i18) {
                    _indexes[_i18] = reader.ReadUInt32();
                }
                return _indexes;
            }
        }

        /**
         * ReadCurve
         * @returns {Tw2GeometryCurve}
         */

    }, {
        key: 'ReadCurve',
        value: function ReadCurve(reader) {
            var type = reader.ReadUInt8();
            if (type === 0) return null;

            var curve = new _geometry.Tw2GeometryCurve();
            curve.dimension = reader.ReadUInt8();
            curve.degree = reader.ReadUInt8();
            var knotCount = reader.ReadUInt32();
            curve.knots = new Float32Array(knotCount);
            for (var i = 0; i < knotCount; ++i) {
                curve.knots[i] = reader.ReadFloat32();
            }
            var controlCount = reader.ReadUInt32();
            curve.controls = new Float32Array(controlCount);
            for (var _i19 = 0; _i19 < controlCount; ++_i19) {
                curve.controls[_i19] = reader.ReadFloat32();
            }
            return curve;
        }
    }]);

    return Tw2GeometryRes;
}(_Tw2Resource2.Tw2Resource);

/**
 * Request Response Type
 * @type {string}
 */


Tw2GeometryRes.prototype.requestResponseType = 'arraybuffer';

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2VideoRes = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Device = __webpack_require__(2);

var _Tw2ResMan = __webpack_require__(6);

var _Tw2Logger = __webpack_require__(4);

var _Tw2Resource2 = __webpack_require__(12);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2VideoRes
 *
 * @property {?WebGLTexture} texture   - The video's webgl texture
 * @property {?HTMLVideoElement} video - The video
 * @property {number} width            - The texture's width
 * @property {number} height           - The texture's height
 * @property {boolean} cycle           - Enables video looping
 * @property {boolean} playOnLoad      - Plays the video as soon as it is able to
 * @property {number} _currentSampler  - The current sampler's hash
 * @property {number} _currentTime     - The video's current time
 * @property {boolean} _playable       - Identifies if the video is playable
 * @property {boolean} _isPlaying      - Identifies if the video is playing
 * @property {?Function} _onPlaying    - An optional callback which is fired when the video is playing
 * @property {?Function} _onPause      - An optional callback which is fired when the video is paused
 * @property {?Function} _onEnded      - An optional callback which is fired when the video has ended
 * @class
 */
var Tw2VideoRes = exports.Tw2VideoRes = function (_Tw2Resource) {
    _inherits(Tw2VideoRes, _Tw2Resource);

    function Tw2VideoRes() {
        _classCallCheck(this, Tw2VideoRes);

        var _this = _possibleConstructorReturn(this, (Tw2VideoRes.__proto__ || Object.getPrototypeOf(Tw2VideoRes)).call(this));

        _this.texture = null;
        _this.video = null;
        _this.width = 0;
        _this.height = 0;
        _this.cycle = true;
        _this.playOnLoad = true;

        _this._currentSampler = 0;
        _this._currentTime = -1;
        _this._playable = false;
        _this._isPlaying = false;

        _this._onPlaying = null;
        _this._onPause = null;
        _this._onEnded = null;
        return _this;
    }

    /**
     * Checks if the resource is good
     * @returns {boolean}
     */


    _createClass(Tw2VideoRes, [{
        key: 'IsGood',
        value: function IsGood() {
            this.KeepAlive();
            return this._isGood && this.video && this._playable;
        }

        /**
         * Keeps the resource alive
         */

    }, {
        key: 'KeepAlive',
        value: function KeepAlive() {
            this.activeFrame = _Tw2ResMan.resMan.activeFrame;
        }

        /**
         * Plays the animation
         * @param {boolean} [cycle] Sets playing to loop
         * @param {Function|null} [onFinished=null] Optional callback to fire when the video has finished
         */

    }, {
        key: 'Play',
        value: function Play() {
            var cycle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var onFinished = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            this.cycle = cycle;
            this._onEnded = onFinished;

            if (this.video && this._playable) {
                this.video.loop = this.cycle;
                this.video.play();
            } else {
                this.playOnLoad = true;
            }
        }

        /**
         * Pauses the video
         */

    }, {
        key: 'Pause',
        value: function Pause() {
            if (this.video) {
                this.video.pause();
            } else {
                this.playOnLoad = false;
            }
        }

        /**
         * Prepares the resource
         * @param {string} text
         */

    }, {
        key: 'Prepare',
        value: function Prepare(text) {
            var gl = _Tw2Device.device.gl;

            switch (text) {
                case 'mp4':
                case 'webm':
                case 'ogg':
                    this.texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, this.texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                    this.width = this.video.width;
                    this.height = this.video.height;
                    this.video.loop = this.cycle;
                    if (this.playOnLoad) this.video.play();
                    this.PrepareFinished(true);
            }
        }

        /**
         * Loads the resource from a path
         *
         * @param {string} path
         * @returns {boolean} returns true to tell the resMan not to handle http requests
         */

    }, {
        key: 'DoCustomLoad',
        value: function DoCustomLoad(path) {
            var _this2 = this;

            var ext = _Tw2ResMan.resMan.constructor.GetPathExt(path);
            this.LoadStarted();
            _Tw2ResMan.resMan._pendingLoads++;

            this.video = document.createElement('video');
            this.video.crossOrigin = 'anonymous';
            this.video.muted = true;

            /**
             * Fires on errors
             */
            this.video.onerror = function () {
                _Tw2ResMan.resMan._pendingLoads--;
                _Tw2Logger.logger.log('res.error', {
                    log: 'error',
                    src: ['Tw2TextureRes', 'DoCustomLoad'],
                    msg: 'Error loading resource',
                    type: 'http.error',
                    path: path
                });
                _this2.LoadFinished(false);
                _this2.PrepareFinished(false);
                _this2.video = null;
            };

            /**
             * Fires when the video is playable
             */
            this.video.oncanplay = function () {
                _this2._playable = true;
                _this2.video.oncanplay = null;
                _Tw2ResMan.resMan._pendingLoads--;
                _Tw2ResMan.resMan._prepareQueue.push([_this2, ext, null]);
                _this2.LoadFinished(true);
            };

            /**
             * Fires when the video has ended
             */
            this.video.onended = function () {
                _this2._isPlaying = false;
                if (_this2._onEnded) _this2._onEnded(_this2);
            };

            /**
             * Fires when the video is paused
             */
            this.video.onpause = function () {
                _this2._isPlaying = false;
                if (_this2._onPause) _this2._onPause(_this2);
            };

            /**
             * Fires when the video is playing
             */
            this.video.onplaying = function () {
                _this2._isPlaying = true;
                if (_this2._onPlaying) _this2._onPlaying(_this2);
            };

            this.video.src = path;
            return true;
        }

        /**
         * Unloads the video and texture from memory
         */

    }, {
        key: 'Unload',
        value: function Unload() {
            if (this.texture) {
                _Tw2Device.device.gl.deleteTexture(this.texture);
                this.texture = null;
            }

            this._isPlaying = false;
            this._playable = false;
            this.playOnLoad = true;
            this.video = null;
            return true;
        }

        /**
         * Bind
         * @param {Tw2SamplerState} sampler
         */

    }, {
        key: 'Bind',
        value: function Bind(sampler) {
            var d = _Tw2Device.device;

            this.KeepAlive();
            var targetType = sampler.samplerType;
            if (targetType !== d.gl.TEXTURE_2D) return;

            if (!this.texture) {
                d.gl.bindTexture(d.gl.TEXTURE_2D, d.GetFallbackTexture());
                return;
            }

            this._currentTime = this.video.currentTime;
            d.gl.bindTexture(d.gl.TEXTURE_2D, this.texture);
            d.gl.texImage2D(d.gl.TEXTURE_2D, 0, d.gl.RGBA, d.gl.RGBA, d.gl.UNSIGNED_BYTE, this.video);
            d.gl.bindTexture(d.gl.TEXTURE_2D, null);

            d.gl.bindTexture(targetType, this.texture);
            if (sampler.hash !== this._currentSampler) {
                sampler.Apply(false);
                this._currentSampler = sampler.hash;
            }
        }
    }]);

    return Tw2VideoRes;
}(_Tw2Resource2.Tw2Resource);

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2PostProcess = __webpack_require__(138);

Object.keys(_Tw2PostProcess).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2PostProcess[key];
    }
  });
});

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2PostProcess = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _global = __webpack_require__(17);

var _Tw2RenderTarget = __webpack_require__(56);

var _mesh = __webpack_require__(47);

var _resource = __webpack_require__(28);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Creates a bloom post effect
 *
 * @property {number} width
 * @property {number} height
 * @property {Tw2TextureRes} texture
 * @property {Tw2RenderTarget} quadRT0
 * @property {Tw2RenderTarget} quadRT1
 * @property {Array.<Tw2Effect|Object>} steps
 * @class
 */
var Tw2PostProcess = exports.Tw2PostProcess = function () {
    function Tw2PostProcess() {
        _classCallCheck(this, Tw2PostProcess);

        this.width = 0;
        this.height = 0;
        this.texture = null;
        this.quadRT0 = new _Tw2RenderTarget.Tw2RenderTarget();
        this.quadRT1 = new _Tw2RenderTarget.Tw2RenderTarget();
        this.steps = [{
            'effect': _mesh.Tw2Effect.create({
                effectFilePath: 'res:/Graphics/Effect/Managed/Space/PostProcess/ColorDownFilter4.fx',
                parameters: {
                    'g_texelSize': [1, 1, 1, 1],
                    'BlitCurrent': ''
                }
            }),
            'rt': this.quadRT1,
            'inputs': {
                'BlitCurrent': null
            }
        }, {
            'effect': _mesh.Tw2Effect.create({
                effectFilePath: 'res:/Graphics/Effect/Managed/Space/PostProcess/ColorHighPassFilter.fx',
                parameters: {
                    'LuminanceThreshold': 0.85,
                    'LuminanceScale': 2,
                    'BlitCurrent': ''
                }
            }),
            'rt': this.quadRT0,
            'inputs': {
                'BlitCurrent': this.quadRT1
            }
        }, {
            'effect': _mesh.Tw2Effect.create({
                effectFilePath: 'res:/Graphics/Effect/Managed/Space/PostProcess/ColorExpBlurHorizontalBig.fx',
                parameters: {
                    'g_texelSize': [1, 1, 1, 1],
                    'BlitCurrent': ''
                }
            }),
            'rt': this.quadRT1,
            'inputs': {
                'BlitCurrent': this.quadRT0
            }
        }, {
            'effect': _mesh.Tw2Effect.create({
                effectFilePath: 'res:/Graphics/Effect/Managed/Space/PostProcess/ColorExpBlurVerticalBig.fx',
                parameters: {
                    'g_texelSize': [1, 1, 1, 1],
                    'BlitCurrent': ''
                }
            }),
            'rt': this.quadRT0,
            'inputs': {
                'BlitCurrent': this.quadRT1
            }
        }, {
            'effect': _mesh.Tw2Effect.create({
                effectFilePath: 'res:/Graphics/Effect/Managed/Space/PostProcess/ColorUpFilter4_Add.fx',
                parameters: {
                    'g_texelSize': [1, 1, 1, 1],
                    'ScalingFactor': 1,
                    'BlitCurrent': '',
                    'BlitOriginal': ''
                }
            }),
            'rt': null,
            'inputs': {
                'BlitCurrent': this.quadRT0,
                'BlitOriginal': null
            }
        }];
    }

    /**
     * Internal render/update function. It is called every frame.
     */


    _createClass(Tw2PostProcess, [{
        key: 'Render',
        value: function Render() {
            var width = _global.device.viewportWidth,
                height = _global.device.viewportHeight;

            if (width <= 0 || height <= 0) return;

            if (this.texture === null) {
                this.texture = new _resource.Tw2TextureRes();
                this.texture.Attach(_global.device.gl.createTexture());
            }

            if (width !== this.width || height !== this.height) {
                _global.device.gl.bindTexture(_global.device.gl.TEXTURE_2D, this.texture.texture);
                _global.device.gl.texImage2D(_global.device.gl.TEXTURE_2D, 0, _global.device.gl.RGBA, width, height, 0, _global.device.gl.RGBA, _global.device.gl.UNSIGNED_BYTE, null);
                _global.device.gl.bindTexture(_global.device.gl.TEXTURE_2D, null);

                this.quadRT0.Create(width / 4, height / 4, false);
                this.quadRT1.Create(width / 4, height / 4, false);

                this.width = width;
                this.height = height;

                for (var i = 0; i < this.steps.length; ++i) {
                    var step = this.steps[i];
                    for (var name in step.inputs) {
                        if (step.inputs.hasOwnProperty(name)) {
                            if (step.inputs[name]) {
                                step.effect.parameters[name].textureRes = step.inputs[name].texture;
                            } else {
                                step.effect.parameters[name].textureRes = this.texture;
                            }
                        }
                    }

                    if ('g_texelSize' in step.effect.parameters && 'BlitCurrent' in step.inputs) {
                        var size = step.effect.parameters['g_texelSize'],
                            rt = step.inputs['BlitCurrent'];

                        if (rt) {
                            size.value[0] = 1.0 / rt.width;
                            size.value[1] = 1.0 / rt.width;
                        } else {
                            size.value[0] = 1.0 / width;
                            size.value[1] = 1.0 / width;
                        }
                        size.OnValueChanged();
                    }
                }
            }

            _global.device.gl.bindTexture(_global.device.gl.TEXTURE_2D, this.texture.texture);
            _global.device.gl.copyTexImage2D(_global.device.gl.TEXTURE_2D, 0, _global.device.alphaBlendBackBuffer ? _global.device.gl.RGBA : _global.device.gl.RGB, 0, 0, width, height, 0);
            _global.device.gl.bindTexture(_global.device.gl.TEXTURE_2D, null);
            _global.device.SetStandardStates(_global.device.RM_OPAQUE);

            for (var _i = 0; _i < this.steps.length; ++_i) {
                var _step = this.steps[_i];
                if (_step.rt !== null) {
                    _step.rt.Set();
                } else {
                    _global.device.gl.bindFramebuffer(_global.device.gl.FRAMEBUFFER, null);
                    _global.device.gl.viewport(0, 0, width, height);
                }
                _global.device.RenderFullScreenQuad(_step.effect);
            }
        }
    }]);

    return Tw2PostProcess;
}();

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2Float
 *
 * @property {number} value
 * @class
 */
var Tw2Float = exports.Tw2Float = function Tw2Float() {
    _classCallCheck(this, Tw2Float);

    this.value = 0;
};

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Frustum = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2Frustum
 *
 * @property {Array.<vec4>} planes
 * @property {vec3} viewPos
 * @property {vec3} viewDir
 * @property {number} halfWidthProjection
 * @class
 */
var Tw2Frustum = exports.Tw2Frustum = function () {
    function Tw2Frustum() {
        _classCallCheck(this, Tw2Frustum);

        this.planes = [_math.vec4.create(), _math.vec4.create(), _math.vec4.create(), _math.vec4.create(), _math.vec4.create(), _math.vec4.create()];
        this.viewPos = _math.vec3.create();
        this.viewDir = _math.vec3.create();
        this.halfWidthProjection = 1;
    }

    /**
     * Initializes the Tw2Frustum
     *
     * @param {mat4} view - View Matrix
     * @param {mat4} proj - Projection Matrix
     * @param {number} viewportSize
     * @param {mat4} [viewInverse] Optional viewInverse matrix
     * @param {mat4} [viewProjection] Optional viewProjection matrix
     */


    _createClass(Tw2Frustum, [{
        key: 'Initialize',
        value: function Initialize(view, proj, viewportSize, viewInverse, viewProjection) {
            var mat4_0 = Tw2Frustum.global.mat4_0;

            var viewInv = viewInverse ? viewInverse : _math.mat4.invert(mat4_0, view);
            this.viewPos.set(viewInv.subarray(12, 14));
            this.viewDir.set(viewInv.subarray(8, 10));
            this.halfWidthProjection = proj[0] * viewportSize * 0.5;

            var viewProj = viewProjection ? viewProjection : _math.mat4.multiply(mat4_0, proj, view);
            this.planes[0][0] = viewProj[2];
            this.planes[0][1] = viewProj[6];
            this.planes[0][2] = viewProj[10];
            this.planes[0][3] = viewProj[14];

            this.planes[1][0] = viewProj[3] + viewProj[0];
            this.planes[1][1] = viewProj[7] + viewProj[4];
            this.planes[1][2] = viewProj[11] + viewProj[8];
            this.planes[1][3] = viewProj[15] + viewProj[12];

            this.planes[2][0] = viewProj[3] - viewProj[1];
            this.planes[2][1] = viewProj[7] - viewProj[5];
            this.planes[2][2] = viewProj[11] - viewProj[9];
            this.planes[2][3] = viewProj[15] - viewProj[13];

            this.planes[3][0] = viewProj[3] - viewProj[0];
            this.planes[3][1] = viewProj[7] - viewProj[4];
            this.planes[3][2] = viewProj[11] - viewProj[8];
            this.planes[3][3] = viewProj[15] - viewProj[12];

            this.planes[4][0] = viewProj[3] + viewProj[1];
            this.planes[4][1] = viewProj[7] + viewProj[5];
            this.planes[4][2] = viewProj[11] + viewProj[9];
            this.planes[4][3] = viewProj[15] + viewProj[13];

            this.planes[5][0] = viewProj[3] - viewProj[2];
            this.planes[5][1] = viewProj[7] - viewProj[6];
            this.planes[5][2] = viewProj[11] - viewProj[10];
            this.planes[5][3] = viewProj[15] - viewProj[14];

            for (var i = 0; i < 6; ++i) {
                var len = _math.vec3.length(this.planes[i]);
                this.planes[i][0] /= len;
                this.planes[i][1] /= len;
                this.planes[i][2] /= len;
                this.planes[i][3] /= len;
            }
        }

        /**
         * Checks to see if a sphere is visible within the frustum
         *
         * @param {vec3} center
         * @param {number} radius
         * @returns {boolean}
         */

    }, {
        key: 'IsSphereVisible',
        value: function IsSphereVisible(center, radius) {
            for (var i = 0; i < 6; ++i) {
                if (this.planes[i][0] * center[0] + this.planes[i][1] * center[1] + this.planes[i][2] * center[2] + this.planes[i][3] < -radius) {
                    return false;
                }
            }
            return true;
        }

        /**
         * GetPixelSizeAcross
         *
         * @param {vec3} center
         * @param {number} radius
         * @returns {number}
         */

    }, {
        key: 'GetPixelSizeAcross',
        value: function GetPixelSizeAcross(center, radius) {
            var d = _math.vec3.subtract(Tw2Frustum.global.vec3_0, this.viewPos, center);

            var depth = _math.vec3.dot(this.viewDir, d),
                epsilon = 1e-5;

            if (depth < epsilon) depth = epsilon;
            if (radius < epsilon) return 0;

            var ratio = radius / depth;
            return ratio * this.halfWidthProjection * 2;
        }
    }]);

    return Tw2Frustum;
}();

/**
 * global variables
 */


Tw2Frustum.global = {
    vec3_0: _math.vec3.create(),
    mat4_0: _math.mat4.create()
};

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ColorCurve = exports.Tw2ColorKey = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ColorKey
 *
 * @property {vec4} value
 * @property {vec4} left
 * @property {vec4} right
 * @property {number} interpolation
 * @class
 */
var Tw2ColorKey = exports.Tw2ColorKey = function (_Tw2CurveKey) {
    _inherits(Tw2ColorKey, _Tw2CurveKey);

    function Tw2ColorKey() {
        _classCallCheck(this, Tw2ColorKey);

        var _this = _possibleConstructorReturn(this, (Tw2ColorKey.__proto__ || Object.getPrototypeOf(Tw2ColorKey)).call(this));

        _this.value = _math.vec4.create();
        _this.left = _math.vec4.create();
        _this.right = _math.vec4.create();
        _this.interpolation = 0;
        return _this;
    }

    return Tw2ColorKey;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2ColorCurve
 *
 * @property {number} start
 * @property {vec4} currentValue
 * @property {number} extrapolation
 * @property {Array.<Tw2ColorKey>} keys
 * @property {number} _currentKey
 * @property {number} length
 * @class
 */


var Tw2ColorCurve = exports.Tw2ColorCurve = function (_Tw2Curve) {
    _inherits(Tw2ColorCurve, _Tw2Curve);

    function Tw2ColorCurve() {
        _classCallCheck(this, Tw2ColorCurve);

        var _this2 = _possibleConstructorReturn(this, (Tw2ColorCurve.__proto__ || Object.getPrototypeOf(Tw2ColorCurve)).call(this));

        _this2.start = 0;
        _this2.value = _math.vec4.create();
        _this2.extrapolation = 0;
        _this2.keys = [];
        _this2._currentKey = 1;
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2ColorCurve, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.value);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {vec4} value
         * @returns {vec4} value
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            if (this.length === 0) {
                return _math.vec4.copy(value, this.value);
            }

            var firstKey = this.keys[0],
                lastKey = this.keys[this.keys.length - 1];

            if (time >= lastKey.time) {
                switch (this.extrapolation) {
                    case Tw2ColorCurve.Extrapolation.NONE:
                        return _math.vec4.copy(value, this.value);

                    case Tw2ColorCurve.Extrapolation.CONSTANT:
                        return _math.vec4.copy(value, lastKey.value);

                    case Tw2ColorCurve.Extrapolation.GRADIENT:
                        return _math.vec4.scaleAndAdd(value, lastKey.value, lastKey.right, time - lastKey.time);

                    default:
                        time = time % lastKey.time;
                }
            } else if (time < 0 || time < firstKey.time) {
                switch (this.extrapolation) {
                    case Tw2ColorCurve.Extrapolation.NONE:
                        return _math.vec4.copy(value, this.value);

                    case Tw2ColorCurve.Extrapolation.GRADIENT:
                        return _math.vec4.scaleAndAdd(value, firstKey.value, firstKey.left, time * this.length - lastKey.time);

                    default:
                        return _math.vec4.copy(value, firstKey.value);
                }
            }

            var ck = this.keys[this._currentKey],
                ck_1 = this.keys[this._currentKey - 1];

            while (time >= ck.time || time < ck_1.time) {
                if (time < ck_1.time) this._currentKey = 0;
                this._currentKey++;
                ck = this.keys[this._currentKey];
                ck_1 = this.keys[this._currentKey - 1];
            }

            var nt = (time - ck_1.time) / (ck.time - ck_1.time);

            switch (ck_1.interpolation) {
                case Tw2ColorCurve.Interpolation.CONSTANT:
                    return _math.vec4.copy(value, ck_1.value);

                default:
                    value[0] = ck_1.value[0] * (1 - nt) + ck.value[0] * nt;
                    value[1] = ck_1.value[1] * (1 - nt) + ck.value[1] * nt;
                    value[2] = ck_1.value[2] * (1 - nt) + ck.value[2] * nt;
                    value[3] = ck_1.value[3] * (1 - nt) + ck.value[3] * nt;
                    return value;
            }
        }
    }]);

    return Tw2ColorCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2ColorCurve.inputDimension = 4;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2ColorCurve.ouputDimension = 4;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2ColorCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2ColorCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE;

/**
 * The curve's key constructor
 * @type {Tw2ColorKey}
 */
Tw2ColorCurve.Key = Tw2ColorKey;

/**
 * Extrapolation types
 * @type {{NONE: number, CONSTANT: number, GRADIENT: number, CYCLE: number}}
 */
Tw2ColorCurve.Extrapolation = {
    NONE: 0,
    CONSTANT: 1,
    GRADIENT: 2,
    CYCLE: 3
};

/**
 * Interpolation types
 * @type {{NONE: number, CONSTANT: number, LINEAR: number}}
 */
Tw2ColorCurve.Interpolation = {
    NONE: 0,
    CONSTANT: 1,
    LINEAR: 2
};

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ColorCurve2 = exports.Tw2ColorKey2 = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ColorKey2
 *
 * @property {number} time
 * @property {vec4} value
 * @property {vec4} leftTangent
 * @property {vec4} rightTangent
 * @property {number} interpolation
 * @class
 */
var Tw2ColorKey2 = exports.Tw2ColorKey2 = function (_Tw2CurveKey) {
    _inherits(Tw2ColorKey2, _Tw2CurveKey);

    function Tw2ColorKey2() {
        _classCallCheck(this, Tw2ColorKey2);

        var _this = _possibleConstructorReturn(this, (Tw2ColorKey2.__proto__ || Object.getPrototypeOf(Tw2ColorKey2)).call(this));

        _this.value = _math.vec4.create();
        _this.leftTangent = _math.vec4.create();
        _this.rightTangent = _math.vec4.create();
        _this.interpolation = 1;
        return _this;
    }

    return Tw2ColorKey2;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2ColorCurve2
 *
 * @property {boolean} cycle
 * @property {boolean} reversed
 * @property {number} timeOffset
 * @property {number} timeScale
 * @property {vec4} startValue=[0,0,0,1]
 * @property {vec4} currentValue=[0,0,0,1]
 * @property {vec4} endValue=[0,0,0,1]
 * @property {vec4} startTangent
 * @property {vec4} endTangent
 * @property {number} interpolation
 * @property {Array.<Tw2ColorKey2>} keys
 * @class
 */


var Tw2ColorCurve2 = exports.Tw2ColorCurve2 = function (_Tw2Curve) {
    _inherits(Tw2ColorCurve2, _Tw2Curve);

    function Tw2ColorCurve2() {
        _classCallCheck(this, Tw2ColorCurve2);

        var _this2 = _possibleConstructorReturn(this, (Tw2ColorCurve2.__proto__ || Object.getPrototypeOf(Tw2ColorCurve2)).call(this));

        _this2.cycle = false;
        _this2.reversed = false;
        _this2.timeOffset = 0;
        _this2.timeScale = 1;
        _this2.startValue = _math.vec4.fromValues(0, 0, 0, 1);
        _this2.currentValue = _math.vec4.fromValues(0, 0, 0, 1);
        _this2.endValue = _math.vec4.fromValues(0, 0, 0, 1);
        _this2.startTangent = _math.vec4.create();
        _this2.endTangent = _math.vec4.create();
        _this2.interpolation = 1;
        _this2.keys = [];
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2ColorCurve2, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort2(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.currentValue);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {vec4} value
         * @returns {vec4}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            time = time / this.timeScale + this.timeOffset;
            if (this.length <= 0 || time <= 0) {
                return _math.vec4.copy(value, this.startValue);
            }

            if (time > this.length) {
                if (this.cycle) {
                    time = time % this.length;
                } else if (this.reversed) {
                    return _math.vec4.copy(value, this.startValue);
                } else {
                    return _math.vec4.copy(value, this.endValue);
                }
            }

            if (this.reversed) {
                time = this.length - time;
            }

            if (this.keys.length === 0) {
                return this.Interpolate(time, null, null, value);
            }

            var startKey = this.keys[0],
                endKey = this.keys[this.keys.length - 1];

            if (time <= startKey.time) {
                return this.Interpolate(time, null, startKey, value);
            } else if (time >= endKey.time) {
                return this.Interpolate(time, endKey, null, value);
            }

            for (var i = 0; i + 1 < this.keys.length; ++i) {
                startKey = this.keys[i];
                endKey = this.keys[i + 1];
                if (startKey.time <= time && endKey.time > time) break;
            }

            return this.Interpolate(time, startKey, endKey, value);
        }

        /**
         * Interpolate
         * @param {number} time
         * @param {Tw2ColorKey2} lastKey
         * @param {Tw2ColorKey2} nextKey
         * @param {vec4} value
         * @returns {vec4} value
         */

    }, {
        key: 'Interpolate',
        value: function Interpolate(time, lastKey, nextKey, value) {
            _math.vec4.copy(value, this.startValue);

            var startValue = this.startValue,
                endValue = this.endValue,
                interp = this.interpolation,
                deltaTime = this.length;

            if (lastKey !== null) {
                interp = lastKey.interpolation;
                time -= lastKey.time;
            }

            switch (interp) {
                case Tw2ColorCurve2.Interpolation.LINEAR:
                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        endValue = nextKey.value;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        deltaTime = this.length - lastKey.time;
                    }
                    value[0] = startValue[0] + (endValue[0] - startValue[0]) * (time / deltaTime);
                    value[1] = startValue[1] + (endValue[1] - startValue[1]) * (time / deltaTime);
                    value[2] = startValue[2] + (endValue[2] - startValue[2]) * (time / deltaTime);
                    value[3] = startValue[3] + (endValue[3] - startValue[3]) * (time / deltaTime);
                    return value;

                default:
                    return value;
            }
        }
    }]);

    return Tw2ColorCurve2;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2ColorCurve2.inputDimension = 4;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2ColorCurve2.outputDimension = 4;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2ColorCurve2.valueProperty = 'currentValue';

/**
 * The curve's type
 * @type {number}
 */
Tw2ColorCurve2.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE2;

/**
 * The curve's key constructor
 * @type {Tw2ColorKey2}
 */
Tw2ColorCurve2.Key = Tw2ColorKey2;

/**
 * Interpolation types
 * @type {{CONSTANT: number, LINEAR: number}}
 */
Tw2ColorCurve2.Interpolation = {
    CONSTANT: 0,
    LINEAR: 1
};

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2EventCurve = exports.Tw2EventKey = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2EventKey
 *
 * @property {string} value
 * @class
 */
var Tw2EventKey = exports.Tw2EventKey = function (_Tw2CurveKey) {
    _inherits(Tw2EventKey, _Tw2CurveKey);

    function Tw2EventKey() {
        _classCallCheck(this, Tw2EventKey);

        var _this = _possibleConstructorReturn(this, (Tw2EventKey.__proto__ || Object.getPrototypeOf(Tw2EventKey)).call(this));

        _this.value = '';
        return _this;
    }

    return Tw2EventKey;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2EventCurve
 *
 * @property {string} value
 * @property {Array.<Tw2EventKey>} keys
 * @property {number} extrapolation
 * @property {number} _time
 * @property {number} _currentKey
 * @property {number} _length
 * @class
 */


var Tw2EventCurve = exports.Tw2EventCurve = function (_Tw2Curve) {
    _inherits(Tw2EventCurve, _Tw2Curve);

    function Tw2EventCurve() {
        _classCallCheck(this, Tw2EventCurve);

        var _this2 = _possibleConstructorReturn(this, (Tw2EventCurve.__proto__ || Object.getPrototypeOf(Tw2EventCurve)).call(this));

        _this2.value = '';
        _this2.keys = [];
        _this2.extrapolation = 0;
        _this2._time = 0;
        _this2._currentKey = 0;
        _this2._length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2EventCurve, [{
        key: 'Sort',
        value: function Sort() {
            if (this.keys.length) {
                this.keys.sort(_Tw2Curve2.Tw2Curve.Compare);
                this._length = this.keys[this.keys.length - 1].time;
            }
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this._length;
        }

        /**
         * Gets a value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            if (this._length <= 0) {
                return this.value;
            }

            var before = this._time;
            this._time = time;
            if (this._time < before) {
                this._currentKey = 0;
            }

            if (this.extrapolation === Tw2EventCurve.Extrapolation.CYCLE) {
                var now = this._time % this._length;
                if (now < before) this._currentKey = 0;
                this._time = now;
            }

            while (this._currentKey < this.keys.length && this._time >= this.keys[this._currentKey].time) {
                this.value = this.keys[this._currentKey].value;
                ++this._currentKey;
            }
        }
    }]);

    return Tw2EventCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2EventCurve.dimension = 1;

/**
 * The curve's output dimension
 * @type {number}
 */
Tw2EventCurve.outputDimension = 1;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2EventCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2EventCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE;

/**
 * The curve's key constructor
 * @type {Tw2EventKey}
 */
Tw2EventCurve.Key = Tw2EventKey;

/**
 * Extrapolation types
 * @type {{NONE: number, CYCLE: number}}
 */
Tw2EventCurve.Extrapolation = {
    NONE: 0,
    CYCLE: 3
};

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2PerlinCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2PerlinCurve
 *
 * @property {number} start
 * @property {number} speed
 * @property {number} alpha
 * @property {number} beta
 * @property {number} offset
 * @property {number} scale
 * @property {number} N
 * @property {number} _startOffset
 * @class
 */
var Tw2PerlinCurve = exports.Tw2PerlinCurve = function (_Tw2Curve) {
  _inherits(Tw2PerlinCurve, _Tw2Curve);

  function Tw2PerlinCurve() {
    _classCallCheck(this, Tw2PerlinCurve);

    var _this = _possibleConstructorReturn(this, (Tw2PerlinCurve.__proto__ || Object.getPrototypeOf(Tw2PerlinCurve)).call(this));

    _this.value = 0;
    _this.start = 0;
    _this.speed = 1;
    _this.alpha = 1.1;
    _this.beta = 2;
    _this.offset = 0;
    _this.scale = 1;
    _this.N = 3;
    _this._startOffset = Math.random() * 100;
    return _this;
  }

  /**
   * Updates the current value at the given time
   * @param {number} time
   */


  _createClass(Tw2PerlinCurve, [{
    key: 'UpdateValue',
    value: function UpdateValue(time) {
      this.value = this.GetValueAt(time);
    }

    /**
     * Gets a value at a specific time
     * @param {number} time
     * @returns {number}
     */

  }, {
    key: 'GetValueAt',
    value: function GetValueAt(time) {
      time -= this._startOffset;
      return (_math.noise.perlin1D(time * this.speed, this.alpha, this.beta, this.N) + 1) / 2 * this.scale + this.offset;
    }
  }]);

  return Tw2PerlinCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's dimension
 * @type {number}
 */


Tw2PerlinCurve.outputDimension = 1;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2PerlinCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2PerlinCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE_NO_KEYS;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2QuaternionCurve = exports.Tw2QuaternionKey2 = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2QuaternionKey2
 *
 * @property {quat} value
 * @property {vec4} leftTangent
 * @property {vec4} rightTangent
 * @property {number} interpolation
 * @class
 */
var Tw2QuaternionKey2 = exports.Tw2QuaternionKey2 = function (_Tw2CurveKey) {
    _inherits(Tw2QuaternionKey2, _Tw2CurveKey);

    function Tw2QuaternionKey2() {
        _classCallCheck(this, Tw2QuaternionKey2);

        var _this = _possibleConstructorReturn(this, (Tw2QuaternionKey2.__proto__ || Object.getPrototypeOf(Tw2QuaternionKey2)).call(this));

        _this.value = _math.quat.create();
        _this.leftTangent = _math.vec4.create();
        _this.rightTangent = _math.vec4.create();
        _this.interpolation = 1;
        return _this;
    }

    return Tw2QuaternionKey2;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2QuaternionCurve
 *
 * @property {boolean} cycle
 * @property {boolean} reversed
 * @property {number} timeOffset
 * @property {number} timeScale
 * @property {quat} startValue
 * @property {quat} currentValue
 * @property {quat} endValue
 * @property {vec4} startTangent
 * @property {vec4} endTangent
 * @property {number} interpolation
 * @property {Array.<Tw2QuaternionKey>} keys
 * @property {number} length
 * @class
 */


var Tw2QuaternionCurve = exports.Tw2QuaternionCurve = function (_Tw2Curve) {
    _inherits(Tw2QuaternionCurve, _Tw2Curve);

    function Tw2QuaternionCurve() {
        _classCallCheck(this, Tw2QuaternionCurve);

        var _this2 = _possibleConstructorReturn(this, (Tw2QuaternionCurve.__proto__ || Object.getPrototypeOf(Tw2QuaternionCurve)).call(this));

        _this2.cycle = false;
        _this2.reversed = false;
        _this2.timeOffset = 0;
        _this2.timeScale = 1;
        _this2.startValue = _math.quat.create();
        _this2.currentValue = _math.quat.create();
        _this2.endValue = _math.quat.create();
        _this2.startTangent = _math.vec4.create();
        _this2.endTangent = _math.vec4.create();
        _this2.interpolation = 1;
        _this2.keys = [];
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2QuaternionCurve, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort2(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.currentValue);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {quat} value
         * @returns {quat}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            time = time / this.timeScale + this.timeOffset;

            if (this.length <= 0 || time <= 0) {
                value[0] = this.startValue[0];
                value[1] = this.startValue[1];
                value[2] = this.startValue[2];
                return value;
            }

            if (time > this.length) {
                if (this.cycle) {
                    time = time % this.length;
                } else if (this.reversed) {
                    value[0] = this.startValue[0];
                    value[1] = this.startValue[1];
                    value[2] = this.startValue[2];
                    return value;
                } else {
                    value[0] = this.endValue[0];
                    value[1] = this.endValue[1];
                    value[2] = this.endValue[2];
                    return value;
                }
            }

            if (this.reversed) {
                time = this.length - time;
            }

            if (this.keys.length === 0) {
                return this.Interpolate(time, null, null, value);
            }

            var startKey = this.keys[0],
                endKey = this.keys[this.keys.length - 1];

            if (time <= startKey.time) {
                return this.Interpolate(time, null, startKey, value);
            } else if (time >= endKey.time) {
                return this.Interpolate(time, endKey, null, value);
            }

            for (var i = 0; i + 1 < this.keys.length; ++i) {
                startKey = this.keys[i];
                endKey = this.keys[i + 1];
                if (startKey.time <= time && endKey.time > time) break;
            }

            return this.Interpolate(time, startKey, endKey, value);
        }

        /**
         * Interpolate
         * @param {number} time
         * @param {null|Tw2QuaternionKey} lastKey
         * @param {null|Tw2QuaternionKey} nextKey
         * @param {quat} value
         * @returns {*}
         */

    }, {
        key: 'Interpolate',
        value: function Interpolate(time, lastKey, nextKey, value) {
            value[0] = this.startValue[0];
            value[1] = this.startValue[1];
            value[2] = this.startValue[2];

            var startValue = this.startValue,
                endValue = this.endValue,
                interp = this.interpolation,
                deltaTime = this.length;

            if (lastKey !== null) {
                interp = lastKey.interpolation;
                time -= lastKey.time;
            }

            switch (interp) {
                case Tw2QuaternionCurve.Interpolation.SPHERICAL_LINEAR:
                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        endValue = nextKey.value;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        deltaTime = this.length - lastKey.time;
                    }

                    _math.quat.slerp(value, startValue, endValue, time / deltaTime);
                    return value;

                default:
                    return value;
            }
        }
    }]);

    return Tw2QuaternionCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2QuaternionCurve.inputDimension = 4;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2QuaternionCurve.outputDimension = 4;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2QuaternionCurve.valueProperty = 'currentValue';

/**
 * The curve's type
 * @type {number}
 */
Tw2QuaternionCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE2;

/**
 * The curve's key constructor
 * @type {Tw2QuaternionKey2}
 */
Tw2QuaternionCurve.Key = Tw2QuaternionKey2;

/**
 * Interpolation types
 * @type {{CONSTANT: number, SPHERICAL_LINEAR: number}}
 */
Tw2QuaternionCurve.Interpolation = {
    CONSTANT: 0,
    SPHERICAL_LINEAR: 4
};

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2RandomConstantCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2RandomConstantCurve
 *
 * @property {number} currentValue
 * @property {number} min
 * @property {number} max
 * @property {boolean} hold
 * @class
 */
var Tw2RandomConstantCurve = exports.Tw2RandomConstantCurve = function (_Tw2Curve) {
  _inherits(Tw2RandomConstantCurve, _Tw2Curve);

  function Tw2RandomConstantCurve() {
    _classCallCheck(this, Tw2RandomConstantCurve);

    var _this = _possibleConstructorReturn(this, (Tw2RandomConstantCurve.__proto__ || Object.getPrototypeOf(Tw2RandomConstantCurve)).call(this));

    _this.value = 0;
    _this.min = 0;
    _this.max = 1;
    _this.hold = true;
    return _this;
  }

  /**
   * Updates the current value at the given time
   */


  _createClass(Tw2RandomConstantCurve, [{
    key: 'UpdateValue',
    value: function UpdateValue() {
      this.value = this.GetValueAt();
    }

    /**
     * Gets a value at a specific time
     * @returns {number}
     */

  }, {
    key: 'GetValueAt',
    value: function GetValueAt() {
      return this.hold ? this.value : this.min + (this.max - this.min) * Math.random();
    }
  }]);

  return Tw2RandomConstantCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's dimension
 * @type {number}
 */


Tw2RandomConstantCurve.outputDimension = 1;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2RandomConstantCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2RandomConstantCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE_NO_KEYS;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2RigidOrientation = exports.Tw2Torque = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2Torque
 *
 * @property {quat} rot0
 * @property {vec3} omega0
 * @property {vec3} torque
 * @class
 */
var Tw2Torque = exports.Tw2Torque = function (_Tw2CurveKey) {
    _inherits(Tw2Torque, _Tw2CurveKey);

    function Tw2Torque() {
        _classCallCheck(this, Tw2Torque);

        var _this = _possibleConstructorReturn(this, (Tw2Torque.__proto__ || Object.getPrototypeOf(Tw2Torque)).call(this));

        _this.rot0 = _math.quat.create();
        _this.omega0 = _math.vec3.create();
        _this.torque = _math.vec3.create();
        return _this;
    }

    return Tw2Torque;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2RigidOrientation
 *
 * @property {string} name
 * @property {number} I
 * @property {number} drag
 * @property {quat} value
 * @property {number} start
 * @property {Array.<Tw2Torque>} states
 * @property {number} length
 * @class
 */


var Tw2RigidOrientation = exports.Tw2RigidOrientation = function (_Tw2Curve) {
    _inherits(Tw2RigidOrientation, _Tw2Curve);

    function Tw2RigidOrientation() {
        _classCallCheck(this, Tw2RigidOrientation);

        var _this2 = _possibleConstructorReturn(this, (Tw2RigidOrientation.__proto__ || Object.getPrototypeOf(Tw2RigidOrientation)).call(this));

        _this2.name = '';
        _this2.I = 1;
        _this2.drag = 1;
        _this2.value = _math.quat.create();
        _this2.start = 0;
        _this2.states = [];
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2RigidOrientation, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort(this, this.states);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.value);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {quat} value
         * @returns {quat}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            if (this.states.length === 0 || time < 0 || time < this.states[0].time) {
                return _math.quat.copy(value, this.value);
            }

            var key = 0;
            if (time >= this.states[this.states.length - 1].time) {
                key = this.states.length - 1;
            } else {
                for (; key + 1 < this.states.length; ++key) {
                    if (time >= this.states[key].time && time < this.states[key + 1].time) {
                        break;
                    }
                }
            }

            var vec3_0 = _Tw2Curve2.Tw2Curve.global.vec3_0,
                quat_0 = _Tw2Curve2.Tw2Curve.global.quat_0;

            var ck = this.states[key];
            _math.vec3.exponentialDecay(vec3_0, ck.omega0, ck.torque, this.I, this.drag, time - ck.time);
            _math.quat.exp(quat_0, vec3_0);
            _math.quat.multiply(value, this.states[key].rot0, quat_0);
            return value;
        }
    }]);

    return Tw2RigidOrientation;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2RigidOrientation.inputDimension = 4;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2RigidOrientation.outputDimension = 4;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2RigidOrientation.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2RigidOrientation.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE;

/**
 * The curve's key constructor
 * @type {Tw2Torque}
 */
Tw2RigidOrientation.Key = Tw2Torque;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2RotationCurve = exports.Tw2QuaternionKey = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2QuaternionKey
 *
 * @property {number} time
 * @property {quat} value
 * @property {vec4} leftTangent
 * @property {vec4} rightTangent
 * @property {number} interpolation
 * @class
 */
var Tw2QuaternionKey = exports.Tw2QuaternionKey = function (_Tw2CurveKey) {
    _inherits(Tw2QuaternionKey, _Tw2CurveKey);

    function Tw2QuaternionKey() {
        _classCallCheck(this, Tw2QuaternionKey);

        var _this = _possibleConstructorReturn(this, (Tw2QuaternionKey.__proto__ || Object.getPrototypeOf(Tw2QuaternionKey)).call(this));

        _this.value = _math.quat.create();
        _this.left = _math.vec4.create();
        _this.right = _math.vec4.create();
        _this.interpolation = 5;
        return _this;
    }

    return Tw2QuaternionKey;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2RotationCurve
 *
 * @property {number} start
 * @property {quat} value
 * @property {number} extrapolation
 * @property {Array.<Tw2QuaternionKey>} keys
 * @property {number} _currentKey
 * @property {number} length
 * @class`
 */


var Tw2RotationCurve = exports.Tw2RotationCurve = function (_Tw2Curve) {
    _inherits(Tw2RotationCurve, _Tw2Curve);

    function Tw2RotationCurve() {
        _classCallCheck(this, Tw2RotationCurve);

        var _this2 = _possibleConstructorReturn(this, (Tw2RotationCurve.__proto__ || Object.getPrototypeOf(Tw2RotationCurve)).call(this));

        _this2.start = 0;
        _this2.value = _math.quat.create();
        _this2.extrapolation = 0;
        _this2.keys = [];
        _this2._currentKey = 1;
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's children
     */


    _createClass(Tw2RotationCurve, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.value);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {quat} value
         * @returns {quat}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            if (this.length === 0) {
                return _math.quat.copy(value, this.value);
            }

            var scratch = _Tw2Curve2.Tw2Curve.global,
                firstKey = this.keys[0],
                lastKey = this.keys[this.keys.length - 1];

            if (time >= lastKey.time) {
                switch (this.extrapolation) {
                    case Tw2RotationCurve.Extrapolation.NONE:
                        return _math.quat.copy(value, this.value);

                    case Tw2RotationCurve.Extrapolation.CONSTANT:
                        return _math.quat.copy(value, lastKey.value);

                    default:
                        time = time % lastKey.time;
                }
            } else if (time < 0 || time < firstKey.time) {
                switch (this.extrapolation) {
                    case Tw2RotationCurve.Extrapolation.NONE:
                        return _math.quat.copy(value, this.value);

                    default:
                        return _math.quat.copy(value, firstKey.value);
                }
            }

            var ck = this.keys[this._currentKey],
                ck_1 = this.keys[this._currentKey - 1];

            while (time >= ck.time || time < ck_1.time) {
                if (time < ck_1.time) this._currentKey = 0;
                this._currentKey++;
                ck = this.keys[this._currentKey];
                ck_1 = this.keys[this._currentKey - 1];
            }

            var nt = (time - ck_1.time) / (ck.time - ck_1.time);
            switch (ck_1.interpolation) {
                case Tw2RotationCurve.Interpolation.CONSTANT:
                    return _math.quat.copy(value, ck_1.value);

                case Tw2RotationCurve.Interpolation.LINEAR:
                    value[0] = ck_1.value[0] * (1 - nt) + ck.value[0] * nt;
                    value[1] = ck_1.value[1] * (1 - nt) + ck.value[1] * nt;
                    value[2] = ck_1.value[2] * (1 - nt) + ck.value[2] * nt;
                    value[3] = ck_1.value[3] * (1 - nt) + ck.value[3] * nt;
                    return value;

                case Tw2RotationCurve.Interpolation.HERMITE:
                    var collect = _math.quat.identity(scratch.quat_0),
                        arr = [ck_1.value, ck_1.right, ck.left, ck.value];

                    for (var i = 3; i > 0; i--) {
                        var power = _math.num.biCumulative(nt, i);
                        if (power > 1) _math.quat.multiply(value, collect, arr[i]);
                        value[0] = -arr[i - 1][0];
                        value[1] = -arr[i - 1][1];
                        value[2] = -arr[i - 1][2];
                        value[3] = arr[i - 1][3];
                        _math.quat.multiply(value, value, arr[i]);
                        _math.quat.pow(value, value, power);
                        _math.quat.multiply(collect, collect, value);
                    }
                    return _math.quat.multiply(value, collect, ck_1.value);

                case Tw2RotationCurve.Interpolation.SLERP:
                    return _math.quat.slerp(value, ck_1.value, ck.value, nt);

                default:
                    return _math.quat.sqlerp(value, ck_1.value, ck_1.right, ck.left, ck.value, nt);
            }
        }
    }]);

    return Tw2RotationCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2RotationCurve.outputDimention = 4;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2RotationCurve.inputDimension = 4;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2RotationCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2RotationCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE;

/**
 * The curve's key constructor
 * @type {Tw2QuaternionKey}
 */
Tw2RotationCurve.Child = Tw2QuaternionKey;

/**
 * Extrapolation types
 * @type {{NONE: number, CONSTANT: number, GRADIENT: number, CYCLE: number}}
 */
Tw2RotationCurve.Extrapolation = {
    NONE: 0,
    CONSTANT: 1,
    GRADIENT: 2,
    CYCLE: 3
};

/**
 * Interpolation types
 * @type {{NONE: number, CONSTANT: number, LINEAR: number, HERMITE: number, SLERP: number, SQUAD: number}}
 */
Tw2RotationCurve.Interpolation = {
    NONE: 0,
    CONSTANT: 1,
    LINEAR: 2,
    HERMITE: 3,
    SLERP: 5,
    SQUAD: 6
};

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ScalarCurve = exports.Tw2ScalarKey = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ScalarKey
 *
 * @property {number} value
 * @property {number} left
 * @property {number} right
 * @property {number} interpolation
 * @class
 */
var Tw2ScalarKey = exports.Tw2ScalarKey = function (_Tw2CurveKey) {
    _inherits(Tw2ScalarKey, _Tw2CurveKey);

    function Tw2ScalarKey() {
        _classCallCheck(this, Tw2ScalarKey);

        var _this = _possibleConstructorReturn(this, (Tw2ScalarKey.__proto__ || Object.getPrototypeOf(Tw2ScalarKey)).call(this));

        _this.value = 0;
        _this.left = 0;
        _this.right = 0;
        _this.interpolation = 0;
        return _this;
    }

    return Tw2ScalarKey;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2ScalarCurve
 *
 * @property {number} start
 * @property {number} timeScale
 * @property {number} timeOffset
 * @property {number} value
 * @property {number} extrapolation
 * @property {Array.<Tw2ScalarKey>} keys
 * @property {number} _currentKey
 * @property {number} length
 * @class
 */


var Tw2ScalarCurve = exports.Tw2ScalarCurve = function (_Tw2Curve) {
    _inherits(Tw2ScalarCurve, _Tw2Curve);

    function Tw2ScalarCurve() {
        _classCallCheck(this, Tw2ScalarCurve);

        var _this2 = _possibleConstructorReturn(this, (Tw2ScalarCurve.__proto__ || Object.getPrototypeOf(Tw2ScalarCurve)).call(this));

        _this2.start = 0;
        _this2.timeScale = 1;
        _this2.timeOffset = 0;
        _this2.value = 0;
        _this2.extrapolation = 0;
        _this2.keys = [];
        _this2._currentKey = 1;
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2ScalarCurve, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.value = this.GetValueAt(time);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @returns {number}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time) {
            time = time / this.timeScale - this.timeOffset;

            if (this.length === 0) {
                return this.value;
            }

            var firstKey = this.keys[0],
                lastKey = this.keys[this.keys.length - 1];

            if (time >= lastKey.time) {
                switch (this.extrapolation) {
                    case Tw2ScalarCurve.Extrapolation.NONE:
                        return this.value;

                    case Tw2ScalarCurve.Extrapolation.CONSTANT:
                        return lastKey.value;

                    case Tw2ScalarCurve.Extrapolation.GRADIENT:
                        return lastKey.value + (time - lastKey.time) * lastKey.right;

                    default:
                        time = time % lastKey.time;
                }
            } else if (time < 0 || time < firstKey.time) {
                switch (this.extrapolation) {
                    case Tw2ScalarCurve.Extrapolation.NONE:
                        return this.value;

                    case Tw2ScalarCurve.Extrapolation.GRADIENT:
                        return firstKey.value + (time * this.length - lastKey.time) * firstKey.left;

                    default:
                        return firstKey.value;
                }
            }

            var ck = this.keys[this._currentKey],
                ck_1 = this.keys[this._currentKey - 1];

            while (time >= ck.time || time < ck_1.time) {
                if (time < ck_1.time) this._currentKey = 0;
                this._currentKey++;
                ck = this.keys[this._currentKey];
                ck_1 = this.keys[this._currentKey - 1];
            }

            var nt = (time - ck_1.time) / (ck.time - ck_1.time);
            switch (ck_1.interpolation) {
                case Tw2ScalarCurve.Interpolation.CONSTANT:
                    return ck_1.value;

                case Tw2ScalarCurve.Interpolation.LINEAR:
                    return ck_1.value * (1 - nt) + ck.value * nt;

                case Tw2ScalarCurve.Interpolation.HERMITE:
                    var k3 = 2 * nt * nt * nt - 3 * nt * nt + 1,
                        k2 = -2 * nt * nt * nt + 3 * nt * nt,
                        k1 = nt * nt * nt - 2 * nt * nt + nt,
                        k0 = nt * nt * nt - nt * nt;
                    return k3 * ck_1.value + k2 * ck.value + k1 * ck_1.right + k0 * ck.left;

                default:
                    var sq = Math.sqrt(ck_1.value / ck.value),
                        exponent = Math.exp(-time / ck_1.right),
                        ret = 1.0 + (sq - 1.0) * exponent;
                    return ret * ret * ck.value;
            }
        }
    }]);

    return Tw2ScalarCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2ScalarCurve.inputDimension = 1;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2ScalarCurve.outputDimension = 1;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2ScalarCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2ScalarCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE;

/**
 * The curve's key constructor
 * @type {Tw2ScalarKey}
 */
Tw2ScalarCurve.Key = Tw2ScalarKey;

/**
 * Extrapolation types
 * @type {{NONE: number, CONSTANT: number, GRADIENT: number, CYCLE: number}}
 */
Tw2ScalarCurve.Extrapolation = {
    NONE: 0,
    CONSTANT: 1,
    GRADIENT: 2,
    CYCLE: 3
};

/**
 * Interpolation types
 * @type {{NONE: number, CONSTANT: number, LINEAR: number, HERMITE: number, CATMULROM: number}}
 */
Tw2ScalarCurve.Interpolation = {
    NONE: 0,
    CONSTANT: 1,
    LINEAR: 2,
    HERMITE: 3,
    CATMULROM: 4
};

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ScalarCurve2 = exports.Tw2ScalarKey2 = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ScalarKey2
 *
 * @property {number} value
 * @property {number} leftTangent
 * @property {number} rightTangent
 * @property {number} interpolation
 * @class
 */
var Tw2ScalarKey2 = exports.Tw2ScalarKey2 = function (_Tw2CurveKey) {
    _inherits(Tw2ScalarKey2, _Tw2CurveKey);

    function Tw2ScalarKey2() {
        _classCallCheck(this, Tw2ScalarKey2);

        var _this = _possibleConstructorReturn(this, (Tw2ScalarKey2.__proto__ || Object.getPrototypeOf(Tw2ScalarKey2)).call(this));

        _this.value = 0;
        _this.leftTangent = 0;
        _this.rightTangent = 0;
        _this.interpolation = 1;
        return _this;
    }

    return Tw2ScalarKey2;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2ScalarCurve2
 *
 * @property {boolean} cycle
 * @property {boolean} reversed
 * @property {number} timeOffset
 * @property {number} timeScale
 * @property {number} startValue
 * @property {number} currentValue
 * @property {number} endValue
 * @property {number} startTangent
 * @property {number} endTangent
 * @property {number} interpolation
 * @property {Array.<Tw2ScalarKey2>} keys
 * @property {number} length
 * @class
 */


var Tw2ScalarCurve2 = exports.Tw2ScalarCurve2 = function (_Tw2Curve) {
    _inherits(Tw2ScalarCurve2, _Tw2Curve);

    function Tw2ScalarCurve2() {
        _classCallCheck(this, Tw2ScalarCurve2);

        var _this2 = _possibleConstructorReturn(this, (Tw2ScalarCurve2.__proto__ || Object.getPrototypeOf(Tw2ScalarCurve2)).call(this));

        _this2.cycle = false;
        _this2.reversed = false;
        _this2.timeOffset = 0;
        _this2.timeScale = 1;
        _this2.startValue = 0;
        _this2.currentValue = 0;
        _this2.endValue = 0;
        _this2.startTangent = 0;
        _this2.endTangent = 0;
        _this2.interpolation = 1;
        _this2.keys = [];
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2ScalarCurve2, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort2(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.currentValue = this.GetValueAt(time);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @returns {number}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time) {
            time = time / this.timeScale + this.timeOffset;
            if (this.length <= 0 || time <= 0) {
                return this.startValue;
            }

            if (time > this.length) {
                if (this.cycle) {
                    time = time % this.length;
                } else if (this.reversed) {
                    return this.startValue;
                } else {
                    return this.endValue;
                }
            }

            if (this.reversed) {
                time = this.length - time;
            }

            if (this.keys.length === 0) {
                return this.Interpolate(time, null, null);
            }

            var startKey = this.keys[0],
                endKey = this.keys[this.keys.length - 1];

            if (time <= startKey.time) {
                return this.Interpolate(time, null, startKey);
            } else if (time >= endKey.time) {
                return this.Interpolate(time, endKey, null);
            }

            for (var i = 0; i + 1 < this.keys.length; ++i) {
                startKey = this.keys[i];
                endKey = this.keys[i + 1];
                if (startKey.time <= time && endKey.time > time) break;
            }

            return this.Interpolate(time, startKey, endKey);
        }

        /**
         * Interpolate
         * @param {number} time
         * @param {Tw2ScalarKey2} lastKey
         * @param {Tw2ScalarKey2} nextKey
         * @returns {number}
         */

    }, {
        key: 'Interpolate',
        value: function Interpolate(time, lastKey, nextKey) {
            var startValue = this.startValue,
                endValue = this.endValue,
                interp = this.interpolation,
                deltaTime = this.length;

            if (lastKey !== null) {
                interp = lastKey.interpolation;
                time -= lastKey.time;
            }

            switch (interp) {
                case Tw2ScalarCurve2.Interpolation.LINEAR:
                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        endValue = nextKey.value;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        deltaTime = this.length - lastKey.time;
                    }
                    return startValue + (endValue - startValue) * (time / deltaTime);

                case Tw2ScalarCurve2.Interpolation.HERMITE:
                    var inTangent = this.startTangent,
                        outTangent = this.endTangent;

                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        inTangent = lastKey.rightTangent;
                        endValue = nextKey.value;
                        outTangent = nextKey.leftTangent;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        outTangent = nextKey.leftTangent;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        inTangent = lastKey.rightTangent;
                        deltaTime = this.length - lastKey.time;
                    }

                    var s = time / deltaTime,
                        s2 = s * s,
                        s3 = s2 * s;

                    var c2 = -2.0 * s3 + 3.0 * s2,
                        c1 = 1.0 - c2,
                        c4 = s3 - s2,
                        c3 = s + c4 - s2;

                    return startValue * c1 + endValue * c2 + inTangent * c3 + outTangent * c4;

                default:
                    return this.startValue;
            }
        }
    }]);

    return Tw2ScalarCurve2;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2ScalarCurve2.inputDimension = 1;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2ScalarCurve2.outputDimension = 1;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2ScalarCurve2.valueProperty = 'currentValue';

/**
 * The curve's type
 * @type {number}
 */
Tw2ScalarCurve2.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE2;

/**
 * The curve's key constructor
 * @type {Tw2ScalarKey2}
 */
Tw2ScalarCurve2.Key = Tw2ScalarKey2;

/**
 * Interpolation types
 * @type {{CONSTANT: number, LINEAR: number, HERMITE: number}}
 */
Tw2ScalarCurve2.Interpolation = {
    CONSTANT: 0,
    LINEAR: 1,
    HERMITE: 2
};

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2SineCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2SineCurve
 *
 * @property {string} name
 * @property {number} value
 * @property {number} offset
 * @property {number} scale
 * @property {number} speed
 */
var Tw2SineCurve = exports.Tw2SineCurve = function (_Tw2Curve) {
  _inherits(Tw2SineCurve, _Tw2Curve);

  function Tw2SineCurve() {
    _classCallCheck(this, Tw2SineCurve);

    var _this = _possibleConstructorReturn(this, (Tw2SineCurve.__proto__ || Object.getPrototypeOf(Tw2SineCurve)).call(this));

    _this.value = 0;
    _this.offset = 0;
    _this.scale = 1;
    _this.speed = 1;
    return _this;
  }

  /**
   * Updates the current value at the given time
   * @param {number} time
   */


  _createClass(Tw2SineCurve, [{
    key: 'UpdateValue',
    value: function UpdateValue(time) {
      this.value = this.GetValueAt(time);
    }

    /**
     * Gets a value at a specific time
     * @param {number} time
     * @returns {number}
     */

  }, {
    key: 'GetValueAt',
    value: function GetValueAt(time) {
      return Math.sin(time * Math.PI * 2 * this.speed) * this.scale + this.offset;
    }
  }]);

  return Tw2SineCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * THe curve's dimension
 * @type {number}
 */


Tw2SineCurve.outputDimension = 1;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2SineCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2SineCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE_NO_KEYS;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Vector2Curve = exports.Tw2Vector2Key = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2Vector2Key
 *
 * @property {vec2} value
 * @property {vec2} leftTangent
 * @property {vec2} rightTangent
 * @property {number} interpolation
 * @class
 */
var Tw2Vector2Key = exports.Tw2Vector2Key = function (_Tw2CurveKey) {
    _inherits(Tw2Vector2Key, _Tw2CurveKey);

    function Tw2Vector2Key() {
        _classCallCheck(this, Tw2Vector2Key);

        var _this = _possibleConstructorReturn(this, (Tw2Vector2Key.__proto__ || Object.getPrototypeOf(Tw2Vector2Key)).call(this));

        _this.value = _math.vec2.create();
        _this.leftTangent = _math.vec2.create();
        _this.rightTangent = _math.vec2.create();
        _this.interpolation = 1;
        return _this;
    }

    return Tw2Vector2Key;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2Vector2Curve
 *
 * @property {boolean} cycle
 * @property {boolean} reversed
 * @property {number} timeOffset
 * @property {number} timeScale
 * @property {vec2} startValue - vec2 array
 * @property {vec2} currentValue - vec2 array
 * @property {vec2} endValue - vec2 array
 * @property {vec2} startTangent - vec2 array
 * @property {vec2} endTangent - vec2 array
 * @property {number} interpolation
 * @property {Array.<Tw2Vector2Key>} keys
 * @property {number} length
 * @class
 */


var Tw2Vector2Curve = exports.Tw2Vector2Curve = function (_Tw2Curve) {
    _inherits(Tw2Vector2Curve, _Tw2Curve);

    function Tw2Vector2Curve() {
        _classCallCheck(this, Tw2Vector2Curve);

        var _this2 = _possibleConstructorReturn(this, (Tw2Vector2Curve.__proto__ || Object.getPrototypeOf(Tw2Vector2Curve)).call(this));

        _this2.cycle = false;
        _this2.reversed = false;
        _this2.timeOffset = 0;
        _this2.timeScale = 1;
        _this2.startValue = _math.vec2.create();
        _this2.currentValue = _math.vec2.create();
        _this2.endValue = _math.vec2.create();
        _this2.startTangent = _math.vec2.create();
        _this2.endTangent = _math.vec2.create();
        _this2.interpolation = 1;
        _this2.keys = [];
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2Vector2Curve, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort2(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.currentValue);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {vec2} value - vec2 array
         * @returns {vec2} vec2 array
         * @prototype
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            time = time / this.timeScale + this.timeOffset;
            if (this.length <= 0 || time <= 0) {
                return _math.vec2.copy(value, this.startValue);
            }

            if (time > this.length) {
                if (this.cycle) {
                    time = time % this.length;
                } else if (this.reversed) {
                    return _math.vec2.copy(value, this.startValue);
                } else {
                    return _math.vec2.copy(value, this.endValue);
                }
            }

            if (this.reversed) {
                time = this.length - time;
            }

            if (this.keys.length === 0) {
                return this.Interpolate(time, null, null, value);
            }

            var startKey = this.keys[0],
                endKey = this.keys[this.keys.length - 1];

            if (time <= startKey.time) {
                return this.Interpolate(time, null, startKey, value);
            } else if (time >= endKey.time) {
                return this.Interpolate(time, endKey, null, value);
            }

            for (var i = 0; i + 1 < this.keys.length; ++i) {
                startKey = this.keys[i];
                endKey = this.keys[i + 1];
                if (startKey.time <= time && endKey.time > time) break;
            }

            return this.Interpolate(time, startKey, endKey, value);
        }

        /**
         * Interpolate
         * @param {number} time
         * @param {Tw2Vector2Key} lastKey
         * @param {Tw2Vector2Key} nextKey
         * @param {vec2} value - vec2 array
         * @returns {vec2} vec2 array
         */

    }, {
        key: 'Interpolate',
        value: function Interpolate(time, lastKey, nextKey, value) {
            _math.vec2.copy(value, this.startValue);

            var startValue = this.startValue,
                endValue = this.endValue,
                interp = this.interpolation,
                deltaTime = this.length;

            if (lastKey !== null) {
                interp = lastKey.interpolation;
                time -= lastKey.time;
            }

            switch (interp) {
                case Tw2Vector2Curve.Interpolation.LINEAR:
                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        endValue = nextKey.value;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        deltaTime = this.length - lastKey.time;
                    }
                    value[0] = startValue[0] + (endValue[0] - startValue[0]) * (time / deltaTime);
                    value[1] = startValue[1] + (endValue[1] - startValue[1]) * (time / deltaTime);
                    return value;

                case Tw2Vector2Curve.Interpolation.HERMITE:
                    var inTangent = this.startTangent,
                        outTangent = this.endTangent;

                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        inTangent = lastKey.rightTangent;
                        endValue = nextKey.value;
                        outTangent = nextKey.leftTangent;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        outTangent = nextKey.leftTangent;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        inTangent = lastKey.rightTangent;
                        deltaTime = this.length - lastKey.time;
                    }

                    var s = time / deltaTime,
                        s2 = s * s,
                        s3 = s2 * s;

                    var c2 = -2.0 * s3 + 3.0 * s2,
                        c1 = 1.0 - c2,
                        c4 = s3 - s2,
                        c3 = s + c4 - s2;

                    value[0] = startValue[0] * c1 + endValue[0] * c2 + inTangent[0] * c3 + outTangent[0] * c4;
                    value[1] = startValue[1] * c1 + endValue[1] * c2 + inTangent[1] * c3 + outTangent[1] * c4;
                    return value;

                default:
                    return value;
            }
        }
    }]);

    return Tw2Vector2Curve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2Vector2Curve.inputDimension = 2;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2Vector2Curve.outputDimension = 2;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2Vector2Curve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2Vector2Curve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE2;

/**
 * The curve's key constructor
 * @type {Tw2Vector2Key}
 */
Tw2Vector2Curve.Key = Tw2Vector2Key;

/**
 * Interpolation types
 * @type {{CONSTANT: number, LINEAR: number, HERMITE: number}}
 */
Tw2Vector2Curve.Interpolation = {
    CONSTANT: 0,
    LINEAR: 1,
    HERMITE: 2
};

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2Vector3Curve = exports.Tw2Vector3Key = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2Vector3Key
 *
 * @property {number} time
 * @property {vec3} value
 * @property {vec3} leftTangent
 * @property {vec3} rightTangent
 * @property {number} interpolation
 * @class
 */
var Tw2Vector3Key = exports.Tw2Vector3Key = function (_Tw2CurveKey) {
    _inherits(Tw2Vector3Key, _Tw2CurveKey);

    function Tw2Vector3Key() {
        _classCallCheck(this, Tw2Vector3Key);

        var _this = _possibleConstructorReturn(this, (Tw2Vector3Key.__proto__ || Object.getPrototypeOf(Tw2Vector3Key)).call(this));

        _this.value = _math.vec3.create();
        _this.leftTangent = _math.vec3.create();
        _this.rightTangent = _math.vec3.create();
        _this.interpolation = 1;
        return _this;
    }

    return Tw2Vector3Key;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2Vector3Curve
 *
 * @property {boolean} cycle
 * @property {boolean} reversed
 * @property {number} timeOffset
 * @property {number} timeScale
 * @property {vec3} startValue
 * @property {vec3} currentValue
 * @property {vec3} endValue
 * @property {vec3} startTangent
 * @property {vec3} endTangent
 * @property {number} interpolation
 * @property {Array.<Tw2Vector3Key>} keys
 * @property {number} length
 * @class
 */


var Tw2Vector3Curve = exports.Tw2Vector3Curve = function (_Tw2Curve) {
    _inherits(Tw2Vector3Curve, _Tw2Curve);

    function Tw2Vector3Curve() {
        _classCallCheck(this, Tw2Vector3Curve);

        var _this2 = _possibleConstructorReturn(this, (Tw2Vector3Curve.__proto__ || Object.getPrototypeOf(Tw2Vector3Curve)).call(this));

        _this2.cycle = false;
        _this2.reversed = false;
        _this2.timeOffset = 0;
        _this2.timeScale = 1;
        _this2.startValue = _math.vec3.create();
        _this2.currentValue = _math.vec3.create();
        _this2.endValue = _math.vec3.create();
        _this2.startTangent = _math.vec3.create();
        _this2.endTangent = _math.vec3.create();
        _this2.interpolation = 1;
        _this2.keys = [];
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2Vector3Curve, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort2(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.currentValue);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {vec3} value
         * @returns {vec3}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            time = time / this.timeScale + this.timeOffset;
            if (this.length <= 0 || time <= 0) {
                return _math.vec3.copy(value, this.startValue);
            }

            if (time > this.length) {
                if (this.cycle) {
                    time = time % this.length;
                } else if (this.reversed) {
                    return _math.vec3.copy(value, this.startValue);
                } else {
                    return _math.vec3.copy(value, this.endValue);
                }
            }

            if (this.reversed) {
                time = this.length - time;
            }

            if (this.keys.length === 0) {
                return this.Interpolate(time, null, null, value);
            }

            var startKey = this.keys[0],
                endKey = this.keys[this.keys.length - 1];

            if (time <= startKey.time) {
                return this.Interpolate(time, null, startKey, value);
            } else if (time >= endKey.time) {
                return this.Interpolate(time, endKey, null, value);
            }

            for (var i = 0; i + 1 < this.keys.length; ++i) {
                startKey = this.keys[i];
                endKey = this.keys[i + 1];
                if (startKey.time <= time && endKey.time > time) break;
            }

            return this.Interpolate(time, startKey, endKey, value);
        }

        /**
         * Interpolate
         * @param {number} time
         * @param {Tw2Vector3Key} lastKey
         * @param {Tw2Vector3Key} nextKey
         * @param {vec3} value
         * @returns {vec3}
         */

    }, {
        key: 'Interpolate',
        value: function Interpolate(time, lastKey, nextKey, value) {
            _math.vec3.copy(value, this.startValue);

            var startValue = this.startValue,
                endValue = this.endValue,
                interp = this.interpolation,
                deltaTime = this.length;

            if (lastKey !== null) {
                interp = lastKey.interpolation;
                time -= lastKey.time;
            }

            switch (interp) {
                case Tw2Vector3Curve.Interpolation.LINEAR:
                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        endValue = nextKey.value;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        deltaTime = this.length - lastKey.time;
                    }

                    value[0] = startValue[0] + (endValue[0] - startValue[0]) * (time / deltaTime);
                    value[1] = startValue[1] + (endValue[1] - startValue[1]) * (time / deltaTime);
                    value[2] = startValue[2] + (endValue[2] - startValue[2]) * (time / deltaTime);
                    return value;

                case Tw2Vector3Curve.Interpolation.HERMITE:
                    var inTangent = this.startTangent,
                        outTangent = this.endTangent;

                    if (lastKey && nextKey) {
                        startValue = lastKey.value;
                        inTangent = lastKey.rightTangent;
                        endValue = nextKey.value;
                        outTangent = nextKey.leftTangent;
                        deltaTime = nextKey.time - lastKey.time;
                    } else if (nextKey) {
                        endValue = nextKey.value;
                        outTangent = nextKey.leftTangent;
                        deltaTime = nextKey.time;
                    } else if (lastKey) {
                        startValue = lastKey.value;
                        inTangent = lastKey.rightTangent;
                        deltaTime = this.length - lastKey.time;
                    }

                    var s = time / deltaTime,
                        s2 = s * s,
                        s3 = s2 * s;

                    var c2 = -2.0 * s3 + 3.0 * s2,
                        c1 = 1.0 - c2,
                        c4 = s3 - s2,
                        c3 = s + c4 - s2;

                    value[0] = startValue[0] * c1 + endValue[0] * c2 + inTangent[0] * c3 + outTangent[0] * c4;
                    value[1] = startValue[1] * c1 + endValue[1] * c2 + inTangent[1] * c3 + outTangent[1] * c4;
                    value[2] = startValue[2] * c1 + endValue[2] * c2 + inTangent[2] * c3 + outTangent[2] * c4;
                    return value;

                default:
                    return value;
            }
        }
    }]);

    return Tw2Vector3Curve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2Vector3Curve.inputDimension = 3;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2Vector3Curve.outputDimension = 3;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2Vector3Curve.valueProperty = 'currentValue';

/**
 * The curve's type
 * @type {number}
 */
Tw2Vector3Curve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE2;

/**
 * The curve's key constructor
 * @type {Tw2Vector3Key}
 */
Tw2Vector3Curve.Key = Tw2Vector3Key;

/**
 * Interpolation types
 * @type {{CONSTANT: number, LINEAR: number, HERMITE: number}}
 */
Tw2Vector3Curve.Interpolation = {
    CONSTANT: 0,
    LINEAR: 1,
    HERMITE: 2
};

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2VectorCurve = exports.Tw2VectorKey = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2Curve2 = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2VectorKey
 *
 * @property {vec3} value
 * @property {vec3} left
 * @property {vec3} right
 * @property {number} interpolation
 * @inherits Tw2CurveKey
 * @class
 */
var Tw2VectorKey = exports.Tw2VectorKey = function (_Tw2CurveKey) {
    _inherits(Tw2VectorKey, _Tw2CurveKey);

    function Tw2VectorKey() {
        _classCallCheck(this, Tw2VectorKey);

        var _this = _possibleConstructorReturn(this, (Tw2VectorKey.__proto__ || Object.getPrototypeOf(Tw2VectorKey)).call(this));

        _this.value = _math.vec3.create();
        _this.left = _math.vec3.create();
        _this.right = _math.vec3.create();
        _this.interpolation = 0;
        return _this;
    }

    return Tw2VectorKey;
}(_Tw2Curve2.Tw2CurveKey);

/**
 * Tw2Vector3Curve
 *
 * @property {string} name
 * @property {number} start
 * @property {vec3} value
 * @property {number} extrapolation
 * @property {Array.<Tw2VectorKey>} keys
 * @property {number} _currentKey
 * @property {number} length
 * @class
 */


var Tw2VectorCurve = exports.Tw2VectorCurve = function (_Tw2Curve) {
    _inherits(Tw2VectorCurve, _Tw2Curve);

    function Tw2VectorCurve() {
        _classCallCheck(this, Tw2VectorCurve);

        var _this2 = _possibleConstructorReturn(this, (Tw2VectorCurve.__proto__ || Object.getPrototypeOf(Tw2VectorCurve)).call(this));

        _this2.start = 0;
        _this2.value = _math.vec3.create();
        _this2.extrapolation = 0;
        _this2.keys = [];
        _this2._currentKey = 1;
        _this2.length = 0;
        return _this2;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2VectorCurve, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2Curve2.Tw2Curve.Sort(this);
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates the current value at the given time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.value);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {vec3} value
         * @returns {vec3}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            if (this.length === 0) {
                return _math.vec3.copy(value, this.value);
            }

            var firstKey = this.keys[0],
                lastKey = this.keys[this.keys.length - 1];

            if (time >= lastKey.time) {
                switch (this.extrapolation) {
                    case Tw2VectorCurve.Extrapolation.NONE:
                        return _math.vec3.copy(value, this.value);

                    case Tw2VectorCurve.Extrapolation.CONSTANT:
                        return _math.vec3.copy(value, lastKey.value);

                    case Tw2VectorCurve.Extrapolation.GRADIENT:
                        return _math.vec3.scaleAndAdd(value, lastKey.value, lastKey.right, time - lastKey.time);

                    default:
                        time = time % lastKey.time;
                }
            } else if (time < 0 || time < firstKey.time) {
                switch (this.extrapolation) {
                    case Tw2VectorCurve.Extrapolation.NONE:
                        return _math.vec3.copy(value, this.value);

                    case Tw2VectorCurve.Extrapolation.GRADIENT:
                        return _math.vec3.scaleAndAdd(value, firstKey.value, firstKey.left, time * this.length - lastKey.time);

                    default:
                        return _math.vec3.copy(value, firstKey.value);
                }
            }

            var ck = this.keys[this._currentKey],
                ck_1 = this.keys[this._currentKey - 1];

            while (time >= ck.time || time < ck_1.time) {
                if (time < ck_1.time) this._currentKey = 0;
                this._currentKey++;
                ck = this.keys[this._currentKey];
                ck_1 = this.keys[this._currentKey - 1];
            }

            var nt = (time - ck_1.time) / (ck.time - ck_1.time);
            switch (ck_1.interpolation) {
                case Tw2VectorCurve.Interpolation.CONSTANT:
                    return _math.vec3.copy(value, ck_1.value);

                case Tw2VectorCurve.Interpolation.LINEAR:
                    value[0] = ck_1.value[0] * (1 - nt) + ck.value[0] * nt;
                    value[1] = ck_1.value[1] * (1 - nt) + ck.value[1] * nt;
                    value[2] = ck_1.value[2] * (1 - nt) + ck.value[2] * nt;
                    return value;

                case Tw2VectorCurve.Interpolation.HERMITE:
                    var k3 = 2 * nt * nt * nt - 3 * nt * nt + 1,
                        k2 = -2 * nt * nt * nt + 3 * nt * nt,
                        k1 = nt * nt * nt - 2 * nt * nt + nt,
                        k0 = nt * nt * nt - nt * nt;

                    value[0] = k3 * ck_1.value[0] + k2 * ck.value[0] + k1 * ck_1.right[0] + k0 * ck.left[0];
                    value[1] = k3 * ck_1.value[1] + k2 * ck.value[1] + k1 * ck_1.right[1] + k0 * ck.left[1];
                    value[2] = k3 * ck_1.value[2] + k2 * ck.value[2] + k1 * ck_1.right[2] + k0 * ck.left[2];
                    return value;

                default:
                    return value;
            }
        }
    }]);

    return Tw2VectorCurve;
}(_Tw2Curve2.Tw2Curve);

/**
 * The curve's key dimension
 * @type {number}
 */


Tw2VectorCurve.inputDimension = 3;

/**
 * The curve's dimension
 * @type {number}
 */
Tw2VectorCurve.outputDimension = 3;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2VectorCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2VectorCurve.curveType = _Tw2Curve2.Tw2Curve.Type.CURVE;

/**
 * The curve's key constructor
 * @type {Tw2VectorKey}
 */
Tw2VectorCurve.Key = Tw2VectorKey;

/**
 * Extrapolation types
 * @type {{NONE: number, CONSTANT: number, GRADIENT: number, CYCLE: number}}
 */
Tw2VectorCurve.Extrapolation = {
    NONE: 0,
    CONSTANT: 1,
    GRADIENT: 2,
    CYCLE: 3
};

/**
 * Interpolation types
 * @type {{NONE: number, CONSTANT: number, LINEAR: number, HERMITE: number}}
 */
Tw2VectorCurve.Interpolation = {
    NONE: 0,
    CONSTANT: 1,
    LINEAR: 2,
    HERMITE: 3
};

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2ColorSequencer = __webpack_require__(156);

Object.keys(_Tw2ColorSequencer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ColorSequencer[key];
    }
  });
});

var _Tw2EulerRotation = __webpack_require__(157);

Object.keys(_Tw2EulerRotation).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2EulerRotation[key];
    }
  });
});

var _Tw2QuaternionSequencer = __webpack_require__(158);

Object.keys(_Tw2QuaternionSequencer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2QuaternionSequencer[key];
    }
  });
});

var _Tw2RGBAScalarSequencer = __webpack_require__(159);

Object.keys(_Tw2RGBAScalarSequencer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2RGBAScalarSequencer[key];
    }
  });
});

var _Tw2ScalarSequencer = __webpack_require__(160);

Object.keys(_Tw2ScalarSequencer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2ScalarSequencer[key];
    }
  });
});

var _Tw2VectorSequencer = __webpack_require__(161);

Object.keys(_Tw2VectorSequencer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2VectorSequencer[key];
    }
  });
});

var _Tw2XYZScalarSequencer = __webpack_require__(162);

Object.keys(_Tw2XYZScalarSequencer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2XYZScalarSequencer[key];
    }
  });
});

var _Tw2YPRSequencer = __webpack_require__(163);

Object.keys(_Tw2YPRSequencer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2YPRSequencer[key];
    }
  });
});

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ColorSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2CurveSequencer2 = __webpack_require__(8);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ColorSequencer
 *
 * @property {number} start
 * @property {vec4} value
 * @property {number} operator
 * @property {Array<Tw2Curve>} functions
 * @class
 */
var Tw2ColorSequencer = exports.Tw2ColorSequencer = function (_Tw2CurveSequencer) {
    _inherits(Tw2ColorSequencer, _Tw2CurveSequencer);

    function Tw2ColorSequencer() {
        _classCallCheck(this, Tw2ColorSequencer);

        var _this = _possibleConstructorReturn(this, (Tw2ColorSequencer.__proto__ || Object.getPrototypeOf(Tw2ColorSequencer)).call(this));

        _this.start = 0;
        _this.value = _math.vec4.create();
        _this.operator = 0;
        _this.functions = [];
        return _this;
    }

    /**
     * Sorts the sequencer
     */


    _createClass(Tw2ColorSequencer, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2CurveSequencer2.Tw2CurveSequencer.Sort(this);
        }

        /**
         * Gets sequencer length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            var len = 0;
            for (var i = 0; i < this.functions.length; ++i) {
                if ('GetLength' in this.functions[i]) {
                    len = Math.max(len, this.functions[i].GetLength());
                }
            }
            return len;
        }

        /**
         * Updates a value at a specific time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.value);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {vec4} value
         * @returns {vec4}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            var vec4_0 = _Tw2CurveSequencer2.Tw2CurveSequencer.global.vec4_0;

            switch (this.operator) {
                case Tw2ColorSequencer.Operator.MULTIPLY:
                    _math.vec4.set(value, 1, 1, 1, 1);
                    for (var i = 0; i < this.functions.length; ++i) {
                        this.functions[i].GetValueAt(time, vec4_0);
                        _math.vec4.multiply(value, value, vec4_0);
                    }
                    return value;

                default:
                    _math.vec4.set(value, 0, 0, 0, 0);
                    for (var _i = 0; _i < this.functions.length; ++_i) {
                        this.functions[_i].GetValueAt(time, vec4_0);
                        _math.vec4.add(value, value, vec4_0);
                    }
                    return value;
            }
        }
    }]);

    return Tw2ColorSequencer;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2ColorSequencer.inputDimension = 4;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2ColorSequencer.outputDimension = 4;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2ColorSequencer.valueProperty = 'value';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2ColorSequencer.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER;

/**
 * The sequencer's curve array
 * @type {string}
 */
Tw2ColorSequencer.childArray = 'functions';

/**
 * Operators
 * @type {{MULTIPLY: number, ADD: number}}
 */
Tw2ColorSequencer.Operator = {
    MULTIPLY: 0,
    ADD: 1
};

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2EulerRotation = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2CurveSequencer2 = __webpack_require__(8);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2EulerRotation
 *
 * @property {string} name
 * @property {Tw2Curve} [yawCurve]
 * @property {Tw2Curve} [pitchCurve]
 * @property {Tw2Curve} [rollCurve]
 * @property {quat} currentValue=[0,0,0,1]
 * @class
 */
var Tw2EulerRotation = exports.Tw2EulerRotation = function (_Tw2CurveSequencer) {
  _inherits(Tw2EulerRotation, _Tw2CurveSequencer);

  function Tw2EulerRotation() {
    _classCallCheck(this, Tw2EulerRotation);

    var _this = _possibleConstructorReturn(this, (Tw2EulerRotation.__proto__ || Object.getPrototypeOf(Tw2EulerRotation)).call(this));

    _this.yawCurve = null;
    _this.pitchCurve = null;
    _this.rollCurve = null;
    _this.currentValue = _math.quat.create();
    return _this;
  }

  /**
   * Sorts the sequencer
   */


  _createClass(Tw2EulerRotation, [{
    key: 'Sort',
    value: function Sort() {
      _Tw2CurveSequencer2.Tw2CurveSequencer.Sort2(this);
    }

    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: 'GetLength',
    value: function GetLength() {
      var len = 0;
      if (this.yawCurve && 'GetLength' in this.yawCurve) len = this.yawCurve.GetLength();
      if (this.pitchCurve && 'GetLength' in this.pitchCurve) len = Math.max(len, this.pitchCurve.GetLength());
      if (this.rollCurve && 'GetLength' in this.rollCurve) len = Math.max(len, this.rollCurve.GetLength());
      return len;
    }

    /**
     * Updates the current value at a specific time
     * @param {number} time
     */

  }, {
    key: 'UpdateValue',
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.currentValue);
    }

    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {quat} value
     * @returns {quat}
     */

  }, {
    key: 'GetValueAt',
    value: function GetValueAt(time, value) {
      var yaw = this.yawCurve ? this.yawCurve.GetValueAt(time) : 0.0,
          pitch = this.pitchCurve ? this.pitchCurve.GetValueAt(time) : 0.0,
          roll = this.rollCurve ? this.rollCurve.GetValueAt(time) : 0.0;

      var sinYaw = Math.sin(yaw / 2.0),
          cosYaw = Math.cos(yaw / 2.0),
          sinPitch = Math.sin(pitch / 2.0),
          cosPitch = Math.cos(pitch / 2.0),
          sinRoll = Math.sin(roll / 2.0),
          cosRoll = Math.cos(roll / 2.0);

      value[0] = sinYaw * cosPitch * sinRoll + cosYaw * sinPitch * cosRoll;
      value[1] = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
      value[2] = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
      value[3] = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;

      return value;
    }
  }]);

  return Tw2EulerRotation;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2EulerRotation.inputDimension = 1;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2EulerRotation.outputDimension = 3;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2EulerRotation.valueProperty = 'currentValue';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2EulerRotation.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER2;

/**
 * The sequencer's curve property names
 * @type {string[]}
 */
Tw2EulerRotation.childProperties = ['yawCurve', 'pitchCurve', 'rollCurve'];

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2QuaternionSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2CurveSequencer2 = __webpack_require__(8);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2QuaternionSequencer
 *
 * @property {string} name
 * @property {number} start
 * @property {quat} value
 * @property {Array<Tw2Curve>} functions
 * @class
 */
var Tw2QuaternionSequencer = exports.Tw2QuaternionSequencer = function (_Tw2CurveSequencer) {
  _inherits(Tw2QuaternionSequencer, _Tw2CurveSequencer);

  function Tw2QuaternionSequencer() {
    _classCallCheck(this, Tw2QuaternionSequencer);

    var _this = _possibleConstructorReturn(this, (Tw2QuaternionSequencer.__proto__ || Object.getPrototypeOf(Tw2QuaternionSequencer)).call(this));

    _this.start = 0;
    _this.value = _math.quat.create();
    _this.functions = [];
    return _this;
  }

  /**
   * Sorts the sequencer
   */


  _createClass(Tw2QuaternionSequencer, [{
    key: 'Sort',
    value: function Sort() {
      _Tw2CurveSequencer2.Tw2CurveSequencer.Sort(this);
    }

    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: 'GetLength',
    value: function GetLength() {
      var len = 0;
      for (var i = 0; i < this.functions.length; ++i) {
        if ('GetLength' in this.functions[i]) {
          len = Math.max(len, this.functions[i].GetLength());
        }
      }
      return len;
    }

    /**
     * Updates a value at a specific time
     * @param {number} time
     */

  }, {
    key: 'UpdateValue',
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }

    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {quat} value
     * @returns {quat}
     */

  }, {
    key: 'GetValueAt',
    value: function GetValueAt(time, value) {
      _math.quat.identity(value);
      var quat_0 = _Tw2CurveSequencer2.Tw2CurveSequencer.global.quat_0;
      for (var i = 0; i < this.functions.length; ++i) {
        this.functions[i].GetValueAt(time, quat_0);
        _math.quat.multiply(value, value, quat_0);
      }
      return value;
    }
  }]);

  return Tw2QuaternionSequencer;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2QuaternionSequencer.inputDimension = 4;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2QuaternionSequencer.outputDimension = 4;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2QuaternionSequencer.valueProperty = 'value';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2QuaternionSequencer.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER;

/**
 * The sequencer's curve array
 * @type {string}
 */
Tw2QuaternionSequencer.childArray = 'functions';

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2RGBAScalarSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2CurveSequencer2 = __webpack_require__(8);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2RGBAScalarSequencer
 *
 * @property {vec4} value
 * @property {Tw2Curve} RedCurve
 * @property {Tw2Curve} GreenCurve
 * @property {Tw2Curve} BlueCurve
 * @property {Tw2Curve} AlphaCurve
 * @class
 */
var Tw2RGBAScalarSequencer = exports.Tw2RGBAScalarSequencer = function (_Tw2CurveSequencer) {
  _inherits(Tw2RGBAScalarSequencer, _Tw2CurveSequencer);

  function Tw2RGBAScalarSequencer() {
    _classCallCheck(this, Tw2RGBAScalarSequencer);

    var _this = _possibleConstructorReturn(this, (Tw2RGBAScalarSequencer.__proto__ || Object.getPrototypeOf(Tw2RGBAScalarSequencer)).call(this));

    _this.value = _math.vec4.create();
    _this.RedCurve = null;
    _this.GreenCurve = null;
    _this.BlueCurve = null;
    _this.AlphaCurve = null;
    return _this;
  }

  /**
   * Sorts the sequencer
   */


  _createClass(Tw2RGBAScalarSequencer, [{
    key: 'Sort',
    value: function Sort() {
      _Tw2CurveSequencer2.Tw2CurveSequencer.Sort2(this);
    }

    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: 'GetLength',
    value: function GetLength() {
      var len = 0;
      if (this.RedCurve && 'GetLength' in this.RedCurve) len = this.RedCurve.GetLength();
      if (this.GreenCurve && 'GetLength' in this.GreenCurve) len = Math.max(len, this.GreenCurve.GetLength());
      if (this.BlueCurve && 'GetLength' in this.BlueCurve) len = Math.max(len, this.BlueCurve.GetLength());
      if (this.AlphaCurve && 'GetLength' in this.AlphaCurve) len = Math.max(len, this.AlphaCurve.GetLength());
      return len;
    }

    /**
     * Updates the current value at a specific time
     * @param {number} time
     */

  }, {
    key: 'UpdateValue',
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }

    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {vec4} value
     * @returns {vec4}
     */

  }, {
    key: 'GetValueAt',
    value: function GetValueAt(time, value) {
      value[0] = this.RedCurve ? this.RedCurve.GetValueAt(time) : 0;
      value[1] = this.GreenCurve ? this.GreenCurve.GetValueAt(time) : 0;
      value[2] = this.BlueCurve ? this.BlueCurve.GetValueAt(time) : 0;
      value[3] = this.AlphaCurve ? this.AlphaCurve.GetValueAt(time) : 0;
      return value;
    }
  }]);

  return Tw2RGBAScalarSequencer;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2RGBAScalarSequencer.inputDimension = 1;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2RGBAScalarSequencer.outputDimension = 4;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2RGBAScalarSequencer.valueProperty = 'value';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2RGBAScalarSequencer.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER2;

/**
 * The sequencer's curve property names
 * @type {string[]}
 */
Tw2RGBAScalarSequencer.childProperties = ['RedCurve', 'GreenCurve', 'BlueCurve', 'AlphaCurve'];

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2ScalarSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tw2CurveSequencer2 = __webpack_require__(8);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2ScalarSequencer
 *
 * @property {string} name
 * @property {number} value
 * @property {number} operator
 * @property {Array<Tw2Curve>} functions
 * @property {number} inMinClamp
 * @property {number} inMaxClamp
 * @property {number} outMinClamp
 * @property {number} outMaxClamp
 * @property {boolean} clamping
 * @class
 */
var Tw2ScalarSequencer = exports.Tw2ScalarSequencer = function (_Tw2CurveSequencer) {
    _inherits(Tw2ScalarSequencer, _Tw2CurveSequencer);

    function Tw2ScalarSequencer() {
        _classCallCheck(this, Tw2ScalarSequencer);

        var _this = _possibleConstructorReturn(this, (Tw2ScalarSequencer.__proto__ || Object.getPrototypeOf(Tw2ScalarSequencer)).call(this));

        _this.value = 0;
        _this.operator = 0;
        _this.functions = [];
        _this.inMinClamp = 0;
        _this.inMaxClamp = 1;
        _this.outMinClamp = 0;
        _this.outMaxClamp = 1;
        _this.clamping = false;
        return _this;
    }

    /**
     * Sorts the sequencer
     */


    _createClass(Tw2ScalarSequencer, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2CurveSequencer2.Tw2CurveSequencer.Sort(this);
        }

        /**
         * Gets sequencer length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            var len = 0;
            for (var i = 0; i < this.functions.length; ++i) {
                if ('GetLength' in this.functions[i]) {
                    len = Math.max(len, this.functions[i].GetLength());
                }
            }
            return len;
        }

        /**
         * Updates a value at a specific time
         *
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.value = this.GetValueAt(time);
        }

        /**
         * Gets a value at a specific time
         *
         * @param {number} time
         * @returns {number}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time) {
            var value = void 0;

            switch (this.operator) {
                case Tw2ScalarSequencer.Operator.MULTIPLY:
                    value = 1;
                    for (var i = 0; i < this.functions.length; ++i) {
                        var v = this.functions[i].GetValueAt(time);
                        if (this.clamping) {
                            v = Math.min(Math.max(v, this.inMinClamp), this.inMaxClamp);
                        }
                        value *= v;
                    }
                    break;

                default:
                    value = 0;
                    for (var _i = 0; _i < this.functions.length; ++_i) {
                        var _v = this.functions[_i].GetValueAt(time);
                        if (this.clamping) {
                            _v = Math.min(Math.max(_v, this.inMinClamp), this.inMaxClamp);
                        }
                        value += _v;
                    }
            }

            if (this.clamping) {
                value = Math.min(Math.max(value, this.outMinClamp), this.outMaxClamp);
            }

            return value;
        }
    }]);

    return Tw2ScalarSequencer;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2ScalarSequencer.inputDimension = 1;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2ScalarSequencer.outputDimension = 1;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2ScalarSequencer.valueProperty = 'value';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2ScalarSequencer.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER;

/**
 * The sequencer's curve properties
 * @type {string}
 */
Tw2ScalarSequencer.childArray = 'functions';

/**
 * Operator types
 * @type {{MULTIPLY: number, ADD: number}}
 */
Tw2ScalarSequencer.Operator = {
    MULTIPLY: 0,
    ADD: 1
};

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2VectorSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2CurveSequencer2 = __webpack_require__(8);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2VectorSequencer
 *
 * @property {string} name
 * @property {number} start
 * @property {vec3} value
 * @property {number} operator
 * @property {Array.<Tw2Curve>} functions
 * @class
 */
var Tw2VectorSequencer = exports.Tw2VectorSequencer = function (_Tw2CurveSequencer) {
    _inherits(Tw2VectorSequencer, _Tw2CurveSequencer);

    function Tw2VectorSequencer() {
        _classCallCheck(this, Tw2VectorSequencer);

        var _this = _possibleConstructorReturn(this, (Tw2VectorSequencer.__proto__ || Object.getPrototypeOf(Tw2VectorSequencer)).call(this));

        _this.start = 0;
        _this.value = _math.vec3.create();
        _this.operator = 0;
        _this.functions = [];
        return _this;
    }

    /**
     * Sorts the sequencer
     */


    _createClass(Tw2VectorSequencer, [{
        key: 'Sort',
        value: function Sort() {
            _Tw2CurveSequencer2.Tw2CurveSequencer.Sort(this);
        }

        /**
         * Gets sequencer length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            var len = 0;
            for (var i = 0; i < this.functions.length; ++i) {
                if ('GetLength' in this.functions[i]) {
                    len = Math.max(len, this.functions[i].GetLength());
                }
            }
            return len;
        }

        /**
         * Updates the current value at a specific time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            this.GetValueAt(time, this.value);
        }

        /**
         * Gets a value at a specific time
         * @param {number} time
         * @param {vec3} value
         * @returns {vec3}
         */

    }, {
        key: 'GetValueAt',
        value: function GetValueAt(time, value) {
            var vec3_0 = _Tw2CurveSequencer2.Tw2CurveSequencer.global.vec3_0;

            switch (this.operator) {
                case Tw2VectorSequencer.Operator.MULTIPLY:
                    _math.vec3.set(value, 1, 1, 1);
                    for (var i = 0; i < this.functions.length; ++i) {
                        this.functions[i].GetValueAt(time, vec3_0);
                        _math.vec3.multiply(value, value, vec3_0);
                    }
                    return value;

                default:
                    _math.vec3.set(value, 0, 0, 0);
                    for (var _i = 0; _i < this.functions.length; ++_i) {
                        this.functions[_i].GetValueAt(time, vec3_0);
                        _math.vec3.add(value, value, vec3_0);
                    }
                    return value;
            }
        }
    }]);

    return Tw2VectorSequencer;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2VectorSequencer.inputDimension = 3;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2VectorSequencer.outputDimension = 3;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2VectorSequencer.valueProperty = 'value';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2VectorSequencer.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER;

/**
 * The sequencer's curve properties
 * @type {string}
 */
Tw2VectorSequencer.childArray = 'functions';

/**
 * Operator types
 * @type {{MULTIPLY: number, ADD: number}}
 */
Tw2VectorSequencer.Operator = {
    MULTIPLY: 0,
    ADD: 1
};

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2XYZScalarSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2CurveSequencer2 = __webpack_require__(8);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2XYZScalarSequencer
 *
 * @property {string} name
 * @property {vec3} value
 * @property {Tw2CurveSequencer} XCurve
 * @property {Tw2CurveSequencer} YCurve
 * @property {Tw2CurveSequencer} ZCurve
 * @class
 */
var Tw2XYZScalarSequencer = exports.Tw2XYZScalarSequencer = function (_Tw2CurveSequencer) {
  _inherits(Tw2XYZScalarSequencer, _Tw2CurveSequencer);

  function Tw2XYZScalarSequencer() {
    _classCallCheck(this, Tw2XYZScalarSequencer);

    var _this = _possibleConstructorReturn(this, (Tw2XYZScalarSequencer.__proto__ || Object.getPrototypeOf(Tw2XYZScalarSequencer)).call(this));

    _this.value = _math.vec3.create();
    _this.XCurve = null;
    _this.YCurve = null;
    _this.ZCurve = null;
    return _this;
  }

  /**
   * Sorts the sequencer
   */


  _createClass(Tw2XYZScalarSequencer, [{
    key: 'Sort',
    value: function Sort() {
      _Tw2CurveSequencer2.Tw2CurveSequencer.Sort2(this);
    }

    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: 'GetLength',
    value: function GetLength() {
      var len = 0;
      if (this.XCurve && 'GetLength' in this.XCurve) len = this.XCurve.GetLength();
      if (this.YCurve && 'GetLength' in this.YCurve) len = Math.max(len, this.YCurve.GetLength());
      if (this.ZCurve && 'GetLength' in this.ZCurve) len = Math.max(len, this.ZCurve.GetLength());
      return len;
    }

    /**
     * Updates a value at a specific time
     * @param {number} time
     */

  }, {
    key: 'UpdateValue',
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }

    /**
     * Gets a value at a specific time
     * @param {number} time
     * @param {vec3} value
     * @returns {vec3}
     */

  }, {
    key: 'GetValueAt',
    value: function GetValueAt(time, value) {
      value[0] = this.XCurve ? this.XCurve.GetValueAt(time) : 0;
      value[1] = this.YCurve ? this.YCurve.GetValueAt(time) : 0;
      value[2] = this.ZCurve ? this.ZCurve.GetValueAt(time) : 0;
      return value;
    }
  }]);

  return Tw2XYZScalarSequencer;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2XYZScalarSequencer.inputDimension = 1;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2XYZScalarSequencer.outputDimension = 3;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2XYZScalarSequencer.valueProperty = 'value';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2XYZScalarSequencer.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER2;

/**
 * The sequencer's curve property names
 * @type {string[]}
 */
Tw2XYZScalarSequencer.childProperties = ['XCurve', 'YCurve', 'ZCurve'];

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2YPRSequencer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _Tw2CurveSequencer2 = __webpack_require__(8);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2YPRSequencer
 *
 * @property {quat} value
 * @property {vec3} YawPitchRoll
 * @property {Tw2Curve} YawCurve
 * @property {Tw2Curve} PitchCurve
 * @property {Tw2Curve} RollCurve
 * @class
 */
var Tw2YPRSequencer = exports.Tw2YPRSequencer = function (_Tw2CurveSequencer) {
  _inherits(Tw2YPRSequencer, _Tw2CurveSequencer);

  function Tw2YPRSequencer() {
    _classCallCheck(this, Tw2YPRSequencer);

    var _this = _possibleConstructorReturn(this, (Tw2YPRSequencer.__proto__ || Object.getPrototypeOf(Tw2YPRSequencer)).call(this));

    _this.value = _math.quat.create();
    _this.YawPitchRoll = _math.vec3.create();
    _this.YawCurve = null;
    _this.PitchCurve = null;
    _this.RollCurve = null;
    return _this;
  }

  /**
   * Sorts the sequencer
   */


  _createClass(Tw2YPRSequencer, [{
    key: 'Sort',
    value: function Sort() {
      _Tw2CurveSequencer2.Tw2CurveSequencer.Sort2(this);
    }

    /**
     * Gets sequencer length
     * @returns {number}
     */

  }, {
    key: 'GetLength',
    value: function GetLength() {
      var len = 0;
      if (this.YawCurve && 'GetLength' in this.YawCurve) len = this.YawCurve.GetLength();
      if (this.PitchCurve && 'GetLength' in this.PitchCurve) len = Math.max(len, this.PitchCurve.GetLength());
      if (this.RollCurve && 'GetLength' in this.RollCurve) len = Math.max(len, this.RollCurve.GetLength());
      return len;
    }

    /**
     * Updates a value at a specific time
     *
     * @param {number} time
     */

  }, {
    key: 'UpdateValue',
    value: function UpdateValue(time) {
      this.GetValueAt(time, this.value);
    }

    /**
     * Gets a value at a specific time
     *
     * @param {number} time
     * @param {quat} value
     * @returns {quat}
     */

  }, {
    key: 'GetValueAt',
    value: function GetValueAt(time, value) {
      if (this.YawCurve) this.YawPitchRoll[0] = this.YawCurve.GetValueAt(time);
      if (this.PitchCurve) this.YawPitchRoll[1] = this.PitchCurve.GetValueAt(time);
      if (this.RollCurve) this.YawPitchRoll[2] = this.RollCurve.GetValueAt(time);

      var sinYaw = Math.sin(this.YawPitchRoll[0] / 180 * Math.PI / 2.0),
          cosYaw = Math.cos(this.YawPitchRoll[0] / 180 * Math.PI / 2.0),
          sinPitch = Math.sin(this.YawPitchRoll[1] / 180 * Math.PI / 2.0),
          cosPitch = Math.cos(this.YawPitchRoll[1] / 180 * Math.PI / 2.0),
          sinRoll = Math.sin(this.YawPitchRoll[2] / 180 * Math.PI / 2.0),
          cosRoll = Math.cos(this.YawPitchRoll[2] / 180 * Math.PI / 2.0);

      value[0] = sinYaw * cosPitch * sinRoll + cosYaw * sinPitch * cosRoll;
      value[1] = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
      value[2] = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
      value[3] = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;

      return value;
    }
  }]);

  return Tw2YPRSequencer;
}(_Tw2CurveSequencer2.Tw2CurveSequencer);

/**
 * The sequencer's curve dimension
 * @type {number}
 */


Tw2YPRSequencer.inputDimension = 1;

/**
 * The sequencer's dimension
 * @type {number}
 */
Tw2YPRSequencer.outputDimension = 4;

/**
 * The sequencer's current value property
 * @type {string}
 */
Tw2YPRSequencer.valueProperty = 'value';

/**
 * The sequencer's type
 * @type {number}
 */
Tw2YPRSequencer.curveType = _Tw2CurveSequencer2.Tw2CurveSequencer.Type.SEQUENCER2;

/**
 * The sequencer's curve property names
 * @type {string[]}
 */
Tw2YPRSequencer.childProperties = ['YawCurve', 'PitchCurve', 'RollCurve'];

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2WbgTrack = __webpack_require__(165);

Object.keys(_Tw2WbgTrack).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2WbgTrack[key];
    }
  });
});

var _Tw2TransformTrack = __webpack_require__(166);

Object.keys(_Tw2TransformTrack).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2TransformTrack[key];
    }
  });
});

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2WbgTrack = Tw2WbgTrack;
exports.Tw2WbgTransformTrack = Tw2WbgTransformTrack;

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

/**
 * Tw2WbgTrack
 *
 * @property {string|number} _id
 * @property {string} name
 * @property {string} geometryResPath
 * @property {Object} geometryRes
 * @property {string} group
 * @property {number} duration
 * @property {boolean} cycle
 */
function Tw2WbgTrack() {
    this._id = _math.util.generateID();
    this.name = '';
    this.geometryResPath = '';
    this.geometryRes = null;
    this.group = '';
    this.duration = 0;
    this.cycle = false;

    /**
     * SetCurves
     * @param self
     * @private
     */
    function SetCurves(self) {
        if (!self.name || !self.group || !self.geometryRes) {
            return;
        }

        for (var i = 0; i < self.geometryRes.animations.length; ++i) {
            var animation = self.geometryRes.animations[i];
            for (var j = 0; j < animation.trackGroups.length; ++j) {
                if (animation.trackGroups[j].name === self.group) {
                    self._ApplyTracks(animation.trackGroups[j], animation.duration);
                }
            }
        }
    }

    /**
     * Initialize
     * @method
     */
    this.Initialize = function () {
        if (this.geometryResPath) {
            this.geometryRes = _core.resMan.GetResource(this.geometryResPath);
            var self = this;
            var notification = {
                OnResPrepared: function OnResPrepared() {
                    SetCurves(self);
                }
            };
            this.geometryRes.RegisterNotification(notification);
        }
    };

    /**
     * Updates a value at a specific time
     * @param {number} time
     * @prototype
     */
    this.UpdateValue = function (time) {
        if (!this._TracksReady()) return;
        if (this.cycle) time = time % this.duration;
        if (time <= this.duration && time >= 0) this._UpdateValue(time);
    };
}

/**
 * Tw2WbgTransformTrack
 *
 * @property {string|number} _id
 * @property {vec3} translation
 * @property {quat} rotation
 * @property {vec3} scale
 * @variable {*} positionCurve
 * @variable {*} rotationCurve
 * @variable {*} scaleCurve
 * @variable {mat4} scaleShear
 */
function Tw2WbgTransformTrack() {
    this._id = _math.util.generateID();
    this.translation = _math.vec3.create();
    this.rotation = _math.quat.create();
    this.rotation[3] = 1;
    this.scale = _math.vec3.create();
    var positionCurve = null;
    var rotationCurve = null;
    var scaleCurve = null;
    var scaleShear = _math.mat4.create();

    /**
     * _TracksReady
     * @returns {*}
     * @private
     */
    this._TracksReady = function () {
        return positionCurve || rotationCurve || scaleCurve;
    };

    /**
     * _ApplyTracks
     * @param trackGroup
     * @param duration
     * @private
     */
    this._ApplyTracks = function (trackGroup, duration) {
        for (var i = 0; i < trackGroup.transformTracks.length; ++i) {
            var track = trackGroup.transformTracks[i];
            if (track.name === this.name) {
                this.duration = duration;
                positionCurve = track.position;
                rotationCurve = track.orientation;
                scaleCurve = track.scaleShear;
            }
        }
        this.UpdateValue(0);
    };

    /**
     * Updates a value at a specific time
     * @param {number} time
     * @prototype
     */
    this._UpdateValue = function (time) {
        if (positionCurve) {
            _math.curve.evaluate(positionCurve, time, this.translation, this.cycle, this.duration);
        }

        if (rotationCurve) {
            _math.curve.evaluate(rotationCurve, time, this.rotation, this.cycle, this.duration);
            _math.quat.normalize(this.rotation, this.rotation);
        }

        if (scaleCurve) {
            _math.curve.evaluate(scaleCurve, time, scaleShear, this.cycle, this.duration);
        }

        this.scale[0] = scaleShear[0];
        this.scale[1] = scaleShear[5];
        this.scale[2] = scaleShear[10];
    };
}

/**
 * @type {Tw2WbgTrack}
 * @prototype
 */
Tw2WbgTransformTrack.prototype = new Tw2WbgTrack();

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2TransformTrack = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2TransformTrack
 *
 * @property {string|number} _id
 * @property {string} name
 * @property {string} resPath
 * @property {Object} res
 * @property {string} group
 * @property {boolean} cycle
 * @property {number} duration
 * @property {vec3} translation
 * @property {quat} rotation
 * @property {vec3} scale
 * @property positionCurve
 * @property orientationCurve
 * @property scaleCurve
 * @property {mat4} _scaleShear
 * @class
 */
var Tw2TransformTrack = exports.Tw2TransformTrack = function () {
    function Tw2TransformTrack() {
        _classCallCheck(this, Tw2TransformTrack);

        this._id = _math.util.generateID();
        this.name = '';
        this.resPath = '';
        this.res = null;
        this.group = '';
        this.cycle = false;
        this.duration = 0;
        this.translation = _math.vec3.create();
        this.rotation = _math.quat.create();
        this.scale = _math.vec3.fromValues(0, 0, 0);
        this.scaleShear = _math.mat4.create();
        this.positionCurve = null;
        this.orientationCurve = null;
        this.scaleCurve = null;
    }

    /**
     * Initializes the Curve
     */


    _createClass(Tw2TransformTrack, [{
        key: 'Initialize',
        value: function Initialize() {
            if (this.resPath !== '') {
                this.res = _core.resMan.GetResource(this.resPath);
            }
        }

        /**
         * Gets curve length
         *
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.duration;
        }

        /**
         * Updates a value at a specific time
         *
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            if (!this.res || !this.res.IsGood()) return;
            if (!this.positionCurve) this.FindTracks();
            if (!this.positionCurve) return;
            if (this.cycle) time = time % this.duration;
            if (time > this.duration || time < 0) return;

            _math.curve.evaluate(this.positionCurve, time, this.translation, this.cycle, this.duration);
            _math.curve.evaluate(this.orientationCurve, time, this.rotation, this.cycle, this.duration);
            _math.quat.normalize(this.rotation, this.rotation);
            _math.curve.evaluate(this.scaleCurve, time, this.scaleShear, this.cycle, this.duration);
            _math.mat4.getScaling(this.scale, this.scaleCurve);
        }

        /**
         * FindTracks
         */

    }, {
        key: 'FindTracks',
        value: function FindTracks() {
            var group = null;
            for (var i = 0; i < this.res.animations.length; ++i) {
                for (var j = 0; j < this.res.animations[i].trackGroups.length; ++j) {
                    if (this.res.animations[i].trackGroups[j].name === this.group) {
                        this.duration = this.res.animations[i].duration;
                        group = this.res.animations[i].trackGroups[j];
                        break;
                    }
                }
            }

            if (!group) return;

            for (var _i = 0; _i < group.transformTracks.length; ++_i) {
                if (this.name === group.transformTracks[_i].name) {
                    this.positionCurve = group.transformTracks[_i].position;
                    this.orientationCurve = group.transformTracks[_i].orientation;
                    this.scaleCurve = group.transformTracks[_i].scaleShear;
                    break;
                }
            }
        }
    }]);

    return Tw2TransformTrack;
}();

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Tw2MayaEulerRotationCurve = __webpack_require__(168);

Object.keys(_Tw2MayaEulerRotationCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2MayaEulerRotationCurve[key];
    }
  });
});

var _Tw2MayaScalarCurve = __webpack_require__(169);

Object.keys(_Tw2MayaScalarCurve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2MayaScalarCurve[key];
    }
  });
});

var _Tw2MayaVector3Curve = __webpack_require__(170);

Object.keys(_Tw2MayaVector3Curve).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2MayaVector3Curve[key];
    }
  });
});

var _Tw2MayaAnimationEngine = __webpack_require__(171);

Object.keys(_Tw2MayaAnimationEngine).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Tw2MayaAnimationEngine[key];
    }
  });
});

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2MayaEulerRotationCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _curves = __webpack_require__(19);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2MayaEulerRotationCurve
 *
 * @property {number} xIndex
 * @property {number} yIndex
 * @property {number} zIndex
 * @property {?Tw2MayaAnimationEngine} animationEngine
 * @property {string} name
 * @property {vec3} eulerValue
 * @property {boolean} updateQuaternion
 * @property {quat} quatValue
 * @property {number} length
 * @class
 */
var Tw2MayaEulerRotationCurve = exports.Tw2MayaEulerRotationCurve = function (_Tw2Curve) {
    _inherits(Tw2MayaEulerRotationCurve, _Tw2Curve);

    function Tw2MayaEulerRotationCurve() {
        _classCallCheck(this, Tw2MayaEulerRotationCurve);

        var _this = _possibleConstructorReturn(this, (Tw2MayaEulerRotationCurve.__proto__ || Object.getPrototypeOf(Tw2MayaEulerRotationCurve)).call(this));

        _this.xIndex = -1;
        _this.yIndex = -1;
        _this.zIndex = -1;
        _this.animationEngine = null;
        _this.eulerValue = _math.vec3.create();
        _this.updateQuaternion = false;
        _this.quatValue = _math.quat.create();
        _this.length = 0;
        return _this;
    }

    /**
     * Sorts the curve
     */


    _createClass(Tw2MayaEulerRotationCurve, [{
        key: 'Sort',
        value: function Sort() {
            this.ComputeLength();
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates a value at a specific time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            if (this.animationEngine) {
                if (this.xIndex) {
                    this.eulerValue[0] = this.animationEngine.Evaluate(this.xIndex, time);
                }

                if (this.yIndex) {
                    if (this.yIndex === this.xIndex) {
                        this.eulerValue[1] = this.eulerValue[0];
                    } else {
                        this.eulerValue[1] = this.animationEngine.Evaluate(this.yIndex, time);
                    }
                }

                if (this.zIndex) {
                    if (this.zIndex === this.xIndex) {
                        this.eulerValue[2] = this.eulerValue[0];
                    } else {
                        this.eulerValue[2] = this.animationEngine.Evaluate(this.zIndex, time);
                    }
                }

                if (this.updateQuaternion) {
                    var sinYaw = Math.sin(this.eulerValue[0] / 2),
                        cosYaw = Math.cos(this.eulerValue[0] / 2),
                        sinPitch = Math.sin(this.eulerValue[1] / 2),
                        cosPitch = Math.cos(this.eulerValue[1] / 2),
                        sinRoll = Math.sin(this.eulerValue[2] / 2),
                        cosRoll = Math.cos(this.eulerValue[2] / 2);

                    this.quatValue[0] = sinYaw * cosPitch * sinRoll + cosYaw * sinPitch * cosRoll;
                    this.quatValue[1] = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
                    this.quatValue[2] = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
                    this.quatValue[3] = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;
                }
            }
        }

        /**
         * Computes curve Length
         */

    }, {
        key: 'ComputeLength',
        value: function ComputeLength() {
            if (!this.animationEngine || this.animationEngine.GetNumberOfCurves() === 0) return;

            this.length = 0;
            if (this.xIndex >= 0) {
                this.length = this.animationEngine.GetLength(this.xIndex);
            }

            if (this.yIndex >= 0) {
                this.length = Math.max(this.length, this.animationEngine.GetLength(this.yIndex));
            }

            if (this.zIndex >= 0) {
                this.length = Math.max(this.length, this.animationEngine.GetLength(this.zIndex));
            }
        }
    }]);

    return Tw2MayaEulerRotationCurve;
}(_curves.Tw2Curve);

/**
 * The curve's dimension
 * @type {number}
 */


Tw2MayaEulerRotationCurve.outputDimension = 3;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2MayaEulerRotationCurve.valueProperty = 'eulerValue';

/**
 * The curve's type
 * @type {number}
 */
Tw2MayaEulerRotationCurve.curveType = _curves.Tw2Curve.Type.CURVE_MAYA;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tw2MayaScalarCurve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _curves = __webpack_require__(19);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2MayaScalarCurve
 *
 * @property {number} index
 * @property {null|Tw2MayaAnimationEngine} animationEngine
 * @property {number} value
 * @property {number} length
 * @class
 */
var Tw2MayaScalarCurve = exports.Tw2MayaScalarCurve = function (_Tw2Curve) {
  _inherits(Tw2MayaScalarCurve, _Tw2Curve);

  function Tw2MayaScalarCurve() {
    _classCallCheck(this, Tw2MayaScalarCurve);

    var _this = _possibleConstructorReturn(this, (Tw2MayaScalarCurve.__proto__ || Object.getPrototypeOf(Tw2MayaScalarCurve)).call(this));

    _this.index = -1;
    _this.animationEngine = null;
    _this.value = 0;
    _this.length = 0;
    return _this;
  }

  /**
   * Sorts the curve
   */


  _createClass(Tw2MayaScalarCurve, [{
    key: 'Sort',
    value: function Sort() {
      this.ComputeLength();
    }

    /**
     * Gets the curve's length
     * @returns {number}
     */

  }, {
    key: 'GetLength',
    value: function GetLength() {
      return this.length;
    }

    /**
     * Updates a value at a specific time
     * @param {number} time
     */

  }, {
    key: 'UpdateValue',
    value: function UpdateValue(time) {
      if (this.animationEngine) {
        this.value = this.animationEngine.Evaluate(this.index, time);
      }
    }

    /**
     * Computes curve Length
     */

  }, {
    key: 'ComputeLength',
    value: function ComputeLength() {
      if (!this.animationEngine || this.animationEngine.GetNumberOfCurves() === 0) return;
      if (this.index >= 0) this.length = this.animationEngine.GetLength(this.index);
    }
  }]);

  return Tw2MayaScalarCurve;
}(_curves.Tw2Curve);

/**
 * The curve's dimension
 * @type {number}
 */


Tw2MayaScalarCurve.outputDimension = 1;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2MayaScalarCurve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2MayaScalarCurve.curveType = _curves.Tw2Curve.Type.CURVE_MAYA;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2MayaVector3Curve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _curves = __webpack_require__(19);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Tw2MayaVector3Curve
 *
 * @property {number} xIndex
 * @property {number} yIndex
 * @property {number} zIndex
 * @property {null|Tw2MayaAnimationEngine} animationEngine
 * @property {string} name
 * @property {vec3} value
 * @property {number} length
 */
var Tw2MayaVector3Curve = exports.Tw2MayaVector3Curve = function (_Tw2Curve) {
    _inherits(Tw2MayaVector3Curve, _Tw2Curve);

    function Tw2MayaVector3Curve() {
        _classCallCheck(this, Tw2MayaVector3Curve);

        var _this = _possibleConstructorReturn(this, (Tw2MayaVector3Curve.__proto__ || Object.getPrototypeOf(Tw2MayaVector3Curve)).call(this));

        _this.xIndex = -1;
        _this.yIndex = -1;
        _this.zIndex = -1;
        _this.animationEngine = null;
        _this.value = _math.vec3.create();
        _this.length = 0;
        return _this;
    }

    /**
     * Sorts the curve's keys
     */


    _createClass(Tw2MayaVector3Curve, [{
        key: 'Sort',
        value: function Sort() {
            this.ComputeLength();
        }

        /**
         * Gets the curve's length
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength() {
            return this.length;
        }

        /**
         * Updates a value at a specific time
         * @param {number} time
         */

    }, {
        key: 'UpdateValue',
        value: function UpdateValue(time) {
            if (this.animationEngine) {
                if (this.xIndex) {
                    this.value[0] = this.animationEngine.Evaluate(this.xIndex, time);
                }

                if (this.yIndex) {
                    if (this.yIndex === this.xIndex) {
                        this.value[1] = this.value[0];
                    } else {
                        this.value[1] = this.animationEngine.Evaluate(this.yIndex, time);
                    }
                }

                if (this.zIndex) {
                    if (this.zIndex === this.xIndex) {
                        this.value[2] = this.value[0];
                    } else {
                        this.value[2] = this.animationEngine.Evaluate(this.zIndex, time);
                    }
                }
            }
        }

        /**
         * Computes curve Length
         */

    }, {
        key: 'ComputeLength',
        value: function ComputeLength() {
            if (!this.animationEngine || this.animationEngine.GetNumberOfCurves() === 0) return;

            this.length = 0;
            if (this.xIndex >= 0) {
                this.length = this.animationEngine.GetLength(this.xIndex);
            }

            if (this.yIndex >= 0) {
                this.length = Math.max(this.length, this.animationEngine.GetLength(this.yIndex));
            }

            if (this.zIndex >= 0) {
                this.length = Math.max(this.length, this.animationEngine.GetLength(this.zIndex));
            }
        }
    }]);

    return Tw2MayaVector3Curve;
}(_curves.Tw2Curve);

/**
 * The curve's dimension
 * @type {number}
 */


Tw2MayaVector3Curve.outputDimension = 3;

/**
 * The curve's current value property
 * @type {string}
 */
Tw2MayaVector3Curve.valueProperty = 'value';

/**
 * The curve's type
 * @type {number}
 */
Tw2MayaVector3Curve.curveType = _curves.Tw2Curve.Type.CURVE_MAYA;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tw2MayaAnimationEngine = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tw2MayaAnimationEngine
 * TODO: Complete the prototype `_EvaluteBezier`
 *
 * @property {number|string} id
 * @property {Array} curves
 * @property {Array} hermiteSegments
 * @property {Array} bezierSegments
 * @property {number} _currentCurveIndex
 * @property _evalCache
 */
var Tw2MayaAnimationEngine = exports.Tw2MayaAnimationEngine = function () {
    function Tw2MayaAnimationEngine() {
        _classCallCheck(this, Tw2MayaAnimationEngine);

        this._id = _math.util.generateID();
        this.curves = [];
        this.hermiteSegments = [];
        this.bezierSegments = [];
        this._currentCurveIndex = 0;
        this._evalCache = null;
    }

    /**
     * Evaluate
     * @param curveIndex
     * @param time
     * @returns {*}
     */


    _createClass(Tw2MayaAnimationEngine, [{
        key: 'Evaluate',
        value: function Evaluate(curveIndex, time) {
            if (this.curves.length <= curveIndex) return 0;

            this._currentCurveIndex = curveIndex;
            if (!this._evalCache) {
                this._evalCache = new Array(this.curves.length);
                for (var i = 0; i < this._evalCache.length; ++i) {
                    this._evalCache[i] = -1;
                }
            }

            var animCurve = this.curves[curveIndex];
            var firstSegment = animCurve[Tw2MayaAnimationEngine.AnimCurveFields.SEGMENT_OFFSET];
            var segments = null;

            if (animCurve[Tw2MayaAnimationEngine.AnimCurveFields.IS_WEIGHTED]) {
                segments = this.bezierSegments;
            } else {
                segments = this.hermiteSegments;
            }

            if (time < segments[firstSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
                if (animCurve[Tw2MayaAnimationEngine.AnimCurveFields.PRE_INFINITY] === Tw2MayaAnimationEngine.INFINITY) {
                    return segments[firstSegment][Tw2MayaAnimationEngine.AnimSegment.VALUE];
                }
                return this._EvaluateInfinities(animCurve, segments, firstSegment, time, true);
            }

            if (time > animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_TIME]) {
                if (animCurve[Tw2MayaAnimationEngine.AnimCurveFields.POST_INFINITY] === Tw2MayaAnimationEngine.INFINITY) {
                    return animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_VALUE];
                }
                return this._EvaluateInfinities(animCurve, segments, firstSegment, time, false);
            }

            return this._EvaluateImpl(animCurve, segments, firstSegment, time);
        }

        /**
         * _EvaluateImpl
         * @param animCurve
         * @param segments
         * @param firstSegment
         * @param time
         * @returns {*}
         */

    }, {
        key: '_EvaluateImpl',
        value: function _EvaluateImpl(animCurve, segments, firstSegment, time) {
            var withinInterval = false,
                nextSegment = null,
                lastSegment = null,
                index = void 0;

            if (this._evalCache[this._currentCurveIndex] >= 0) {
                lastSegment = firstSegment + this._evalCache[this._currentCurveIndex];
                if (this._evalCache[this._currentCurveIndex] < animCurve[Tw2MayaAnimationEngine.AnimCurveFields.NUM_SEGMENTS - 1] && time > segments[lastSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
                    nextSegment = firstSegment + this._evalCache[this._currentCurveIndex] + 1;
                    if (time === segments[nextSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
                        this._evalCache[this._currentCurveIndex]++;
                        return segments[nextSegment][Tw2MayaAnimationEngine.AnimSegment.VALUE];
                    } else if (time < segments[nextSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
                        index = this._evalCache[this._currentCurveIndex] + 1;
                        withinInterval = true;
                    } else {
                        nextSegment = null;
                    }
                } else if (this._evalCache[this._currentCurveIndex] > 0 && time < segments[lastSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
                    var prevSegment = firstSegment + this._evalCache[this._currentCurveIndex] - 1;
                    if (time > segments[prevSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
                        index = this._evalCache[this._currentCurveIndex];
                        withinInterval = true;
                    } else if (time === segments[prevSegment][Tw2MayaAnimationEngine.AnimSegment.TIME]) {
                        this._evalCache[this._currentCurveIndex]--;
                        return segments[prevSegment][Tw2MayaAnimationEngine.AnimSegment.VALUE];
                    }
                }
            }

            if (!withinInterval) {
                var result = this._Find(animCurve, time, segments, firstSegment);
                index = result[1];
                if (result[0] || index === 0) {
                    if (index === animCurve[Tw2MayaAnimationEngine.AnimCurveFields.NUM_SEGMENTS]) {
                        index--;
                        this._evalCache[this._currentCurveIndex] = index;
                        return animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_VALUE];
                    } else {
                        this._evalCache[this._currentCurveIndex] = index;
                        return segments[firstSegment + index][Tw2MayaAnimationEngine.AnimSegment.VALUE];
                    }
                } else if (index === animCurve[Tw2MayaAnimationEngine.AnimCurveFields.NUM_SEGMENTS] + 1) {
                    this._evalCache[this._currentCurveIndex] = 0;
                    return animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_VALUE];
                }
            }

            if (this._evalCache[this._currentCurveIndex] !== index - 1) {
                this._evalCache[this._currentCurveIndex] = index - 1;
                lastSegment = firstSegment + this._evalCache[this._currentCurveIndex];
                if (nextSegment === null) nextSegment = firstSegment + index;
            }

            if (animCurve[Tw2MayaAnimationEngine.AnimCurveFields.IS_WEIGHTED]) {
                var bSegment = segments[lastSegment];
                if (bSegment[Tw2MayaAnimationEngine.BezierSegment.IS_STEP]) {
                    return bSegment[Tw2MayaAnimationEngine.BezierSegment.VALUE];
                } else if (bSegment[Tw2MayaAnimationEngine.BezierSegment.IS_STEP_NEXT]) {
                    if (nextSegment === null) {
                        return animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_VALUE];
                    }
                    return segments[nextSegment][Tw2MayaAnimationEngine.BezierSegment.VALUE];
                } else {
                    var nextKeyTime = animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_TIME];
                    if (this._evalCache[this._currentCurveIndex] + 1 < animCurve[Tw2MayaAnimationEngine.AnimCurveFields.NUM_SEGMENTS]) {
                        nextKeyTime = segments[nextSegment][Tw2MayaAnimationEngine.BezierSegment.TIME];
                    }
                    return this._EvaluateBezier(bSegment, time, nextKeyTime);
                }
            } else {
                var hSegment = segments[lastSegment];
                if (hSegment[Tw2MayaAnimationEngine.HermiteSegment.IS_STEP]) {
                    return hSegment[Tw2MayaAnimationEngine.HermiteSegment.VALUE];
                } else if (hSegment[Tw2MayaAnimationEngine.HermiteSegment.IS_STEP_NEXT]) {
                    if (nextSegment === null) {
                        return animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_VALUE];
                    }
                    return segments[nextSegment][Tw2MayaAnimationEngine.HermiteSegment.VALUE];
                } else {
                    return this._EvaluateHermite(hSegment, time);
                }
            }
        }

        /* eslint-disable no-unused-vars */

        /**
         * A static helper function to evaluate the infinity portion of an animation curve.
         * The infinity portion is the parts of the animation curve outside the range of keys.
         * @param curve - The animation curve to evaluate
         * @param segments
         * @param startSegment
         * @param {time} time
         * @param {boolean} bool - false: evaluate the post-infinity portion, true: evaluate the pre-infinity portion
         */

    }, {
        key: '_EvaluateInfinities',
        value: function _EvaluateInfinities(curve, segments, startSegment, time, bool) {

            throw new Error('_EvaluateInfinities not implemented');
        }

        /* eslint-enable no-unused-vars */

        /**
         * _EvaluateHermite
         * @param segment
         * @param time
         * @returns {*}
         */

    }, {
        key: '_EvaluateHermite',
        value: function _EvaluateHermite(segment, time) {
            var t = time - segment[Tw2MayaAnimationEngine.HermiteSegment.TIME];
            var coeff = segment[Tw2MayaAnimationEngine.HermiteSegment.COEFF];
            return t * (t * (t * coeff[0] + coeff[1]) + coeff[2]) + coeff[3];
        }

        /**
         * _EvaluateBezier
         * @param segment
         * @param time
         * @param nextSegmentTime
         * @returns {*}
         */

    }, {
        key: '_EvaluateBezier',
        value: function _EvaluateBezier(segment, time, nextSegmentTime) {
            var t = void 0,
                s = void 0;

            s = (time - segment[Tw2MayaAnimationEngine.BezierSegment.TIME]) / (nextSegmentTime - segment[Tw2MayaAnimationEngine.BezierSegment.TIME]);

            if (segment[Tw2MayaAnimationEngine.BezierSegment.IS_LINEAR]) {
                t = s;
            } else {
                var _poly = _math.vec4.create();
                _poly[3] = segment[Tw2MayaAnimationEngine.BezierSegment.COEFF][3];
                _poly[2] = segment[Tw2MayaAnimationEngine.BezierSegment.COEFF][2];
                _poly[1] = segment[Tw2MayaAnimationEngine.BezierSegment.COEFF][1];
                _poly[0] = segment[Tw2MayaAnimationEngine.BezierSegment.COEFF][0] - s;
                var roots = [];
                if (_math.curve.polyZeroes(_poly, 3, 0.0, 1, 1.0, 1, roots) === 1) t = roots[0];else t = 0.0;
            }

            var poly = segment[Tw2MayaAnimationEngine.BezierSegment.POLYY];
            return t * (t * (t * poly[3] + poly[2]) + poly[1]) + poly[0];
        }

        /**
         * _Find
         * @param animCurve
         * @param time
         * @param segments
         * @param firstSegment
         * @returns {*}
         */

    }, {
        key: '_Find',
        value: function _Find(animCurve, time, segments, firstSegment) {
            var len = void 0,
                mid = void 0,
                low = void 0,
                high = void 0;

            /* use a binary search to find the key */
            var index = 0;
            len = animCurve[Tw2MayaAnimationEngine.AnimCurveFields.NUM_SEGMENTS] + 1;
            var segment = null;
            var stime = 0.0;

            if (len > 0) {
                low = 0;
                high = len - 1;
                do {
                    mid = low + high >> 1;
                    if (mid < len - 1) {
                        segment = firstSegment + mid;
                        stime = segments[segment][Tw2MayaAnimationEngine.AnimSegment.TIME];
                    } else {
                        stime = animCurve[Tw2MayaAnimationEngine.AnimCurveFields.END_TIME];
                    }

                    if (time < stime) {
                        high = mid - 1;
                    } else if (time > stime) {
                        low = mid + 1;
                    } else {
                        index = mid;
                        return [true, index];
                    }
                } while (low <= high);
                index = low;
            }
            return [false, index];
        }

        /**
         * Returns the total number of curves
         * @returns {number}
         */

    }, {
        key: 'GetNumberOfCurves',
        value: function GetNumberOfCurves() {
            return this.curves.length;
        }

        /**
         * Gets specific curve's length
         * @property {number} index
         * @returns {number}
         */

    }, {
        key: 'GetLength',
        value: function GetLength(index) {
            if (index < 0 || index >= this.curves.length) return 0;
            var curve = this.curves[index];
            var firstSegment = void 0;

            if (curve[Tw2MayaAnimationEngine.AnimCurveFields.IS_WEIGHTED]) {
                firstSegment = this.bezierSegments[curve[Tw2MayaAnimationEngine.AnimCurveFields.SEGMENT_OFFSET]];
            } else {
                firstSegment = this.hermiteSegments[curve[Tw2MayaAnimationEngine.AnimCurveFields.SEGMENT_OFFSET]];
            }

            return curve[Tw2MayaAnimationEngine.AnimCurveFields.END_TIME] - firstSegment[Tw2MayaAnimationEngine.AnimSegment.TIME];
        }
    }]);

    return Tw2MayaAnimationEngine;
}();

Tw2MayaAnimationEngine.AnimCurveFields = {
    NUM_SEGMENTS: 0,
    SEGMENT_OFFSET: 1,
    END_TIME: 2,
    END_VALUE: 3,
    IN_TANGENT: 4,
    OUT_TANGENT: 5,
    PRE_INFINITY: 6,
    POST_INFINITY: 7,
    IS_WEIGHTED: 8
};

Tw2MayaAnimationEngine.AnimSegment = {
    TIME: 0,
    VALUE: 1
};

Tw2MayaAnimationEngine.HermiteSegment = {
    TIME: 0,
    VALUE: 1,
    COEFF: 2,
    IS_STEP: 3,
    IS_STEP_NEXT: 4
};

Tw2MayaAnimationEngine.BezierSegment = {
    TIME: 0,
    VALUE: 1,
    COEFF: 2,
    POLYY: 3,
    IS_STEP: 4,
    IS_STEP_NEXT: 5,
    IS_LINEAR: 6
};

Tw2MayaAnimationEngine.INFINITY = 0;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _child = __webpack_require__(58);

Object.keys(_child).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _child[key];
    }
  });
});

var _effect = __webpack_require__(178);

Object.keys(_effect).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _effect[key];
    }
  });
});

var _object = __webpack_require__(60);

Object.keys(_object).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _object[key];
    }
  });
});

var _item = __webpack_require__(63);

Object.keys(_item).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _item[key];
    }
  });
});

var _EveSpaceScene = __webpack_require__(195);

Object.keys(_EveSpaceScene).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveSpaceScene[key];
    }
  });
});

var _EveSOF = __webpack_require__(196);

Object.keys(_EveSOF).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveSOF[key];
    }
  });
});

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveChildBillboard = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveChild2 = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Mesh attachment to space object and oriented towards the camera
 *
 * @property {Tw2Mesh|Tw2InstancedMesh} mesh
 * @property {Tw2BasicPerObjectData} _perObjectData
 * @class
 */
var EveChildBillboard = exports.EveChildBillboard = function (_EveChild) {
    _inherits(EveChildBillboard, _EveChild);

    function EveChildBillboard() {
        _classCallCheck(this, EveChildBillboard);

        var _this = _possibleConstructorReturn(this, (EveChildBillboard.__proto__ || Object.getPrototypeOf(EveChildBillboard)).call(this));

        _this.mesh = null;
        _this._perObjectData = new _core.Tw2BasicPerObjectData();
        _this._perObjectData.perObjectFFEData = new _core.Tw2RawData();
        _this._perObjectData.perObjectFFEData.Declare('world', 16);
        _this._perObjectData.perObjectFFEData.Declare('worldInverseTranspose', 16);
        _this._perObjectData.perObjectFFEData.Create();
        return _this;
    }

    /**
     * Gets the child's resources
     * @param {Array} [out=[]]
     * @returns {Array.<Tw2Resource>} out
     */


    _createClass(EveChildBillboard, [{
        key: 'GetResources',
        value: function GetResources(out) {
            if (this.mesh) this.mesh.GetResources(out);
            return out;
        }

        /**
         * Per frame update
         * @param {number} dt
         * @param {mat4} parentTransform
         */

    }, {
        key: 'Update',
        value: function Update(dt, parentTransform) {
            _get(EveChildBillboard.prototype.__proto__ || Object.getPrototypeOf(EveChildBillboard.prototype), 'Update', this).call(this, dt, parentTransform);

            var viewInverse = _EveChild2.EveChild.global.mat4_0,
                finalScale = _EveChild2.EveChild.global.vec3_0;

            _math.mat4.lookAt(viewInverse, _core.device.eyePosition, this.worldTransform.subarray(12), [0, 1, 0]);
            _math.mat4.transpose(viewInverse, viewInverse);
            _math.mat4.getScaling(finalScale, parentTransform);
            _math.vec3.multiply(finalScale, finalScale, this.scaling);

            this.worldTransform[0] = viewInverse[0] * finalScale[0];
            this.worldTransform[1] = viewInverse[1] * finalScale[0];
            this.worldTransform[2] = viewInverse[2] * finalScale[0];
            this.worldTransform[4] = viewInverse[4] * finalScale[1];
            this.worldTransform[5] = viewInverse[5] * finalScale[1];
            this.worldTransform[6] = viewInverse[6] * finalScale[1];
            this.worldTransform[8] = viewInverse[8] * finalScale[2];
            this.worldTransform[9] = viewInverse[9] * finalScale[2];
            this.worldTransform[10] = viewInverse[10] * finalScale[2];
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (this.display && this.mesh) {
                _math.mat4.transpose(this._perObjectData.perObjectFFEData.Get('world'), this.worldTransform);
                _math.mat4.invert(this._perObjectData.perObjectFFEData.Get('worldInverseTranspose'), this.worldTransform);
                this.mesh.GetBatches(mode, accumulator, this._perObjectData);
            }
        }
    }]);

    return EveChildBillboard;
}(_EveChild2.EveChild);

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveChildContainer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _EveChild2 = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Container for other child effects
 *
 * @parameter {Array.<{}>} objects
 * @parameter {Array.<Tw2CurveSet>} curveSets
 * @class
 */
var EveChildContainer = exports.EveChildContainer = function (_EveChild) {
    _inherits(EveChildContainer, _EveChild);

    function EveChildContainer() {
        _classCallCheck(this, EveChildContainer);

        var _this = _possibleConstructorReturn(this, (EveChildContainer.__proto__ || Object.getPrototypeOf(EveChildContainer)).call(this));

        _this.objects = [];
        _this.curveSets = [];
        return _this;
    }

    /**
     * Gets the child's resources
     * @param {Array} [out=[]]
     * @returns {Array<Tw2Resource>} out
     */


    _createClass(EveChildContainer, [{
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            for (var i = 0; i < this.objects.length; i++) {
                if ('GetResources' in this.objects[i]) {
                    this.objects[i].GetResources(out);
                }
            }
            return out;
        }

        /**
         * Per frame update
         * @param {number} dt
         * @param {mat4} parentTransform
         */

    }, {
        key: 'Update',
        value: function Update(dt, parentTransform) {
            _get(EveChildContainer.prototype.__proto__ || Object.getPrototypeOf(EveChildContainer.prototype), 'Update', this).call(this, dt, parentTransform);

            for (var i = 0; i < this.curveSets.length; i++) {
                this.curveSets[i].Update(dt);
            }

            for (var _i = 0; _i < this.objects.length; _i++) {
                this.objects[_i].Update(dt, this.worldTransform);
            }
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (this.display) {
                for (var i = 0; i < this.objects.length; i++) {
                    this.objects[i].GetBatches(mode, accumulator, perObjectData);
                }
            }
        }
    }]);

    return EveChildContainer;
}(_EveChild2.EveChild);

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveChildExplosion = undefined;

var _EveChild2 = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * 'Complex' explosion object. Not implemented.
 *
 * @class
 */
var EveChildExplosion = exports.EveChildExplosion = function (_EveChild) {
    _inherits(EveChildExplosion, _EveChild);

    function EveChildExplosion() {
        _classCallCheck(this, EveChildExplosion);

        return _possibleConstructorReturn(this, (EveChildExplosion.__proto__ || Object.getPrototypeOf(EveChildExplosion)).call(this));
    }

    return EveChildExplosion;
}(_EveChild2.EveChild);

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveChildMesh = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveChild2 = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Mesh attachment to space object
 *
 * @property {Tw2Mesh|Tw2InstancedMesh} mesh
 * @property {boolean} useSpaceObjectData
 * @class
 */
var EveChildMesh = exports.EveChildMesh = function (_EveChild) {
    _inherits(EveChildMesh, _EveChild);

    function EveChildMesh() {
        _classCallCheck(this, EveChildMesh);

        var _this = _possibleConstructorReturn(this, (EveChildMesh.__proto__ || Object.getPrototypeOf(EveChildMesh)).call(this));

        _this.mesh = null;
        _this.useSpaceObjectData = true;
        return _this;
    }

    /**
     * Gets the child's resources
     * @param {Array} [out=[]]
     * @returns {Array.<Tw2Resource>} out
     */


    _createClass(EveChildMesh, [{
        key: 'GetResources',
        value: function GetResources(out) {
            if (this.mesh) this.mesh.GetResources(out);
            return out;
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (!this.display || !this.mesh) return;

            if (this.useSpaceObjectData) {
                if (!this._perObjectData) {
                    this._perObjectData = new _core.Tw2PerObjectData();
                    this._perObjectData.perObjectVSData = new _core.Tw2RawData();
                    this._perObjectData.perObjectVSData.data = new Float32Array(perObjectData.perObjectVSData.data.length);

                    this._perObjectData.perObjectVSData.data[33] = 1;
                    this._perObjectData.perObjectVSData.data[35] = 1;

                    this._perObjectData.perObjectPSData = new _core.Tw2RawData();
                    this._perObjectData.perObjectPSData.data = new Float32Array(perObjectData.perObjectPSData.data.length);

                    this._perObjectData.perObjectPSData.data[1] = 1;
                    this._perObjectData.perObjectPSData.data[3] = 1;
                }
                this._perObjectData.perObjectVSData.data.set(perObjectData.perObjectVSData.data);
                this._perObjectData.perObjectPSData.data.set(perObjectData.perObjectPSData.data);

                _math.mat4.transpose(this._perObjectData.perObjectVSData.data, this.worldTransform);
                _math.mat4.transpose(this._perObjectData.perObjectVSData.data.subarray(16), this.worldTransformLast);
            } else {
                if (!this._perObjectData) {
                    this._perObjectData = new _core.Tw2BasicPerObjectData();
                    this._perObjectData.perObjectFFEData = new _core.Tw2RawData();
                    this._perObjectData.perObjectFFEData.Declare('world', 16);
                    this._perObjectData.perObjectFFEData.Declare('worldInverseTranspose', 16);
                    this._perObjectData.perObjectFFEData.Create();
                }
                _math.mat4.transpose(this._perObjectData.perObjectFFEData.Get('world'), this.worldTransform);
                _math.mat4.invert(this._perObjectData.perObjectFFEData.Get('worldInverseTranspose'), this.worldTransform);
            }

            this.mesh.GetBatches(mode, accumulator, this._perObjectData);
        }
    }]);

    return EveChildMesh;
}(_EveChild2.EveChild);

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveChildParticleSystem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveChild2 = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Particle system attachment to space object
 *
 * @property {Tw2Mesh} mesh
 * @property {Array<Tw2ParticleEmitter>} particleEmitters
 * @property {Array<Tw2ParticleSystem>} particleSystems
 * @property {Tw2BasicPerObjectData} _perObjectData
 * @class
 */
var EveChildParticleSystem = exports.EveChildParticleSystem = function (_EveChild) {
    _inherits(EveChildParticleSystem, _EveChild);

    function EveChildParticleSystem() {
        _classCallCheck(this, EveChildParticleSystem);

        var _this = _possibleConstructorReturn(this, (EveChildParticleSystem.__proto__ || Object.getPrototypeOf(EveChildParticleSystem)).call(this));

        _this.mesh = null;
        _this.particleEmitters = [];
        _this.particleSystems = [];
        _this._perObjectData = new _core.Tw2BasicPerObjectData();
        _this._perObjectData.perObjectFFEData = new _core.Tw2RawData();
        _this._perObjectData.perObjectFFEData.Declare('world', 16);
        _this._perObjectData.perObjectFFEData.Declare('worldInverseTranspose', 16);
        _this._perObjectData.perObjectFFEData.Create();
        return _this;
    }

    /**
     * Gets the child's resources
     * @param {Array} [out=[]]
     * @returns {Array.<Tw2Resource>} out
     */


    _createClass(EveChildParticleSystem, [{
        key: 'GetResources',
        value: function GetResources(out) {
            if (this.mesh) this.mesh.GetResources(out);
            return out;
        }

        /**
         * Per frame update
         * @param {number} dt
         * @param {mat4} parentTransform
         */

    }, {
        key: 'Update',
        value: function Update(dt, parentTransform) {
            _get(EveChildParticleSystem.prototype.__proto__ || Object.getPrototypeOf(EveChildParticleSystem.prototype), 'Update', this).call(this, dt, parentTransform);

            for (var i = 0; i < this.particleEmitters.length; ++i) {
                this.particleEmitters[i].Update(dt);
            }

            for (var _i = 0; _i < this.particleSystems.length; ++_i) {
                this.particleSystems[_i].Update(dt);
            }
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (this.display && this.mesh) {
                _math.mat4.transpose(this._perObjectData.perObjectFFEData.Get('world'), this.worldTransform);
                _math.mat4.invert(this._perObjectData.perObjectFFEData.Get('worldInverseTranspose'), this.worldTransform);
                this.mesh.GetBatches(mode, accumulator, this._perObjectData);
            }
        }
    }]);

    return EveChildParticleSystem;
}(_EveChild2.EveChild);

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _EveLensflare = __webpack_require__(179);

Object.keys(_EveLensflare).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveLensflare[key];
    }
  });
});

var _EveMeshOverlayEffect = __webpack_require__(180);

Object.keys(_EveMeshOverlayEffect).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveMeshOverlayEffect[key];
    }
  });
});

var _EveOccluder = __webpack_require__(59);

Object.keys(_EveOccluder).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveOccluder[key];
    }
  });
});

var _EveStretch = __webpack_require__(181);

Object.keys(_EveStretch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveStretch[key];
    }
  });
});

var _EveTurretFiringFX = __webpack_require__(182);

Object.keys(_EveTurretFiringFX).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _EveTurretFiringFX[key];
    }
  });
});

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveLensflare = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveOccluder = __webpack_require__(59);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EveLensFlare
 *
 * @property {number|string} _id
 * @property {String} name=
 * @property {boolean} display
 * @property {boolean} update
 * @property {boolean} doOcclusionQueries
 * @property {number} cameraFactor
 * @property {vec3} position
 * @property {Array} flares
 * @property {Array.<EveOccluder>} occluders
 * @property {Array.<EveOccluder>} backgroundOccluders
 * @property {number} occlusionIntensity
 * @property {number} backgroundOcclusionIntensity
 * @property {Array} distanceToEdgeCurves
 * @property {Array} distanceToCenterCurves
 * @property {Array} radialAngleCurves
 * @property {Array} xDistanceToCenter
 * @property {Array} yDistanceToCenter
 * @property {Array} bindings
 * @property {Array.<Tw2CurveSet>} curveSets
 * @property {?Tw2Mesh} mesh
 * @property {vec3} _direction
 * @property {mat4} _transform
 * @property {*} _backBuffer
 * @class
 */
var EveLensflare = exports.EveLensflare = function () {
    function EveLensflare() {
        _classCallCheck(this, EveLensflare);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.update = true;
        this.doOcclusionQueries = true;
        this.cameraFactor = 20;
        this.position = _math.vec3.create();
        this.flares = [];
        this.occluders = [];
        this.backgroundOccluders = [];
        this.occlusionIntensity = 1;
        this.backgroundOcclusionIntensity = 1;
        this.distanceToEdgeCurves = [];
        this.distanceToCenterCurves = [];
        this.radialAngleCurves = [];
        this.xDistanceToCenter = [];
        this.yDistanceToCenter = [];
        this.bindings = [];
        this.curveSets = [];
        this.mesh = null;
        this._direction = _math.vec3.create();
        this._transform = _math.mat4.create();
        this._backBuffer = null;

        EveLensflare.init();
    }

    /**
     * Gets lensflares's res objects
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2Resource>} [out]
     */


    _createClass(EveLensflare, [{
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.mesh) this.mesh.GetResources(out);

            for (var i = 0; i < this.flares.length; i++) {
                this.flares[i].GetResources(out);
            }

            if (_EveOccluder.EveOccluder.global && _EveOccluder.EveOccluder.global.effect && !out.includes(_EveOccluder.EveOccluder.global.effect)) {
                out.push(_EveOccluder.EveOccluder.global.effect);
            }

            return out;
        }

        /**
         * Updates Occluders
         */

    }, {
        key: 'UpdateOccluders',
        value: function UpdateOccluders() {
            if (!this.doOcclusionQueries) return;

            var d = _core.device,
                g = EveLensflare.global;

            if (!g.occluderLevels[0].texture || g.occluderLevels[0].width < this.occluders.length * 2) {
                for (var i = 0; i < g.occluderLevels.length; ++i) {
                    g.occluderLevels[i].Create(this.occluders.length * 2, 1, false);
                }
            }

            // TODO: Is this deprecated?
            for (var j = 0; j < this.flares.length; ++j) {
                if ('_backBuffer' in this.flares[j]) {
                    this.flares[j]._backBuffer.textureRes = g.occluderLevels.texture;
                }
            }

            this.occlusionIntensity = 1;
            this.backgroundOcclusionIntensity = 1;

            g.occluderLevels[g.occludedLevelIndex].Set();
            d.SetStandardStates(d.RM_OPAQUE);
            d.gl.clearColor(0.0, 0.0, 0.0, 1.0);
            d.gl.clear(d.gl.COLOR_BUFFER_BIT);
            g.occluderLevels[g.occludedLevelIndex].Unset();

            var samples = 1;
            if (d.antialiasing) {
                samples = d.msaaSamples;
                d.gl.sampleCoverage(1.0 / samples, false);
            }

            for (var _i = 0; _i < this.occluders.length; ++_i) {
                d.SetRenderState(d.RS_COLORWRITEENABLE, 8);
                d.gl.colorMask(false, false, false, true);
                d.gl.clearColor(0.0, 0.0, 0.0, 0.0);
                d.gl.clear(d.gl.COLOR_BUFFER_BIT);

                // Turn off antialiasing
                if (d.antialiasing) {
                    d.gl.enable(d.gl.SAMPLE_COVERAGE);
                    d.gl.sampleCoverage(0.25, false);
                }
                this.occluders[_i].UpdateValue(this._transform, _i);
                if (d.antialiasing) d.gl.disable(d.gl.SAMPLE_COVERAGE);

                // Copy back buffer into a texture
                if (!g.backBuffer.texture) g.backBuffer.Attach(d.gl.createTexture());
                d.gl.bindTexture(d.gl.TEXTURE_2D, g.backBuffer.texture);
                if (g.backBuffer.width !== d.viewportWidth || g.backBuffer.height !== d.viewportHeight) {
                    d.gl.texImage2D(d.gl.TEXTURE_2D, 0, d.gl.RGBA, d.viewportWidth, d.viewportHeight, 0, d.gl.RGBA, d.gl.UNSIGNED_BYTE, null);
                    d.gl.texParameteri(d.gl.TEXTURE_2D, d.gl.TEXTURE_MAG_FILTER, d.gl.LINEAR);
                    d.gl.texParameteri(d.gl.TEXTURE_2D, d.gl.TEXTURE_MIN_FILTER, d.gl.LINEAR);
                    g.backBuffer.width = d.viewportWidth;
                    g.backBuffer.height = d.viewportHeight;
                }
                d.gl.copyTexImage2D(d.gl.TEXTURE_2D, 0, d.alphaBlendBackBuffer ? d.gl.RGBA : d.gl.RGB, 0, 0, g.backBuffer.width, g.backBuffer.height, 0);
                d.gl.bindTexture(d.gl.TEXTURE_2D, null);

                // Collect samples
                g.occluderLevels[g.occludedLevelIndex].Set();
                _EveOccluder.EveOccluder.CollectSamples(g.backBuffer, _i, g.occluderLevels[0].width / 2, samples);
                g.occluderLevels[g.occludedLevelIndex].Unset();
            }

            if (d.antialiasing) d.gl.sampleCoverage(1, false);

            g.occluderLevels[(g.occludedLevelIndex + 1) % g.occluderLevels.length].Set();
            var pixels = new Uint8Array(g.occluderLevels[0].width * 4);
            d.gl.readPixels(0, 0, 2, 1, d.gl.RGBA, d.gl.UNSIGNED_BYTE, pixels);
            g.occluderLevels[(g.occludedLevelIndex + 1) % g.occluderLevels.length].Unset();

            this.occlusionIntensity = 1;
            for (var _i2 = 0; _i2 < g.occluderLevels[0].width * 2; _i2 += 4) {
                this.occlusionIntensity *= pixels[_i2 + 1] ? pixels[_i2] / pixels[_i2 + 1] : 1;
            }

            this.backgroundOcclusionIntensity = this.occlusionIntensity;

            _core.store.SetVariableValue('LensflareFxOccScale', [this.occlusionIntensity, this.occlusionIntensity, 0, 0]);
            g.occludedLevelIndex = (g.occludedLevelIndex + 1) % g.occluderLevels.length;
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (this.display) {
                var viewDir = _math.vec4.set(EveLensflare.global.vec4_0, 0, 0, 1, 0);

                _math.vec4.transformMat4(viewDir, viewDir, _core.device.viewInverse);
                if (_math.vec3.dot(viewDir, this._direction) < 0) return;

                for (var i = 0; i < this.flares.length; ++i) {
                    this.flares[i].GetBatches(mode, accumulator, perObjectData);
                }

                if (this.mesh) {
                    this.mesh.GetBatches(mode, accumulator, perObjectData);
                }
            }
        }

        /**
         * Prepares the lensflare for rendering
         */

    }, {
        key: 'PrepareRender',
        value: function PrepareRender() {
            if (!this.display) return;

            var g = EveLensflare.global,
                viewDir = g.vec4_0,
                cameraPos = g.vec3_0,
                scaleMat = _math.mat4.identity(g.mat4_0),
                cameraSpacePos = g.vec3_2,
                negDirVec = g.vec3_3,
                negPos = g.vec3_1,
                dist = g.vec4_1;

            _math.vec3.transformMat4(cameraPos, [0, 0, 0], _core.device.viewInverse);

            if (_math.vec3.length(this.position) === 0) {
                _math.vec3.negate(negPos, cameraPos);
                //let distScale = vec3.length(negPos);
                //distScale = distScale > 1.5 ? 1 / Math.log(distScale) : 2.5;
            } else {
                _math.vec3.negate(negPos, this.position);
                _math.vec3.normalize(this._direction, negPos);
            }

            _math.vec4.transformMat4(viewDir, [0, 0, 1, 0], _core.device.viewInverse);
            _math.vec3.scaleAndAdd(cameraSpacePos, cameraPos, viewDir, -this.cameraFactor);
            _math.vec3.negate(negDirVec, this._direction);
            _math.mat4.arcFromForward(this._transform, negDirVec);
            _math.mat4.setTranslation(this._transform, cameraSpacePos);
            _math.mat4.scale(scaleMat, scaleMat, [this.occlusionIntensity, this.occlusionIntensity, 1]);
            //mat4.multiply(scaleMat, scaleMat, this._transform);

            var dir = this._direction;

            _core.store.SetVariableValue('LensflareFxDirectionScale', [dir[0], dir[1], dir[2], 1]);

            _math.vec4.set(dist, dir[0], dir[1], dir[2], 0);
            _math.vec4.transformMat4(dist, dist, _core.device.view);
            _math.vec4.transformMat4(dist, dist, _core.device.projection);
            dist[0] /= dist[3];
            dist[1] /= dist[3];

            var distToEdge = 1 - Math.min(1 - Math.abs(dist[0]), 1 - Math.abs(dist[1])),
                distToCenter = Math.sqrt(dist[0] * dist[0] + dist[1] * dist[1]),
                radialAngle = Math.atan2(dist[1], dist[0]) + Math.PI;

            for (var i = 0; i < this.distanceToEdgeCurves.length; ++i) {
                this.distanceToEdgeCurves[i].UpdateValue(distToEdge);
            }

            for (var _i3 = 0; _i3 < this.distanceToCenterCurves.length; ++_i3) {
                this.distanceToCenterCurves[_i3].UpdateValue(distToCenter);
            }

            for (var _i4 = 0; _i4 < this.radialAngleCurves.length; ++_i4) {
                this.radialAngleCurves[_i4].UpdateValue(radialAngle);
            }

            for (var _i5 = 0; _i5 < this.xDistanceToCenter.length; ++_i5) {
                this.xDistanceToCenter[_i5].UpdateValue(dist[0] + 10);
            }

            for (var _i6 = 0; _i6 < this.yDistanceToCenter.length; ++_i6) {
                this.yDistanceToCenter[_i6].UpdateValue(dist[1] + 10);
            }

            for (var _i7 = 0; _i7 < this.bindings.length; ++_i7) {
                this.bindings[_i7].CopyValue();
            }

            for (var _i8 = 0; _i8 < this.flares.length; ++_i8) {
                this.flares[_i8].UpdateViewDependentData(this._transform);
            }
        }

        /**
         * Initializes class global and scratch variables
         */

    }], [{
        key: 'init',
        value: function init() {
            if (!EveLensflare.global) {
                var g = EveLensflare.global = {};
                g.vec3_0 = _math.vec3.create();
                g.vec3_1 = _math.vec3.create();
                g.vec3_2 = _math.vec3.create();
                g.vec3_3 = _math.vec3.create();
                g.vec4_0 = _math.vec4.create();
                g.vec4_1 = _math.vec4.create();
                g.mat4_0 = _math.mat4.create();

                g.backBuffer = new _core.Tw2TextureRes();
                g.backBuffer.width = 0;
                g.backBuffer.height = 0;
                g.backBuffer.hasMipMaps = false;
                g.occludedLevelIndex = 0;
                g.occluderLevels = [new _core.Tw2RenderTarget(), new _core.Tw2RenderTarget(), new _core.Tw2RenderTarget(), new _core.Tw2RenderTarget()];
            }
        }
    }]);

    return EveLensflare;
}();

/**
 * Class global and scratch variables
 * @type {{string:*}}
 */


EveLensflare.global = null;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveMeshOverlayEffect = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(1);

var _math = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Constructor for Overlay Effects
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {boolean} display                     - Enables/ disables all batch accumulations
 * @property {{}} visible                          - Batch accumulation options for the overlay effect
 * @property {boolean} visible.opaqueEffects       - Enables/ disables opaque effect batch accumulation
 * @property {boolean} visible.decalEffects        - Enables/ disables decal effect batch accumulation
 * @property {boolean} visible.transparentEffects  - Enables/ disables transparent effect batch accumulation
 * @property {boolean} visible.additiveEffects     - Enables/ disables additive effect batch accumulation
 * @property {boolean} visible.distortionEffects   - Currently not supported
 * @property {boolean} update
 * @property {Tw2CurveSet} curveSet
 * @property {Array.<Tw2Effect>} opaqueEffects
 * @property {Array.<Tw2Effect>} decalEffects
 * @property {Array.<Tw2Effect>} transparentEffects
 * @property {Array.<Tw2Effect>} additiveEffects
 * @property {Array.<Tw2Effect>} distortionEffects - Currently not supported
 * @class
 */
var EveMeshOverlayEffect = exports.EveMeshOverlayEffect = function () {
    function EveMeshOverlayEffect() {
        _classCallCheck(this, EveMeshOverlayEffect);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.visible = {};
        this.visible.opaqueEffects = true;
        this.visible.decalEffects = true;
        this.visible.transparentEffects = true;
        this.visible.additiveEffects = true;
        this.visible.distortionEffects = false;
        this.update = true;
        this.curveSet = null;
        this.opaqueEffects = [];
        this.decalEffects = [];
        this.transparentEffects = [];
        this.additiveEffects = [];
        this.distortionEffects = [];
    }

    /**
     * Gets the mesh overlay's resources
     * @param {Array} [out=[]] - Optional receiving array
     * @returns {Array.<Tw2Resource>} [out]
     */


    _createClass(EveMeshOverlayEffect, [{
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            _math.util.perArrayChild(this.opaqueEffects, 'GetResources', out);
            _math.util.perArrayChild(this.decalEffects, 'GetResources', out);
            _math.util.perArrayChild(this.transparentEffects, 'GetResources', out);
            _math.util.perArrayChild(this.additiveEffects, 'GetResources', out);
            _math.util.perArrayChild(this.distortionEffects, 'GetResources', out);
            return out;
        }

        /**
         * Per frame update
         * @param {number} dt - delta Time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            if (this.update && this.curveSet) this.curveSet.Update(dt);
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         * @param {Tw2Mesh} mesh
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData, mesh) {
            if (!this.display || !mesh || !mesh.IsGood()) return;

            var effects = this.GetEffects(mode);
            for (var i = 0; i < effects.length; i++) {
                var batch = new _core.Tw2GeometryBatch();
                batch.renderMode = mode;
                batch.perObjectData = perObjectData;
                batch.geometryRes = mesh.geometryResource;
                batch.meshIx = mesh.meshIndex;
                batch.start = 0;
                batch.count = mesh.geometryResource.meshes[mesh.meshIndex].areas.length;
                batch.effect = effects[i];
                accumulator.Commit(batch);
            }
        }

        /**
         * Gets effects
         * @param {number} mode
         * @returns {Array.<Tw2Effect>}
         */

    }, {
        key: 'GetEffects',
        value: function GetEffects(mode) {
            if (this.display) {
                switch (mode) {
                    case _core.device.RM_OPAQUE:
                        if (this.visible.opaqueEffects) return this.opaqueEffects;
                        break;

                    case _core.device.RM_TRANSPARENT:
                        if (this.visible.transparentEffects) return this.transparentEffects;
                        break;

                    case _core.device.RM_ADDITIVE:
                        if (this.visible.additiveEffects) return this.additiveEffects;
                        break;

                    case _core.device.RM_DECAL:
                        if (this.visible.decalEffects) return this.decalEffects;
                        break;
                }
            }
            return [];
        }
    }]);

    return EveMeshOverlayEffect;
}();

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveStretch = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _index = __webpack_require__(0);

var _index2 = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EveStretch
 *
 * @property {string|number} _id
 * @property {String} name
 * @property {boolean} display
 * @property {boolean} update
 * @property {Array.<Tw2CurveSet>} curveSets
 * @property {*} source
 * @property {*} dest
 * @property {*} sourceObject
 * @property {*} destObject
 * @property {*} stretchObject
 * @property {Tw2Float} length
 * @property {number} _time
 * @property {boolean} _useTransformsForStretch
 * @property {vec3} _sourcePosition
 * @property {vec3} _destinationPosition
 * @property {boolean} _displaySourceObject
 * @property {mat4} _sourceTransform
 * @property {boolean} _displayDestObject
 * @property {boolean} _useTransformsForStretch
 * @property {boolean} _isNegZForward
 * @class
 */
var EveStretch = exports.EveStretch = function () {
    function EveStretch() {
        _classCallCheck(this, EveStretch);

        this._id = _index.util.generateID();
        this.name = '';
        this.display = true;
        this.update = true;
        this.curveSets = [];
        this.source = null;
        this.dest = null;
        this.sourceObject = null;
        this.destObject = null;
        this.stretchObject = null;
        this.length = new _index2.Tw2Float();
        this._time = 0;
        this._useTransformsForStretch = false;
        this._sourcePosition = _index.vec3.create();
        this._destinationPosition = _index.vec3.create();
        this._displaySourceObject = true;
        this._sourceTransform = null;
        this._displayDestObject = true;
        this._useTransformsForStretch = false;
        this._isNegZForward = false;

        EveStretch.init();
    }

    /**
     * Gets source position
     * @param {vec3} position
     */


    _createClass(EveStretch, [{
        key: 'SetSourcePosition',
        value: function SetSourcePosition(position) {
            this._useTransformsForStretch = false;
            this._sourcePosition = position;
        }

        /**
         * Sets the destination position
         * @param {vec3} position
         */

    }, {
        key: 'SetDestinationPosition',
        value: function SetDestinationPosition(position) {
            this._destinationPosition = position;
        }

        /**
         * Sets the source transform
         * @param {mat4} transform
         */

    }, {
        key: 'SetSourceTransform',
        value: function SetSourceTransform(transform) {
            this._useTransformsForStretch = true;
            this._sourceTransform = transform;
        }

        /**
         * SetIsNegZForward
         * @param {boolean} isNegZForward
         */

    }, {
        key: 'SetIsNegZForward',
        value: function SetIsNegZForward(isNegZForward) {
            this._isNegZForward = isNegZForward;
        }

        /**
         * Gets the stretches resources
         * @param {Array} [out=[]]
         * @return {Array<Tw2Resource>} out
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.source && this.source.GetResources) this.source.GetResources(out);
            if (this.dest && this.dest.GetResources) this.dest.GetResources(out);
            if (this.sourceObject && this.sourceObject.GetResources) this.sourceObject.GetResources(out);
            if (this.destObject && this.destObject.GetResources) this.destObject.GetResources(out);
            if (this.stretchObject && this.stretchObject.GetResources) this.stretchObject.GetResources(out);
            return out;
        }

        /**
         * Updates view dependent data
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData() {
            if (!this.display) return;

            var g = EveStretch.global,
                directionVec = _index.vec3.subtract(g.vec3_0, this._destinationPosition, this._sourcePosition),
                m = _index.mat4.identity(g.mat4_0),
                x = _index.vec3.set(g.vec3_1, 0, 0, 0),
                up = _index.vec3.set(g.vec3_2, 0, 0, 0),
                s = _index.mat4.identity(g.mat4_1);

            var scalingLength = _index.vec3.length(directionVec);
            _index.vec3.normalize(directionVec, directionVec);

            if (this._useTransformsForStretch) {
                _index.mat4.rotateX(m, m, -Math.PI / 2);
                _index.mat4.multiply(m, this._sourceTransform, m);
            } else {
                if (Math.abs(directionVec[1]) > 0.9) {
                    up[2] = 1;
                } else {
                    up[1] = 1;
                }

                _index.vec3.cross(x, up, directionVec);
                _index.vec3.normalize(x, x);
                _index.vec3.cross(up, directionVec, x);
                m[0] = x[0];
                m[1] = x[1];
                m[2] = x[2];
                m[4] = -directionVec[0];
                m[5] = -directionVec[1];
                m[6] = -directionVec[2];
                m[8] = up[0];
                m[9] = up[1];
                m[10] = up[2];
            }

            if (this.destObject && this._displayDestObject) {
                _index.mat4.setTranslation(m, this._destinationPosition);
                this.destObject.UpdateViewDependentData(m);
            }

            if (this.sourceObject && this._displaySourceObject) {
                if (this._useTransformsForStretch) {
                    _index.mat4.identity(m);
                    _index.mat4.rotateX(m, m, -Math.PI / 2);
                    _index.mat4.multiply(m, this._sourceTransform, m);
                } else {
                    _index.mat4.setTranslation(m, this._sourcePosition);
                }
                this.sourceObject.UpdateViewDependentData(m);
            }

            if (this.stretchObject) {
                if (this._useTransformsForStretch) {
                    _index.mat4.identity(m);
                    _index.mat4.scale(m, m, [1, 1, scalingLength]);
                    _index.mat4.multiply(m, this._sourceTransform, m);
                } else {
                    m[0] = x[0];
                    m[1] = x[1];
                    m[2] = x[2];
                    m[4] = up[0];
                    m[5] = up[1];
                    m[6] = up[2];
                    m[8] = -directionVec[0];
                    m[9] = -directionVec[1];
                    m[10] = -directionVec[2];
                    if (this._isNegZForward) scalingLength = -scalingLength;
                    _index.mat4.scale(s, s, [1, 1, scalingLength]);
                    _index.mat4.multiply(m, m, s);
                }
                this.stretchObject.UpdateViewDependentData(m);
            }
        }

        /**
         * Per frame update
         * @param {number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            for (var i = 0; i < this.curveSets.length; ++i) {
                this.curveSets[i].Update(dt);
            }

            this._time += dt;

            if (this.source) {
                this.source.GetValueAt(this._time, this._sourcePosition);
            } else if (this._useTransformsForStretch) {
                this._sourcePosition[0] = this._sourceTransform[12];
                this._sourcePosition[1] = this._sourceTransform[13];
                this._sourcePosition[2] = this._sourceTransform[14];
            }

            if (this.dest) {
                this.source.GetValueAt(this._time, this._destinationPosition);
            }

            var directionVec = _index.vec3.subtract(EveStretch.global.vec3_0, this._destinationPosition, this._sourcePosition);
            this.length.value = _index.vec3.length(directionVec);
            _index.vec3.normalize(directionVec, directionVec);

            if (this.sourceObject && this._displaySourceObject) {
                this.sourceObject.Update(dt);
            }

            if (this.stretchObject) {
                this.stretchObject.Update(dt);
            }

            if (this.destObject && this._displayDestObject) {
                this.destObject.Update(dt);
            }
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (!this.display) return;

            if (this.sourceObject && this._displaySourceObject) {
                this.sourceObject.GetBatches(mode, accumulator, perObjectData);
            }

            if (this.destObject && this._displayDestObject) {
                this.destObject.GetBatches(mode, accumulator, perObjectData);
            }

            if (this.stretchObject) {
                this.stretchObject.GetBatches(mode, accumulator, perObjectData);
            }
        }

        /**
         * Initializes class global and scratch variables
         */

    }], [{
        key: 'init',
        value: function init() {
            if (!EveStretch.global) {
                EveStretch.global = {
                    vec3_0: _index.vec3.create(),
                    vec3_1: _index.vec3.create(),
                    vec3_2: _index.vec3.create(),
                    mat4_0: _index.mat4.create(),
                    mat4_1: _index.mat4.create()
                };
            }
        }
    }]);

    return EveStretch;
}();

/**
 * Class global and scratch variables
 * @type {{string:*}}
 */


EveStretch.global = null;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveTurretFiringFX = exports.EvePerMuzzleData = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _index = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EvePerMuzzleData
 * Todo: Remove reference in this.muzzlePosition
 *
 * @property {boolean} started
 * @property {boolean} readyToStart
 * @property muzzlePositionBone
 * @property {mat4} muzzleTransform
 * @property {vec3} muzzlePosition
 * @property {number} currentStartDelay
 * @property {number} constantDelay
 * @property {number} elapsedTime
 * @class
 */
var EvePerMuzzleData = exports.EvePerMuzzleData = function EvePerMuzzleData() {
    _classCallCheck(this, EvePerMuzzleData);

    this._id = _index.util.generateID();
    this.started = false;
    this.readyToStart = false;
    this.muzzlePositionBone = null;
    this.muzzleTransform = _index.mat4.create();
    this.muzzlePosition = this.muzzleTransform.subarray(12, 15);
    this.currentStartDelay = 0;
    this.constantDelay = 0;
    this.elapsedTime = 0;
};

/**
 * EveTurretFiringFX
 *
 * @property {string|number} _id
 * @property {string} name
 * @property {boolean} display
 * @property {Array.<EveStretch>} stretch
 * @property {boolean} useMuzzleTransform
 * @property {boolean} isFiring
 * @property {boolean} isLoopFiring
 * @property {number} firingDelay1
 * @property {number} firingDelay2
 * @property {number} firingDelay3
 * @property {number} firingDelay4
 * @property {number} firingDelay5
 * @property {number} firingDelay6
 * @property {number} firingDelay7
 * @property {number} firingDelay8
 * @property {vec3} endPosition
 * @property {number} _firingDuration
 * @property {Array.<EvePerMuzzleData>} _perMuzzleData
 * @class
 */


var EveTurretFiringFX = exports.EveTurretFiringFX = function () {
    function EveTurretFiringFX() {
        _classCallCheck(this, EveTurretFiringFX);

        this._id = _index.util.generateID();
        this.name = '';
        this.display = true;
        this.stretch = [];
        this.useMuzzleTransform = false;
        this.isFiring = false;
        this.isLoopFiring = false;
        this.firingDelay1 = 0;
        this.firingDelay2 = 0;
        this.firingDelay3 = 0;
        this.firingDelay4 = 0;
        this.firingDelay5 = 0;
        this.firingDelay6 = 0;
        this.firingDelay7 = 0;
        this.firingDelay8 = 0;
        this.endPosition = _index.vec3.create();
        this._firingDuration = 0;
        this._perMuzzleData = [];
    }

    /**
     * Initializes the turret firing fx
     */


    _createClass(EveTurretFiringFX, [{
        key: 'Initialize',
        value: function Initialize() {
            this._firingDuration = this.GetCurveDuration();
            for (var i = 0; i < this.stretch.length; ++i) {
                this._perMuzzleData[i] = new EvePerMuzzleData();
            }if (this._perMuzzleData.length > 0) this._perMuzzleData[0].constantDelay = this.firingDelay1;
            if (this._perMuzzleData.length > 1) this._perMuzzleData[1].constantDelay = this.firingDelay2;
            if (this._perMuzzleData.length > 2) this._perMuzzleData[2].constantDelay = this.firingDelay3;
            if (this._perMuzzleData.length > 3) this._perMuzzleData[3].constantDelay = this.firingDelay4;
            if (this._perMuzzleData.length > 4) this._perMuzzleData[4].constantDelay = this.firingDelay5;
            if (this._perMuzzleData.length > 5) this._perMuzzleData[5].constantDelay = this.firingDelay6;
            if (this._perMuzzleData.length > 6) this._perMuzzleData[6].constantDelay = this.firingDelay7;
            if (this._perMuzzleData.length > 7) this._perMuzzleData[7].constantDelay = this.firingDelay8;
        }

        /**
         * Gets the total curve duration
         * @returns {number}
         */

    }, {
        key: 'GetCurveDuration',
        value: function GetCurveDuration() {
            var maxDuration = 0;
            for (var i = 0; i < this.stretch.length; ++i) {
                var stretch = this.stretch[i];
                for (var j = 0; j < stretch.curveSets.length; ++j) {
                    maxDuration = Math.max(maxDuration, stretch.curveSets[j].GetMaxCurveDuration());
                }
            }
            return maxDuration;
        }

        /**
         * Gets a count of stretch effects
         * @returns {Number}
         */

    }, {
        key: 'GetPerMuzzleEffectCount',
        value: function GetPerMuzzleEffectCount() {
            return this.stretch.length;
        }

        /**
         * Sets muzzle bone id
         * @param {number} index
         * @param bone
         */

    }, {
        key: 'SetMuzzleBoneID',
        value: function SetMuzzleBoneID(index, bone) {
            this._perMuzzleData[index].muzzlePositionBone = bone;
        }

        /**
         * Gets a muzzle's transform
         * @param {number} index
         * @returns {mat4}
         */

    }, {
        key: 'GetMuzzleTransform',
        value: function GetMuzzleTransform(index) {
            return this._perMuzzleData[index].muzzleTransform;
        }

        /**
         * Prepares the firing effect
         * @param {number} delay
         * @param {number} [muzzleID=-1]
         */

    }, {
        key: 'PrepareFiring',
        value: function PrepareFiring(delay) {
            var muzzleID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

            for (var i = 0; i < this.stretch.length; ++i) {
                if (muzzleID < 0 || muzzleID === i) {
                    this._perMuzzleData[i].currentStartDelay = delay + this._perMuzzleData[i].constantDelay;
                    this._perMuzzleData[i].started = false;
                    this._perMuzzleData[i].readyToStart = false;
                    this._perMuzzleData[i].elapsedTime = 0;
                } else {
                    this._perMuzzleData[i].currentStartDelay = Number.MAX_VALUE;
                    this._perMuzzleData[i].started = false;
                    this._perMuzzleData[i].readyToStart = false;
                    this._perMuzzleData[i].elapsedTime = 0;
                }
            }
            this.isFiring = true;
        }

        /**
         * Starts a muzzle effect
         * @param {number} muzzleID
         */

    }, {
        key: 'StartMuzzleEffect',
        value: function StartMuzzleEffect(muzzleID) {
            var stretch = this.stretch[muzzleID];
            for (var i = 0; i < stretch.curveSets.length; ++i) {
                var curveSet = stretch.curveSets[i];
                switch (curveSet.name) {
                    case 'play_start':
                    case 'play_loop':
                        curveSet.PlayFrom(-this._perMuzzleData[muzzleID].currentStartDelay);
                        break;

                    case 'play_stop':
                        curveSet.Stop();
                        break;
                }
            }
            this._perMuzzleData[muzzleID].started = true;
            this._perMuzzleData[muzzleID].readyToStart = false;
        }

        /**
         * Stops the firing effect
         */

    }, {
        key: 'StopFiring',
        value: function StopFiring() {
            for (var j = 0; j < this.stretch.length; ++j) {
                var stretch = this.stretch[j];
                for (var i = 0; i < stretch.curveSets.length; ++i) {
                    var curveSet = stretch.curveSets[i];
                    switch (curveSet.name) {
                        case 'play_start':
                        case 'play_loop':
                            curveSet.Stop();
                            break;

                        case 'play_stop':
                            curveSet.Play();
                            break;
                    }
                }
                this._perMuzzleData[j].started = false;
                this._perMuzzleData[j].readyToStart = false;
                this._perMuzzleData[j].currentStartDelay = 0;
                this._perMuzzleData[j].elapsedTime = 0;
            }
            this.isFiring = false;
        }

        /**
         * Gets resources
         * @param {Array} [out=[]}
         * @returns {Array<Resource>} out
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            for (var i = 0; i < this.stretch.length; i++) {
                this.stretch[i].GetResources(out);
            }
            return out;
        }

        /**
         * Updates view dependant data
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData() {
            for (var i = 0; i < this.stretch.length; ++i) {
                this.stretch[i].UpdateViewDependentData();
            }
        }

        /**
         * Per frame update
         * @param {number} dt - Delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            for (var i = 0; i < this.stretch.length; ++i) {
                if (this._perMuzzleData[i].started) {
                    this._perMuzzleData[i].elapsedTime += dt;
                }

                if (this._perMuzzleData[i].elapsedTime < this._firingDuration || this.isLoopFiring) {
                    if (this.isFiring) {
                        if (!this._perMuzzleData[i].started) {
                            if (this._perMuzzleData[i].readyToStart) {
                                this.StartMuzzleEffect(i);
                                this._perMuzzleData[i].currentStartDelay = 0;
                                this._perMuzzleData[i].elapsedTime = 0;
                            } else {
                                this._perMuzzleData[i].currentStartDelay -= dt;
                            }

                            if (this._perMuzzleData[i].currentStartDelay <= 0) {
                                this._perMuzzleData[i].readyToStart = true;
                            }
                        } else {
                            if (this.useMuzzleTransform) {
                                this.stretch[i].SetSourceTransform(this._perMuzzleData[i].muzzleTransform);
                            } else {
                                this.stretch[i].SetSourcePosition(this._perMuzzleData[i].muzzlePosition);
                            }
                            this.stretch[i].SetDestinationPosition(this.endPosition);
                            this.stretch[i].SetIsNegZForward(true);
                        }
                    }
                }
                this.stretch[i].Update(dt);
            }
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (!this.display || !this.isFiring) return;

            for (var i = 0; i < this.stretch.length; ++i) {
                if (this._perMuzzleData[i].started && (this._firingDuration >= this._perMuzzleData[i].elapsedTime || this.isLoopFiring)) {
                    this.stretch[i].GetBatches(mode, accumulator, perObjectData);
                }
            }
        }
    }]);

    return EveTurretFiringFX;
}();

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveEffectRoot = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _index = __webpack_require__(0);

var _index2 = __webpack_require__(1);

var _EveObject2 = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EveEffectRoot root objects for FX, can be put into scene's objects array
 *
 * @property {string} name
 * @property {boolean} display
 * @property {[{}]} curveSets
 * @property {[{}]} effectChildren
 * @property {vec3} scaling
 * @property {quat} rotation
 * @property {vec3} translation
 * @property {mat4} localTransform
 * @property {mat4} rotationTransform
 * @property {vec3} boundingSphereCenter
 * @property {number} boundingSphereRadius
 * @property {number} duration
 * @property {Tw2PerObjectData} _perObjectData
 * @class
 */
var EveEffectRoot = exports.EveEffectRoot = function (_EveObject) {
    _inherits(EveEffectRoot, _EveObject);

    function EveEffectRoot() {
        _classCallCheck(this, EveEffectRoot);

        var _this = _possibleConstructorReturn(this, (EveEffectRoot.__proto__ || Object.getPrototypeOf(EveEffectRoot)).call(this));

        _this.curveSets = [];
        _this.effectChildren = [];
        _this.duration = 0;
        _this.scaling = _index.vec3.fromValues(1, 1, 1);
        _this.rotation = _index.quat.create();
        _this.translation = _index.vec3.create();
        _this.localTransform = _index.mat4.create();
        _this.rotationTransform = _index.mat4.create();
        _this.boundingSphereCenter = _index.vec3.create();
        _this.boundingSphereRadius = 0;

        _this._perObjectData = new _index2.Tw2PerObjectData();
        _this._perObjectData.perObjectVSData = new _index2.Tw2RawData();
        _this._perObjectData.perObjectVSData.Declare('WorldMat', 16);
        _this._perObjectData.perObjectVSData.Declare('WorldMatLast', 16);
        _this._perObjectData.perObjectVSData.Declare('Shipdata', 4);
        _this._perObjectData.perObjectVSData.Declare('Clipdata1', 4);
        _this._perObjectData.perObjectVSData.Declare('EllipsoidRadii', 4);
        _this._perObjectData.perObjectVSData.Declare('EllipsoidCenter', 4);
        _this._perObjectData.perObjectVSData.Declare('CustomMaskMatrix0', 16);
        _this._perObjectData.perObjectVSData.Declare('CustomMaskMatrix1', 16);
        _this._perObjectData.perObjectVSData.Declare('CustomMaskData0', 4);
        _this._perObjectData.perObjectVSData.Declare('CustomMaskData1', 4);
        _this._perObjectData.perObjectVSData.Declare('JointMat', 696);
        _this._perObjectData.perObjectVSData.Create();

        _this._perObjectData.perObjectPSData = new _index2.Tw2RawData();
        _this._perObjectData.perObjectPSData.Declare('Shipdata', 4);
        _this._perObjectData.perObjectPSData.Declare('Clipdata1', 4);
        _this._perObjectData.perObjectPSData.Declare('Clipdata2', 4);
        _this._perObjectData.perObjectPSData.Declare('ShLighting', 4 * 7);
        _this._perObjectData.perObjectPSData.Declare('CustomMaskMaterialID0', 4);
        _this._perObjectData.perObjectPSData.Declare('CustomMaskMaterialID1', 4);
        _this._perObjectData.perObjectPSData.Declare('CustomMaskTarget0', 4);
        _this._perObjectData.perObjectPSData.Declare('CustomMaskTarget1', 4);
        _this._perObjectData.perObjectPSData.Create();
        return _this;
    }

    /**
     * Starts playing the effectRoot's curveSets if they exist
     */


    _createClass(EveEffectRoot, [{
        key: 'Start',
        value: function Start() {
            for (var i = 0; i < this.curveSets.length; ++i) {
                this.curveSets[i].Play();
            }
        }

        /**
         * Stops the effectRoot's curveSets from playing
         */

    }, {
        key: 'Stop',
        value: function Stop() {
            for (var i = 0; i < this.curveSets.length; ++i) {
                this.curveSets[i].Stop();
            }
        }

        /**
         * Gets effect root res objects
         * @param {Array} [out=[]] - Optional receiving array
         * @returns {Array.<Tw2EffectRes|Tw2TextureRes>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            for (var i = 0; i < this.effectChildren.length; ++i) {
                this.effectChildren[i].GetResources(out);
            }
            return out;
        }

        /**
         * Internal per frame update
         * @param {number} dt - Delta Time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            _index.quat.normalize(this.rotation, this.rotation); // Don't really need to normalize...
            _index.mat4.fromRotationTranslationScale(this.localTransform, this.rotation, this.translation, this.scaling);

            for (var i = 0; i < this.curveSets.length; ++i) {
                this.curveSets[i].Update(dt);
            }

            for (var _i = 0; _i < this.effectChildren.length; ++_i) {
                this.effectChildren[_i].Update(dt, this.localTransform);
            }
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (!this.display) return;

            for (var i = 0; i < this.effectChildren.length; ++i) {
                this.effectChildren[i].GetBatches(mode, accumulator, this._perObjectData);
            }
        }
    }]);

    return EveEffectRoot;
}(_EveObject2.EveObject);

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveMissile = exports.EveMissileWarhead = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveObject2 = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EveMissileWarhead
 *
 * @property {String} name
 * @property {Boolean} display
 * @property {Tw2Mesh} mesh
 * @property {EveSpriteSet} spriteSet
 * @property {Number} state
 * @property {Number} time
 * @property {Number} durationEjectPhase
 * @property {Number} startEjectVelocity
 * @property {Number} acceleration
 * @property {Number} maxExplosionDistance
 * @property {Number} impactSize
 * @property {Number} impactDuration
 * @property {vec3} pathOffset
 * @property {mat4} transform
 * @property {vec3} velocity
 * @property {Tw2PerObjectData} _perObjectData
 * @class
 */
var EveMissileWarhead = exports.EveMissileWarhead = function (_EveObject) {
    _inherits(EveMissileWarhead, _EveObject);

    function EveMissileWarhead() {
        _classCallCheck(this, EveMissileWarhead);

        var _this = _possibleConstructorReturn(this, (EveMissileWarhead.__proto__ || Object.getPrototypeOf(EveMissileWarhead)).call(this));

        _this.mesh = null;
        _this.spriteSet = null;
        _this.state = EveMissileWarhead.State.READY;
        _this.time = 0;
        _this.durationEjectPhase = 0;
        _this.startEjectVelocity = 0;
        _this.acceleration = 1;
        _this.maxExplosionDistance = 40;
        _this.impactSize = 0;
        _this.impactDuration = 0.6;
        _this.pathOffset = _math.vec3.create();
        _this.transform = _math.mat4.create();
        _this.velocity = _math.vec3.create();

        _this._perObjectData = new _core.Tw2PerObjectData();
        _this._perObjectData.perObjectVSData = new _core.Tw2RawData();
        _this._perObjectData.perObjectVSData.Declare('WorldMat', 16);
        _this._perObjectData.perObjectVSData.Declare('WorldMatLast', 16);
        _this._perObjectData.perObjectVSData.Declare('Shipdata', 4);
        _this._perObjectData.perObjectVSData.Declare('Clipdata1', 4);
        _this._perObjectData.perObjectVSData.Create();

        _this._perObjectData.perObjectPSData = new _core.Tw2RawData();
        _this._perObjectData.perObjectPSData.Declare('Shipdata', 4);
        _this._perObjectData.perObjectPSData.Declare('Clipdata1', 4);
        _this._perObjectData.perObjectPSData.Declare('Clipdata2', 4);
        _this._perObjectData.perObjectPSData.Create();

        _this._perObjectData.perObjectVSData.Get('Shipdata')[1] = 1;
        _this._perObjectData.perObjectPSData.Get('Shipdata')[1] = 1;
        _this._perObjectData.perObjectVSData.Get('Shipdata')[3] = -10;
        _this._perObjectData.perObjectPSData.Get('Shipdata')[3] = 1;
        return _this;
    }

    /**
     * Initializes the warhead
     */


    _createClass(EveMissileWarhead, [{
        key: 'Initialize',
        value: function Initialize() {
            if (this.spriteSet) this.spriteSet.UseQuads(true);
        }

        /**
         * Sets up the warhead for rendering
         * @param {mat4} transform - Initial local to world transform
         */

    }, {
        key: 'Launch',
        value: function Launch(transform) {
            _math.mat4.copy(this.transform, transform);
            this.velocity[0] = transform[8] * this.startEjectVelocity;
            this.velocity[1] = transform[9] * this.startEjectVelocity;
            this.velocity[2] = transform[10] * this.startEjectVelocity;
            this.time = 0;
            this.state = EveMissileWarhead.State.IN_FLIGHT;
        }

        /**
         * Creates a clone of the warhead
         * @returns {EveMissileWarhead}
         */

    }, {
        key: 'Clone',
        value: function Clone() {
            var warhead = new EveMissileWarhead();
            warhead.mesh = this.mesh;
            warhead.spriteSet = this.spriteSet;
            return warhead;
        }

        /**
         * Gets warhead resources
         * @param {Array} [out=[]] - Receiving array
         * @returns {Array<Tw2Resource>} out
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.mesh) this.mesh.GetResources(out);
            if (this.spriteSet) this.spriteSet.GetResources(out);
        }

        /**
         * Per frame view dependent data update
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData() {
            if (!this.display || this.state === EveMissileWarhead.State.DEAD) return;
            _math.mat4.transpose(this._perObjectData.perObjectVSData.Get('WorldMat'), this.transform);
            _math.mat4.transpose(this._perObjectData.perObjectVSData.Get('WorldMatLast'), this.transform);
        }

        /**
         * Per frame update
         * @param {Number} dt - Time since previous frame
         * @param {vec3} missilePosition - Missile position
         * @param {vec3} missileTarget - Missile target position
         */

    }, {
        key: 'Update',
        value: function Update(dt, missilePosition, missileTarget) {
            if (this.state === EveMissileWarhead.State.IN_FLIGHT) {
                var g = EveMissileWarhead.global,
                    position = _math.mat4.getTranslation(g.vec3_0, this.transform),
                    tmp = g.vec3_1,
                    x = g.vec3_2,
                    y = g.vec3_3;

                this.time += dt;
                if (this.time > this.durationEjectPhase) {
                    _math.vec3.subtract(position, this.velocity, missilePosition);
                    _math.vec3.lerp(position, position, missilePosition, 1 - Math.exp(-dt * 0.9999));
                    _math.mat4.setTranslation(this.transform, position);
                    _math.vec3.subtract(tmp, missileTarget, position);
                    if (_math.vec3.length(tmp) < this.maxExplosionDistance) {
                        console.log(position, tmp);
                        this.state = EveMissileWarhead.State.DEAD;
                    }
                } else {
                    _math.vec3.scale(tmp, this.velocity, dt);
                    this.transform[12] += tmp[0];
                    this.transform[13] += tmp[1];
                    this.transform[14] += tmp[2];
                }

                var z = _math.vec3.normalize(tmp, this.velocity);

                if (Math.abs(z[0]) < 0.99) {
                    _math.vec3.cross(x, z, [1, 0, 0]);
                } else {
                    _math.vec3.cross(x, z, [0, 1, 0]);
                }

                _math.vec3.normalize(x, x);
                _math.vec3.cross(y, x, z);
                this.transform[0] = x[0];
                this.transform[1] = x[1];
                this.transform[2] = x[2];
                this.transform[4] = y[0];
                this.transform[5] = y[1];
                this.transform[6] = y[2];
                this.transform[8] = z[0];
                this.transform[9] = z[1];
                this.transform[10] = z[2];
            }

            if (this.spriteSet) {
                this.spriteSet.Update(dt);
            }
        }

        /**
         * Accumulates render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (this.display && this.mesh && this.state !== EveMissileWarhead.State.DEAD) {
                if (this.mesh) {
                    this.mesh.GetBatches(mode, accumulator, this._perObjectData);
                }

                if (this.spriteSet) {
                    this.spriteSet.GetBatches(mode, accumulator, this._perObjectData, this.transform);
                }
            }
        }
    }]);

    return EveMissileWarhead;
}(_EveObject2.EveObject);

/**
 * Missile warhead states
 * @type {{READY: number, IN_FLIGHT: number, DEAD: number}}
 */


EveMissileWarhead.State = {
    READY: 0,
    IN_FLIGHT: 1,
    DEAD: 2
};

/**
 * EveMissile
 *
 * @property {number|string} _id
 * @property {String} name
 * @property {Boolean} display
 * @property {Array} warheads
 * @property {Array} curveSets
 * @property {vec3} boundingSphereCenter
 * @property {Number} boundingSphereRadius
 * @property {vec3} position
 * @property {vec3} target
 * @property {Number} speed
 * @property {?function(EveMissileWarhead): void} warheadExplosionCallback
 * @property {?function(EveMissile): void} missileFinishedCallback
 * @class
 */

var EveMissile = exports.EveMissile = function () {
    function EveMissile() {
        _classCallCheck(this, EveMissile);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.warheads = [];
        this.curveSets = [];
        this.speed = 1;
        this.position = _math.vec3.create();
        this.target = _math.vec3.create();
        this.boundingSphereCenter = _math.vec3.create();
        this.boundingSphereRadius = 0;
        this.warheadExplosionCallback = null;
        this.missileFinishedCallback = null;

        EveMissile.init();
    }

    /**
     * Prepares missile for rendering
     * @param {vec3} position - Missile starting position
     * @param {Array} turretTransforms - Turret muzzle local to world transforms
     * @param {vec3} target - Target position
     */


    _createClass(EveMissile, [{
        key: 'Launch',
        value: function Launch(position, turretTransforms, target) {
            _math.vec3.copy(this.position, position);
            _math.vec3.copy(this.target, target);

            if (this.warheads.length > turretTransforms.length) {
                this.warheads.splice(turretTransforms.length);
            } else {
                while (this.warheads.length < turretTransforms.length) {
                    this.warheads.push(this.warheads[0].Clone());
                }
            }

            for (var i = 0; i < this.warheads.length; ++i) {
                this.warheads[0].Launch(turretTransforms[i]);
            }
        }

        /**
         * Gets missile res objects
         * @param {Array} [out=[]] - Receiving array
         * @returns {Array<Tw2Resource>} out
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            for (var i = 0; i < this.warheads.length; ++i) {
                this.warheads[i].GetResources(out);
            }
        }

        /**
         * Per frame view dependent data update
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData() {
            for (var i = 0; i < this.warheads.length; ++i) {
                this.warheads[i].UpdateViewDependentData();
            }
        }

        /**
         * Per frame update
         * @param {Number} dt - Time since previous frame
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            var tmp = _math.vec3.subtract(EveMissileWarhead.global.vec3_0, this.target, this.position),
                distance = _math.vec3.length(tmp);

            if (distance > 0.1) {
                _math.vec3.normalize(tmp, tmp);
                _math.vec3.scale(tmp, tmp, Math.min(dt * this.speed, distance));
                _math.vec3.add(this.position, this.position, tmp);
            }

            for (var i = 0; i < this.curveSets.length; ++i) {
                this.curveSets[i].Update(dt);
            }

            var checkDead = false;
            for (var _i = 0; _i < this.warheads.length; ++_i) {
                var state = this.warheads[_i].state;
                this.warheads[_i].Update(dt, this.position, this.target);

                if (state !== EveMissileWarhead.State.DEAD && this.warheads[_i].state === EveMissileWarhead.State.DEAD) {
                    if (this.warheadExplosionCallback) {
                        this.warheadExplosionCallback(this.warheads[_i]);
                    }
                    checkDead = true;
                }
            }

            if (checkDead && this.missileFinishedCallback) {
                for (var _i2 = 0; _i2 < this.warheads.length; ++_i2) {
                    if (this.warheads[_i2].state !== EveMissileWarhead.State.DEAD) {
                        return;
                    }
                }
                this.missileFinishedCallback(this);
            }
        }

        /**
         * Accumulates render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (!this.display) return;

            for (var i = 0; i < this.warheads.length; ++i) {
                this.warheads[i].GetBatches(mode, accumulator);
            }
        }
    }]);

    return EveMissile;
}();

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EvePlanet = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(1);

var _EveTransform = __webpack_require__(61);

var _EveObject2 = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EvePlanet
 *
 * @property {string} name
 * @property {boolean} display
 * @property {EveTransform} highDetail
 * @property {Tw2Effect} effectHeight
 * @property {Tw2RenderTarget} heightMap
 * @property {*} zOnlyModel
 * @property {number} itemID
 * @property {string} heightMapResPath1
 * @property {string} heightMapResPath2
 * @property {boolean} heightDirty
 * @property {Array} lockedResources
 * @property {Array.<Resource>} watchedResources
 * @class
 */
var EvePlanet = exports.EvePlanet = function (_EveObject) {
    _inherits(EvePlanet, _EveObject);

    function EvePlanet() {
        _classCallCheck(this, EvePlanet);

        var _this = _possibleConstructorReturn(this, (EvePlanet.__proto__ || Object.getPrototypeOf(EvePlanet)).call(this));

        _this.highDetail = new _EveTransform.EveTransform();
        _this.effectHeight = new _core.Tw2Effect();
        _this.heightMap = new _core.Tw2RenderTarget();
        _this.zOnlyModel = null;
        _this.itemID = 0;
        _this.heightMapResPath1 = '';
        _this.heightMapResPath2 = '';
        _this.heightDirty = false;
        _this.lockedResources = [];
        _this.watchedResources = [];
        return _this;
    }

    /**
     * Creates the planet
     * @param {number} itemID - the item id is used for randomization
     * @param {string} planetPath - .red file for a planet, or planet template
     * @param {string} [atmospherePath] - optional .red file for a planet's atmosphere
     * @param {string} heightMap1
     * @param {string} heightMap2
     */


    _createClass(EvePlanet, [{
        key: 'Create',
        value: function Create(itemID, planetPath, atmospherePath, heightMap1, heightMap2) {
            var _this2 = this;

            this.itemID = itemID;
            this.heightMapResPath1 = heightMap1;
            this.heightMapResPath2 = heightMap2;
            this.highDetail.children = [];
            this.heightDirty = true;

            _core.resMan.GetObject(planetPath, function (obj) {
                return EvePlanet.MeshLoaded(_this2, obj);
            });
            _core.resMan.GetObject('res:/dx9/model/worldobject/planet/planetzonly.red', function (obj) {
                return _this2.zOnlyModel = obj;
            });

            if (atmospherePath) {
                _core.resMan.GetObject(atmospherePath, function (obj) {
                    return _this2.highDetail.children.push(obj);
                });
            }
        }

        /**
         * GetPlanetResources
         * Todo: Replace this, using this.GetResources();
         * @param obj
         * @param visited
         * @param result
         */

    }, {
        key: 'GetPlanetResources',
        value: function GetPlanetResources(obj, visited, result) {
            if (visited.includes(obj)) return;
            visited.push(obj);

            if (obj && _typeof(obj['doNotPurge']) !== ( true ? 'undefined' : _typeof(undefined))) {
                result.push(obj);
                return;
            }

            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    if (_typeof(obj[prop]) === 'object') {
                        this.GetPlanetResources(obj[prop], visited, result);
                    }
                }
            }
        }

        /**
         * Gets planet res objects
         * @param {Array} [out=[]] - Optional receiving array
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.highDetail) this.highDetail.GetResources(out);
            if (this.effectHeight) this.effectHeight.GetResources(out);
            return out;
        }

        /**
         * Updates view dependent data
         * @param {mat4} parentTransform
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData(parentTransform) {
            this.highDetail.UpdateViewDependentData(parentTransform);
            if (this.zOnlyModel) {
                this.zOnlyModel.translation = this.highDetail.translation;
                this.zOnlyModel.scaling = this.highDetail.scaling;
                this.zOnlyModel.UpdateViewDependentData(parentTransform);
            }
        }

        /**
         * Per frame update
         * @param {number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            this.highDetail.Update(dt);
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (this.display && this.heightDirty && this.watchedResources.length && this.heightMapResPath1 !== '') {
                for (var i = 0; i < this.watchedResources.length; ++i) {
                    if (this.watchedResources[i] && !this.watchedResources[i].IsGood()) return;
                }

                this.watchedResources = [];

                this.heightMap.Set();
                _core.device.SetStandardStates(_core.device.RM_FULLSCREEN);
                _core.device.gl.clearColor(0.0, 0.0, 0.0, 0.0);
                _core.device.gl.clear(_core.device.gl.COLOR_BUFFER_BIT);
                _core.device.RenderFullScreenQuad(this.effectHeight);
                this.heightMap.Unset();

                this.heightDirty = false;
                for (var _i = 0; _i < this.lockedResources.length; ++_i) {
                    this.lockedResources[_i].doNotPurge--;
                }

                var mainMesh = this.highDetail.children[0].mesh;
                var originalEffect = null;

                if (mainMesh.transparentAreas.length) {
                    originalEffect = mainMesh.transparentAreas[0].effect;
                } else if (mainMesh.opaqueAreas.length) {
                    originalEffect = mainMesh.opaqueAreas[0].effect;
                }

                if (originalEffect) {
                    originalEffect.parameters['HeightMap'].textureRes = this.heightMap.texture;
                }
            }

            if (this.display) {
                this.highDetail.GetBatches(mode, accumulator);
            }
        }

        /**
         * Gets z buffer only batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetZOnlyBatches',
        value: function GetZOnlyBatches(mode, accumulator) {
            if (this.display && this.zOnlyModel) {
                this.zOnlyModel.GetBatches(mode, accumulator);
            }
        }

        /**
         * Internal helper function that fires when a planet's mesh has loaded
         * @property {EvePlanet} planet
         * @property {*} obj
         */

    }], [{
        key: 'MeshLoaded',
        value: function MeshLoaded(planet, obj) {
            planet.highDetail.children.unshift(obj);
            planet.lockedResources = [];
            planet.GetPlanetResources(planet.highDetail, [], planet.lockedResources);

            var mainMesh = planet.highDetail.children[0].mesh,
                originalEffect = null,
                resPath = void 0;

            if (mainMesh.transparentAreas.length) {
                originalEffect = mainMesh.transparentAreas[0].effect;
                resPath = originalEffect.effectFilePath;
            } else if (mainMesh.opaqueAreas.length) {
                originalEffect = mainMesh.opaqueAreas[0].effect;
                resPath = originalEffect.effectFilePath;
            } else {
                resPath = 'res:/Graphics/Effect/Managed/Space/Planet/EarthlikePlanet.fx';
            }
            resPath = resPath.replace('.fx', 'BlitHeight.fx');

            planet.watchedResources = [];
            for (var param in originalEffect.parameters) {
                if (originalEffect.parameters.hasOwnProperty(param)) {
                    planet.effectHeight.parameters[param] = originalEffect.parameters[param];
                    if ('textureRes' in originalEffect.parameters[param]) {
                        planet.watchedResources.push(originalEffect.parameters[param].textureRes);
                    }
                }
            }

            for (var i = 0; i < planet.highDetail.children[0].children.length; ++i) {
                mainMesh = planet.highDetail.children[0].children[i].mesh;
                if (!mainMesh) continue;

                originalEffect = null;
                if (mainMesh.transparentAreas.length) {
                    originalEffect = mainMesh.transparentAreas[0].effect;
                } else if (mainMesh.opaqueAreas.length) {
                    originalEffect = mainMesh.opaqueAreas[0].effect;
                } else {
                    continue;
                }

                for (var _param in originalEffect.parameters) {
                    if (originalEffect.parameters.hasOwnProperty(_param)) {
                        planet.effectHeight.parameters[_param] = originalEffect.parameters[_param];
                        if ('textureRes' in originalEffect.parameters[_param]) {
                            planet.watchedResources.push(originalEffect.parameters[_param].textureRes);
                        }
                    }
                }
            }

            var NormalHeight1 = new _core.Tw2TextureParameter('NormalHeight1', planet.heightMapResPath1);
            NormalHeight1.Initialize();
            planet.watchedResources.push(NormalHeight1.textureRes);
            planet.lockedResources.push(NormalHeight1.textureRes);
            planet.effectHeight.parameters.NormalHeight1 = NormalHeight1;

            var NormalHeight2 = new _core.Tw2TextureParameter('NormalHeight2', planet.heightMapResPath2);
            NormalHeight2.Initialize();
            planet.watchedResources.push(NormalHeight2.textureRes);
            planet.lockedResources.push(NormalHeight2.textureRes);
            planet.effectHeight.parameters.NormalHeight2 = NormalHeight2;

            planet.effectHeight.parameters.Random = new _core.Tw2FloatParameter('Random', planet.itemID % 100);
            planet.effectHeight.parameters.TargetTextureHeight = new _core.Tw2FloatParameter('TargetTextureHeight', 1024);

            planet.effectHeight.effectFilePath = resPath;
            planet.effectHeight.Initialize();
            planet.heightDirty = true;
            planet.heightMap.Create(2048, 1024, false);
            planet.watchedResources.push(planet.effectHeight.effectRes);

            for (var _i2 = 0; _i2 < planet.lockedResources.length; ++_i2) {
                planet.lockedResources[_i2].doNotPurge++;
                if (planet.lockedResources[_i2].IsPurged()) {
                    planet.lockedResources[_i2].Reload();
                }
            }
        }
    }]);

    return EvePlanet;
}(_EveObject2.EveObject);

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveShip = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _EveSpaceObject2 = __webpack_require__(62);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EveShip
 *
 * @property {boolean} visible.turretSets      - Enables/ disables turret set batch accumulation
 * @property {boolean} visible.boosters        - Enables/ disables booster batch accumulation
 * @property {Array.<EveBoosterSet>} boosters
 * @property {Array.<EveTurretSet>} turretSets
 * @property {number} boosterGain
 * @class
 */
var EveShip = exports.EveShip = function (_EveSpaceObject) {
    _inherits(EveShip, _EveSpaceObject);

    function EveShip() {
        _classCallCheck(this, EveShip);

        var _this = _possibleConstructorReturn(this, (EveShip.__proto__ || Object.getPrototypeOf(EveShip)).call(this));

        _this.visible.turretSets = true;
        _this.visible.boosters = true;
        _this.boosters = null;
        _this.turretSets = [];
        _this.boosterGain = 1;
        return _this;
    }

    /**
     * Initializes the Eve Ship
     */


    _createClass(EveShip, [{
        key: 'Initialize',
        value: function Initialize() {
            _get(EveShip.prototype.__proto__ || Object.getPrototypeOf(EveShip.prototype), 'Initialize', this).call(this);
            if (this.boosters) {
                this.RebuildBoosterSet();
            }
        }

        /**
         * Rebuilds the ship's booster set
         */

    }, {
        key: 'RebuildBoosterSet',
        value: function RebuildBoosterSet() {
            if (this.boosters) {
                this.boosters.UpdateItemsFromLocators(this.FindLocatorsByPrefix('locator_booster'));
            }
        }

        /**
         * Rebuilds turret sets
         */

    }, {
        key: 'RebuildTurretPositions',
        value: function RebuildTurretPositions() {
            for (var i = 0; i < this.turretSets.length; i++) {
                this.RebuildTurretSet(i);
            }
        }

        /**
         * Rebuilds a turret set
         * @param {number} index
         */

    }, {
        key: 'RebuildTurretSet',
        value: function RebuildTurretSet(index) {
            if (this.turretSets[index] === undefined) return;

            var turretSet = this.turretSets[index],
                prefix = turretSet.locatorName,
                count = this.GetLocatorCount(prefix),
                locators = [];

            for (var j = 0; j < count; ++j) {
                var name = prefix + String.fromCharCode('a'.charCodeAt(0) + j),
                    locator = this.FindLocatorByName(name);

                if (locator) {
                    locator.FindBone(this.animation);
                    locators.push(locator);
                }
            }

            turretSet.UpdateItemsFromLocators(locators);
        }

        /**
         * Gets ship's res objects
         * @param {Array} [out=[]] - Optional receiving array
         * @param {Boolean} excludeChildren - True to exclude children's res objects
         * @returns {Array.<Tw2EffectRes|Tw2TextureRes|Tw2GeometryRes>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var excludeChildren = arguments[1];

            _get(EveShip.prototype.__proto__ || Object.getPrototypeOf(EveShip.prototype), 'GetResources', this).call(this, out, excludeChildren);

            for (var i = 0; i < this.turretSets.length; i++) {
                this.turretSets[i].GetResources(out);
            }

            if (this.boosters) {
                this.boosters.GetResources(out);
            }

            return out;
        }

        /**
         * Updates view dependant data
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData() {
            _get(EveShip.prototype.__proto__ || Object.getPrototypeOf(EveShip.prototype), 'UpdateViewDependentData', this).call(this);

            for (var i = 0; i < this.turretSets.length; ++i) {
                this.turretSets[i].UpdateViewDependentData();
            }
        }

        /**
         * Per frame update
         * @param {number} dt - deltaTime
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            _get(EveShip.prototype.__proto__ || Object.getPrototypeOf(EveShip.prototype), 'Update', this).call(this, dt);

            if (this.boosters) {
                if (this.boosters._locatorRebuildPending) {
                    this.RebuildBoosterSet();
                }

                this.boosters.Update(dt, this.transform);
            }

            for (var i = 0; i < this.turretSets.length; ++i) {
                if (this.turretSets[i]._locatorRebuildPending) {
                    this.RebuildTurretSet(i);
                }

                this.turretSets[i].Update(dt, this.transform);
            }
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (this.display) {
                _get(EveShip.prototype.__proto__ || Object.getPrototypeOf(EveShip.prototype), 'GetBatches', this).call(this, mode, accumulator);

                this._perObjectData.perObjectVSData.Get('Shipdata')[0] = this.boosterGain;
                this._perObjectData.perObjectPSData.Get('Shipdata')[0] = this.boosterGain;

                if (this.boosters && this.visible.boosters) {
                    this.boosters.GetBatches(mode, accumulator, this._perObjectData);
                }

                if (this.visible.turretSets) {
                    if (this.lod > 1) {
                        for (var i = 0; i < this.turretSets.length; ++i) {
                            this.turretSets[i].GetBatches(mode, accumulator, this._perObjectData, this.visible.firingEffects);
                        }
                    } else if (this.visible.firingEffects) {
                        for (var _i = 0; _i < this.turretSets.length; ++_i) {
                            if (this.turretSets[_i].firingEffect) {
                                this.turretSets[_i].firingEffect.GetBatches(mode, accumulator, this._perObjectData);
                            }
                        }
                    }
                }
            }
        }
    }]);

    return EveShip;
}(_EveSpaceObject2.EveSpaceObject);

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveBoosterSet = exports.EveBoosterSetItem = exports.EveBoosterBatch = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveObjectSet2 = __webpack_require__(10);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Booster render batch
 *
 * @property {EveBoosterSet} boosters
 * @class
 */
var EveBoosterBatch = exports.EveBoosterBatch = function (_Tw2RenderBatch) {
    _inherits(EveBoosterBatch, _Tw2RenderBatch);

    function EveBoosterBatch() {
        _classCallCheck(this, EveBoosterBatch);

        var _this = _possibleConstructorReturn(this, (EveBoosterBatch.__proto__ || Object.getPrototypeOf(EveBoosterBatch)).call(this));

        _this.boosters = null;
        return _this;
    }

    /**
     * Commits the batch
     * @param {string} technique - technique name
     */


    _createClass(EveBoosterBatch, [{
        key: 'Commit',
        value: function Commit(technique) {
            this.boosters.Render(technique);
        }
    }]);

    return EveBoosterBatch;
}(_core.Tw2RenderBatch);

/**
 * EveBoosterSetItem
 *
 * @param {boolean} enableCustomValues   - Enables custom values
 * @property {{}} visible                - Visibility options
 * @property {boolean} visible.halo      - Toggles halo visibility
 * @property {boolean} visible.symHalo   - Toggles symmetrical halo visibility
 * @property {boolean} visible.glow      - Toggles glow visibility
 * @property {boolean} visible.trail     - Toggles trail visibility (not implemented)
 * @property {?string} locatorName       - The item's locator name, if it was built from one
 * @property {boolean} updateFromLocator - Sets whether the item should be updated when it's locator is
 * @property {mat4} transform            - The item's local transform
 * @property {number} atlas0             - The item's atlas index 0
 * @property {number} atlas1             - The item's atlas index 1
 * @property {number} seed               - A random seed which affects any glows built from this item
 * @property {number} wavePhase          - A random seed which affects the booster wave pattern
 * @property {*} customValues            - An optional object containing custom values
 * @class
 */


var EveBoosterSetItem = exports.EveBoosterSetItem = function (_EveObjectSetItem) {
    _inherits(EveBoosterSetItem, _EveObjectSetItem);

    function EveBoosterSetItem() {
        _classCallCheck(this, EveBoosterSetItem);

        var _this2 = _possibleConstructorReturn(this, (EveBoosterSetItem.__proto__ || Object.getPrototypeOf(EveBoosterSetItem)).call(this));

        _this2.visible = {};
        _this2.visible.glow = true;
        _this2.visible.symHalo = true;
        _this2.visible.halo = true;
        _this2.visible.trail = true;
        _this2.visible.customValues = false;
        _this2.locatorName = null;
        _this2.updateFromLocator = false;
        _this2.seed = Math.random() * 7;
        _this2.wavePhase = Math.random();
        _this2.atlas0 = 0;
        _this2.atlas1 = 0;
        _this2.transform = _math.mat4.create();
        _this2.customValues = null;
        return _this2;
    }

    /**
     * Gets the item's position
     * @param {vec3} out
     * @returns {vec3} out
     */


    _createClass(EveBoosterSetItem, [{
        key: 'GetPosition',
        value: function GetPosition(out) {
            return _math.mat4.getTranslation(out, this.transform);
        }

        /**
         * Gets the item's direction
         * @param {vec3} out
         * @returns {vec3} out
         */

    }, {
        key: 'GetDirection',
        value: function GetDirection(out) {
            _math.vec3.set(out, this.transform[8], this.transform[9], this.transform[10]);
            _math.vec3.normalize(out, out);
            var scale = this.GetScale();
            if (scale < 3) _math.vec3.scale(out, out, scale / 3);
            return out;
        }

        /**
         * Gets the item's scale
         * @returns {number}
         */

    }, {
        key: 'GetScale',
        value: function GetScale() {
            var tr = this.transform;
            return Math.max(_math.vec3.length([tr[0], tr[1], tr[2]]), _math.vec3.length([tr[4], tr[5], tr[6]]));
        }

        /**
         * Creates an item from an object
         * @param {*} [opt={}]
         * @returns {EveBoosterSetItem}
         */

    }], [{
        key: 'create',
        value: function create() {
            var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var item = new this();
            _math.util.assignIfExists(item.visible, opt.visible, ['glow', 'symHalo', 'halo', 'trail']);
            _math.util.assignIfExists(item, opt, ['name', 'display', 'seed', 'wavePhase', 'transform', 'locatorName', 'updateFromLocator', 'atlas0', 'atlas1']);
            return item;
        }
    }]);

    return EveBoosterSetItem;
}(_EveObjectSet2.EveObjectSetItem);

/**
 * EveBoosterSet
 *
 * @property {{}} visible                      - Visibility controls
 * @property {boolean} visible.glows           - Toggles glow visibility
 * @property {boolean} visible.symHalos        - Toggles symmetrical halo visibility
 * @property {boolean} visible.halos           - Toggles halo visibility
 * @property {boolean} visible.trails          - Toggles trails visibility (Not implemented)
 * @property {Tw2Effect} effect                - The booster's booster effect
 * @property {?Tw2Effect} glows                - The booster's glows (sprites)
 * @property {number} maxVel                   - (Not implemented)
 * @property {boolean} alwaysOn                - (Not implemented)
 * @property {number} glowDistance             - The distance between the booster's locators and glow sprites
 * @property {number} glowScale                - The base scale of the booster's glow sprites
 * @property {vec4} glowColor                  - The color of the booster set's glow sprites
 * @property {vec4} warpGlowColor              - The color of the booster set's glow sprites when warping (Not implemented)
 * @property {number} haloDistance             - The distance between the booster set's locators and halo sprites
 * @property {number} haloScaleX               - The base vertical scale of the booster set's halos
 * @property {number} haloScaleY               - The base horizontal scale of the booster set's halos
 * @property {vec4} haloColor                  - The color of the booster set's halo sprites
 * @property {vec4} warpHaloColor              - The color of the booster set's halo sprites when warping (Not implemented)
 * @property {vec4} trailSize                  - The booster set's trail size (Not implemented)
 * @property {vec4} trailColor                 - The booster set's trail color (Not implemented)
 * @property {number} symHaloDistance          - The distance between the booster set's locators and symmetrical halo sprites
 * @property {number} symHaloScale             - The base scale of the booster set's symmetrical halos
 * @property {mat4} _parentTransform           - The booster set's parent's transform
 * @property {WebGLBuffer} _positions          - The booster set's webgl buffer
 * @property {Tw2VertexDeclaration} _decl      - The booster set's vertex declarations
 * @property {Tw2PerObjectData} _perObjectData - The booster set's shader data
 * @property {boolean} _locatorRebuildPending  - Identifies that the booster set needs to be rebuilt from locators
 * @class
 */


var EveBoosterSet = exports.EveBoosterSet = function (_EveObjectSet) {
    _inherits(EveBoosterSet, _EveObjectSet);

    function EveBoosterSet() {
        _classCallCheck(this, EveBoosterSet);

        var _this3 = _possibleConstructorReturn(this, (EveBoosterSet.__proto__ || Object.getPrototypeOf(EveBoosterSet)).call(this));

        _this3.visible = {};
        _this3.visible.glows = true;
        _this3.visible.symHalos = true;
        _this3.visible.halos = true;
        _this3.visible.trails = true;
        _this3.effect = null;
        _this3.glows = null;
        _this3.alwaysOn = true;
        _this3.maxVel = 250;
        _this3.glowDistance = 2.5;
        _this3.glowScale = 1.0;
        _this3.glowColor = _math.vec4.create();
        _this3.warpGlowColor = _math.vec4.create();
        _this3.haloDistance = 3.01;
        _this3.haloScaleX = 1.0;
        _this3.haloScaleY = 1.0;
        _this3.haloColor = _math.vec4.create();
        _this3.warpHaloColor = _math.vec4.create();
        _this3.symHaloDistance = 3;
        _this3.symHaloScale = 1.0;
        _this3.trailColor = _math.vec4.create();
        _this3.trailSize = _math.vec4.create();
        _this3._parentTransform = _math.mat4.create();
        _this3._positions = null;

        _this3._decl = new _core.Tw2VertexDeclaration();
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.POSITION, 0, _core.device.gl.FLOAT, 3, 0));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 0, _core.device.gl.FLOAT, 2, 12));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 4, 20));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 2, _core.device.gl.FLOAT, 4, 36));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 3, _core.device.gl.FLOAT, 4, 52));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 4, _core.device.gl.FLOAT, 4, 68));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 5, _core.device.gl.FLOAT, 4, 84));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 6, _core.device.gl.FLOAT, 1, 100));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 7, _core.device.gl.FLOAT, 2, 104));
        _this3._decl.RebuildHash();

        _this3._perObjectData = new _core.Tw2PerObjectData();
        _this3._perObjectData.perObjectVSData = new _core.Tw2RawData();
        _this3._perObjectData.perObjectVSData.Declare('WorldMat', 16);
        _this3._perObjectData.perObjectVSData.Declare('Shipdata', 4);
        _this3._perObjectData.perObjectVSData.Create();

        _this3._locatorRebuildPending = true;
        return _this3;
    }

    /**
     * Finds a booster item that belongs to a locator by it's name
     * @param {string} locatorName
     * @returns {?EveBoosterSetItem}
     */


    _createClass(EveBoosterSet, [{
        key: 'FindItemByLocatorName',
        value: function FindItemByLocatorName(locatorName) {
            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i].locatorName && this.items[i].locatorName === locatorName) {
                    return this.items[i];
                }
            }
            return null;
        }

        /**
         * Updates booster items that were built from locators
         * @param {Array.<EveLocator>} locators
         */

    }, {
        key: 'UpdateItemsFromLocators',
        value: function UpdateItemsFromLocators(locators) {
            var items = Array.from(this.items);

            for (var i = 0; i < locators.length; i++) {
                var _locators$i = locators[i],
                    name = _locators$i.name,
                    transform = _locators$i.transform,
                    atlasIndex0 = _locators$i.atlasIndex0,
                    atlasIndex1 = _locators$i.atlasIndex1;


                var item = this.FindItemByLocatorName(name);
                if (!item) {
                    this.CreateItem({
                        name: name,
                        locatorName: name,
                        updateFromLocator: true,
                        atlas0: atlasIndex0,
                        atlas1: atlasIndex1,
                        transform: transform
                    });
                } else {
                    items.splice(items.indexOf(item), 1);

                    if (item.updateFromLocator) {
                        _math.mat4.copy(item.transform, transform);
                        item.atlas0 = atlasIndex0;
                        item.atlas1 = atlasIndex1;
                        item.OnValueChanged();
                    }
                }
            }

            for (var _i = 0; _i < items.length; _i++) {
                if (items[_i].locatorName !== null) {
                    this.RemoveItem(items[_i]);
                    _i--;
                }
            }

            this._locatorRebuildPending = false;

            if (this._rebuildPending) {
                this.Rebuild();
            }
        }

        /**
         * Rebuilds the booster set from it's parent's locators
         */

    }, {
        key: 'RebuildItemsFromLocators',
        value: function RebuildItemsFromLocators() {
            this._locatorRebuildPending = true;
        }

        /**
         * Gets booster set resources
         * @param {Array} [out=[]] - Optional receiving array
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.effect) {
                this.effect.GetResources(out);
            }

            if (this.glows) {
                this.glows.effect.GetResources(out);
            }

            return out;
        }

        /**
         * Per frame update
         * @param {number} dt - DeltaTime
         * @param {mat4} parentMatrix
         */

    }, {
        key: 'Update',
        value: function Update(dt, parentMatrix) {
            _math.mat4.copy(this._parentTransform, parentMatrix);
            if (this._rebuildPending) this.Rebuild();
            if (this.glows) this.glows.Update(dt);
        }

        /**
         * Unloads the booster's buffers
         */

    }, {
        key: 'Unload',
        value: function Unload() {
            if (this._positions) {
                _core.device.gl.deleteBuffer(this._positions);
                this._positions = null;
            }

            if (this.glows) {
                this.glows.Unload();
            }
        }

        /**
         * Rebuilds the boosters
         */

    }, {
        key: 'Rebuild',
        value: function Rebuild() {
            this.constructor.RebuildItems(this);
            var itemCount = this._visibleItems.length;
            this._rebuildPending = false;
            if (!itemCount) return;

            var d = _core.device,
                box = EveBoosterSet._box,
                data = new Float32Array(itemCount * box.length * 6 * 28),
                order = [0, 3, 1, 3, 2, 1];

            var index = 0;
            for (var i = 0; i < itemCount; ++i) {
                var item = this._visibleItems[i];
                for (var b = 0; b < box.length; ++b) {
                    for (var j = 0; j < order.length; ++j) {
                        data[index++] = box[b][order[j]][0];
                        data[index++] = box[b][order[j]][1];
                        data[index++] = box[b][order[j]][2];
                        data[index++] = 0;
                        data[index++] = 0;
                        data.set(item.transform, index);
                        index += 16;
                        data[index++] = 0;
                        data[index++] = 1;
                        data[index++] = 1;
                        data[index++] = 1;
                        data[index++] = item.wavePhase;
                        data[index++] = item.atlas0;
                        data[index++] = item.atlas1;
                    }
                }
            }

            this._positions = d.gl.createBuffer();
            d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._positions);
            d.gl.bufferData(d.gl.ARRAY_BUFFER, data, d.gl.STATIC_DRAW);
            d.gl.bindBuffer(d.gl.ARRAY_BUFFER, null);
            this._positions.count = itemCount * 12 * 3;

            if (this.glows) this.glows.Rebuild();
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (!this.display || mode !== _core.device.RM_ADDITIVE || !this._positions || !this._visibleItems.length) return;

            if (this.effect) {
                var batch = new EveBoosterBatch();
                _math.mat4.transpose(this._perObjectData.perObjectVSData.Get('WorldMat'), this._parentTransform);
                this._perObjectData.perObjectVSData.Set('Shipdata', perObjectData.perObjectVSData.Get('Shipdata'));
                this._perObjectData.perObjectPSData = perObjectData.perObjectPSData;
                batch.perObjectData = this._perObjectData;
                batch.boosters = this;
                batch.renderMode = _core.device.RM_ADDITIVE;
                accumulator.Commit(batch);
            }

            if (this.glows) {
                this.glows.GetBoosterGlowBatches(mode, accumulator, perObjectData, this._parentTransform, perObjectData.perObjectVSData.Get('Shipdata')[0], 0);
            }
        }

        /**
         * Renders the accumulated batches
         * @param {string} technique - technique name
         * @returns {boolean}
         */

    }, {
        key: 'Render',
        value: function Render(technique) {
            if (!this.effect || !this.effect.IsGood()) return false;

            _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._positions);
            for (var pass = 0; pass < this.effect.GetPassCount(technique); ++pass) {
                this.effect.ApplyPass(technique, pass);
                if (!this._decl.SetDeclaration(this.effect.GetPassInput(technique, pass), 112)) return false;
                _core.device.ApplyShadowState();
                _core.device.gl.drawArrays(_core.device.gl.TRIANGLES, 0, this._positions.count);
            }
            return true;
        }

        /**
         * Rebuilds a booster set's items
         * @param {EveBoosterSet} boosters
         */

    }], [{
        key: 'RebuildItems',
        value: function RebuildItems(boosters) {
            var glows = boosters.glows,
                g = EveBoosterSet.global,
                spritePos = g.vec3_0;

            if (glows) glows.ClearItems();
            boosters._visibleItems = [];

            for (var i = 0; i < boosters.items.length; i++) {
                var item = boosters.items[i];
                item._onModified = boosters._onChildModified;

                if (item.display) {
                    boosters._visibleItems.push(item);

                    if (glows) {
                        var src = item.customValues && item.customValues.display ? item.customValues : boosters,
                            pos = item.GetPosition(g.vec3_1),
                            dir = item.GetDirection(g.vec3_2),
                            scale = item.GetScale();

                        if (boosters.visible.glows && item.visible.glow) {
                            glows.CreateItem({
                                name: item.name + '_glow',
                                position: _math.vec3.subtract(spritePos, pos, _math.vec3.scale(spritePos, dir, src.glowDistance)),
                                blinkRate: item.seed,
                                blinkPhase: item.seed,
                                minScale: src.glowScale * scale,
                                maxScale: src.glowScale * scale,
                                color: src.glowColor,
                                warpColor: src.warpGlowColor
                            });
                        }

                        if (boosters.visible.symHalos && item.visible.symHalo) {
                            glows.CreateItem({
                                name: item.name + '_symHalo',
                                position: _math.vec3.subtract(spritePos, pos, _math.vec3.scale(spritePos, dir, src.symHaloDistance)),
                                blinkRate: item.seed,
                                blinkPhase: item.seed + 1,
                                minScale: src.symHaloScale * scale,
                                maxScale: src.symHaloScale * scale,
                                color: src.haloColor,
                                warpColor: src.warpHaloColor
                            });
                        }

                        if (boosters.visible.halos && item.visible.halo) {
                            glows.CreateItem({
                                name: item.name + '_halo',
                                position: _math.vec3.subtract(spritePos, pos, _math.vec3.scale(spritePos, dir, src.haloDistance)),
                                blinkRate: item.seed,
                                blinkPhase: item.seed + 1,
                                minScale: src.haloScaleX * scale,
                                maxScale: src.haloScaleY * scale,
                                color: src.haloColor,
                                warpColor: src.warpHaloColor
                            });
                        }
                    }

                    item._rebuildPending = false;
                }
            }
        }
    }]);

    return EveBoosterSet;
}(_EveObjectSet2.EveObjectSet);

/**
 * The booster set's item constructor
 * @type {EveBoosterSetItem}
 */


EveBoosterSet.Item = EveBoosterSetItem;

/**
 * Internal helper
 * @type {Array}
 */
EveBoosterSet._box = [[[-1.0, -1.0, 0.0], [1.0, -1.0, 0.0], [1.0, 1.0, 0.0], [-1.0, 1.0, 0.0]], [[-1.0, -1.0, -1.0], [-1.0, 1.0, -1.0], [1.0, 1.0, -1.0], [1.0, -1.0, -1.0]], [[-1.0, -1.0, 0.0], [-1.0, 1.0, 0.0], [-1.0, 1.0, -1.0], [-1.0, -1.0, -1.0]], [[1.0, -1.0, 0.0], [1.0, -1.0, -1.0], [1.0, 1.0, -1.0], [1.0, 1.0, 0.0]], [[-1.0, -1.0, 0.0], [-1.0, -1.0, -1.0], [1.0, -1.0, -1.0], [1.0, -1.0, 0.0]], [[-1.0, 1.0, 0.0], [1.0, 1.0, 0.0], [1.0, 1.0, -1.0], [-1.0, 1.0, -1.0]]];

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveCurveLineSet = exports.EveCurveLineSetItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveObjectSet2 = __webpack_require__(10);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EveCurveLineSetItem
 *
 * @property {number} type
 * @property {vec3} position1
 * @property {vec4} color1
 * @property {vec3} position2
 * @property {vec4} color2
 * @property {vec3} intermediatePosition
 * @property {number} width
 * @property {vec4} multiColor
 * @property {number} multiColorBorder
 * @property {vec4} overlayColor
 * @property {number} animationSpeed
 * @property {number} animationScale
 * @property {number} numOfSegments
 * @class
 */
var EveCurveLineSetItem = exports.EveCurveLineSetItem = function (_EveObjectSetItem) {
    _inherits(EveCurveLineSetItem, _EveObjectSetItem);

    function EveCurveLineSetItem() {
        _classCallCheck(this, EveCurveLineSetItem);

        var _this = _possibleConstructorReturn(this, (EveCurveLineSetItem.__proto__ || Object.getPrototypeOf(EveCurveLineSetItem)).call(this));

        _this.type = EveCurveLineSetItem.Type.INVALID;
        _this.position1 = _math.vec3.create();
        _this.color1 = _math.vec4.fromValues(1, 1, 1, 1);
        _this.position2 = _math.vec3.create();
        _this.color2 = _math.vec4.fromValues(1, 1, 1, 1);
        _this.intermediatePosition = _math.vec3.create();
        _this.width = 1;
        _this.multiColor = _math.vec4.fromValues(0, 0, 0, 1);
        _this.multiColorBorder = -1;
        _this.overlayColor = _math.vec4.fromValues(0, 0, 0, 1);
        _this.animationSpeed = 0;
        _this.animationScale = 1;
        _this.numOfSegments = 1;
        return _this;
    }

    /**
     * Changes the line's colors
     * @param {vec3} startColor
     * @param {vec3} endColor
     */


    _createClass(EveCurveLineSetItem, [{
        key: 'ChangeColor',
        value: function ChangeColor(startColor, endColor) {
            _math.vec3.copy(this.color1, startColor);
            _math.vec3.copy(this.color2, endColor);
            this.OnValueChanged();
        }

        /**
         * Changes the line's width
         * @param {number} width
         */

    }, {
        key: 'ChangeWidth',
        value: function ChangeWidth(width) {
            this.width = width;
            this.OnValueChanged();
        }

        /**
         * Changes positions from cartesian coordinates
         * @param {vec3} startPosition
         * @param {vec3} endPosition
         * @param {vec3} middle
         */

    }, {
        key: 'ChangeCartesian',
        value: function ChangeCartesian(startPosition, endPosition, middle) {
            _math.vec3.copy(this.position1, startPosition);
            _math.vec3.copy(this.position2, endPosition);
            _math.vec3.copy(this.intermediatePosition, middle);
            this.OnValueChanged();
        }

        /**
         * Changes cartesian position
         * @param {vec3} startPosition
         * @param {vec3} endPosition
         */

    }, {
        key: 'ChangePositionCartesian',
        value: function ChangePositionCartesian(startPosition, endPosition) {
            _math.vec3.copy(this.position1, startPosition);
            _math.vec3.copy(this.position2, endPosition);
            this.OnValueChanged();
        }

        /**
         * Changes cartesian intermediate position
         * @param {vec3} intermediatePosition
         */

    }, {
        key: 'ChangeIntermediateCartesian',
        value: function ChangeIntermediateCartesian(intermediatePosition) {
            _math.vec3.copy(this.intermediatePosition, intermediatePosition);
            this.OnValueChanged();
        }

        /**
         * Changes positions from spherical
         * @param {vec3} startPosition
         * @param {vec3} endPosition
         * @param {vec3} middle
         * @param {vec3} center
         */

    }, {
        key: 'ChangeSpherical',
        value: function ChangeSpherical(startPosition, endPosition, middle, center) {
            _math.vec3.fromSpherical(this.position1, startPosition, center);
            _math.vec3.fromSpherical(this.position2, endPosition, center);
            _math.vec3.fromSpherical(this.intermediatePosition, middle, center);
            this.OnValueChanged();
        }

        /**
         * Changes position from spherical coordinates
         * @param {vec3} startPosition
         * @param {vec3} endPosition
         * @param {vec3} center
         */

    }, {
        key: 'ChangePositionSpherical',
        value: function ChangePositionSpherical(startPosition, endPosition, center) {
            _math.vec3.fromSpherical(this.position1, startPosition, center);
            _math.vec3.fromSpherical(this.position2, endPosition, center);
            this.OnValueChanged();
        }

        /**
         * Changes spherical intermediate position
         * @param {vec3} intermediatePosition
         * @param {vec3} center
         */

    }, {
        key: 'ChangeIntermediateSpherical',
        value: function ChangeIntermediateSpherical(intermediatePosition, center) {
            _math.vec3.fromSpherical(this.intermediatePosition, intermediatePosition, center);
            this.OnValueChanged();
        }

        /**
         * Changes multi line color
         * @param {vec4} color
         * @param {number} border
         */

    }, {
        key: 'ChangeMultiColor',
        value: function ChangeMultiColor(color, border) {
            _math.vec4.copy(this.multiColor, color);
            this.multiColorBorder = border;
            this.OnValueChanged();
        }

        /**
         * Changes animated color settings
         * @param {vec4} color
         * @param {number} speed
         * @param {number} scale
         */

    }, {
        key: 'ChangeAnimation',
        value: function ChangeAnimation(color, speed, scale) {
            _math.vec4.copy(this.overlayColor, color);
            this.animationSpeed = speed;
            this.animationScale = scale;
            this.OnValueChanged();
        }

        /**
         * Changes line segmentation
         * @param {number} numOfSegments
         */

    }, {
        key: 'ChangeSegmentation',
        value: function ChangeSegmentation(numOfSegments) {
            if (this.type !== EveCurveLineSetItem.Type.STRAIGHT) {
                this.numOfSegments = numOfSegments;
                this.OnValueChanged();
            }
        }

        /**
         * Creates a line from an object
         * @param {*} [opt={}]
         * @returns {EveCurveLineSetItem}
         */

    }], [{
        key: 'create',
        value: function create() {
            var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var item = new this();
            _math.util.assignIfExists(item, opt, ['name', 'display', 'type', 'position1', 'color1', 'position2', 'color2', 'intermediatePosition', 'width', 'multiColor', 'multiColorBorder', 'overlayColor', 'animationSpeed', 'animationScale', 'numOfSegments']);
            return item;
        }
    }]);

    return EveCurveLineSetItem;
}(_EveObjectSet2.EveObjectSetItem);

/**
 * Curve line types
 * @type {{INVALID: number, STRAIGHT: number, SPHERED: number, CURVED: number}}
 */


EveCurveLineSetItem.Type = {
    INVALID: 0,
    STRAIGHT: 1,
    SPHERED: 2,
    CURVED: 3
};

/**
 * Default curved line segmentation
 * @type {number}
 */
EveCurveLineSetItem.DEFAULT_CURVED_SEGMENTS = 20;

/**
 * Default sphered line segmentation
 * @type {number}
 */
EveCurveLineSetItem.DEFAULT_SPHERED_SEGEMENTS = 20;

/**
 * EveCurveLineSet
 *
 * @property {Tw2Effect} lineEffect
 * @property {?Tw2Effect} pickEffect
 * @property {number} lineWidthFactor
 * @property {boolean} additive
 * @property {number} depthOffset
 * @property {vec3} translation
 * @property {quat} rotation
 * @property {vec3} scaling
 * @property {mat4} transform
 * @property {mat4} parentTransform
 * @property {number} _vertexSize
 * @property {number} _vbSize
 * @property {?WebGLBuffer} _vb
 * @property {Tw2PerObjectData} _perObjectData
 * @property {Tw2VertexDeclaration} _decl
 * @class
 */

var EveCurveLineSet = exports.EveCurveLineSet = function (_EveObjectSet) {
    _inherits(EveCurveLineSet, _EveObjectSet);

    function EveCurveLineSet() {
        _classCallCheck(this, EveCurveLineSet);

        var _this2 = _possibleConstructorReturn(this, (EveCurveLineSet.__proto__ || Object.getPrototypeOf(EveCurveLineSet)).call(this));

        _this2.lineEffect = _core.Tw2Effect.create({
            effectFilePath: 'res:/Graphics/Effect/Managed/Space/SpecialFX/Lines3D.fx',
            textures: {
                'TexMap': 'res:/texture/global/white.dds.0.png',
                'OverlayTexMap': 'res:/texture/global/white.dds.0.png'
            }
        });

        _this2.pickEffect = null;
        _this2.lineWidthFactor = 1;
        _this2.additive = false;
        _this2.pickable = true;
        _this2.depthOffset = 0;
        _this2.translation = _math.vec3.create();
        _this2.rotation = _math.quat.create();
        _this2.scaling = _math.vec3.fromValues(1, 1, 1);
        _this2.transform = _math.mat4.create();
        _this2.parentTransform = _math.mat4.create();
        _this2._vertexSize = 26;
        _this2._vbSize = 0;
        _this2._vb = null;

        _this2._perObjectData = new _core.Tw2PerObjectData();
        _this2._perObjectData.perObjectVSData = new _core.Tw2RawData();
        _this2._perObjectData.perObjectVSData.Declare('WorldMat', 16);
        _this2._perObjectData.perObjectVSData.Create();
        _this2._perObjectData.perObjectPSData = new _core.Tw2RawData();
        _this2._perObjectData.perObjectPSData.Declare('WorldMat', 16);
        _this2._perObjectData.perObjectPSData.Create();

        _this2._decl = new _core.Tw2VertexDeclaration();
        _this2._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.POSITION, 0, _core.device.gl.FLOAT, 3, 0));
        _this2._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 0, _core.device.gl.FLOAT, 4, 12));
        _this2._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 4, 28));
        _this2._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 2, _core.device.gl.FLOAT, 3, 44));
        _this2._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 0, _core.device.gl.FLOAT, 4, 56));
        _this2._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 1, _core.device.gl.FLOAT, 4, 72));
        _this2._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 2, _core.device.gl.FLOAT, 4, 88));
        _this2._decl.stride = 4 * _this2._vertexSize;
        _this2._decl.RebuildHash();

        EveCurveLineSet.init();
        return _this2;
    }

    /**
     * Alias for this.items
     * @returns {Array}
     */


    _createClass(EveCurveLineSet, [{
        key: 'Initialize',


        /**
         * Initializes the curve line set
         */
        value: function Initialize() {
            this.OnValueChanged();
            this.Rebuild();
        }

        /**
         * Creates a straight line
         * @param {vec3} start
         * @param {vec3} end
         * @param {number} [width]
         * @param {vec4} [startColor]
         * @param {vec4} [endColor]
         * @returns {EveCurveLineSetItem}
         */

    }, {
        key: 'AddStraightLine',
        value: function AddStraightLine(start, end, width, startColor, endColor) {
            return this.CreateItem({
                type: EveCurveLineSetItem.Type.STRAIGHT,
                position1: start,
                position2: end,
                color1: startColor,
                color2: endColor,
                width: width
            });
        }

        /**
         * Creates and adds a curved line from cartesian coordinates
         * @param {vec3} start
         * @param {vec3} end
         * @param {vec3} center
         * @param {number} [width]
         * @param {vec4} [startColor]
         * @param {vec4} [endColor]
         * @returns {EveCurveLineSetItem}
         */

    }, {
        key: 'AddCurvedLineCrt',
        value: function AddCurvedLineCrt(start, end, center, width, startColor, endColor) {
            return this.CreateItem({
                type: EveCurveLineSetItem.Type.CURVED,
                position1: start,
                position2: end,
                intermediatePosition: center,
                color1: startColor,
                color2: endColor,
                width: width,
                numOfSegments: EveCurveLineSetItem.DEFAULT_CURVED_SEGMENTS
            });
        }

        /**
         * Creates and adds a curved line from spherical coordinates
         * @param {vec3} start
         * @param {vec3} end
         * @param {vec3} center
         * @param {vec3} middle
         * @param {number} [width]
         * @param {vec4} [startColor]
         * @param {vec4} [endColor]
         * @returns {EveCurveLineSetItem}
         */

    }, {
        key: 'AddCurvedLineSph',
        value: function AddCurvedLineSph(start, end, center, middle, width, startColor, endColor) {
            var g = EveCurveLineSet.global;
            return this.CreateItem({
                type: EveCurveLineSetItem.Type.CURVED,
                position1: _math.vec3.fromSpherical(g.vec3_0, start, center),
                position2: _math.vec3.fromSpherical(g.vec3_1, end, center),
                intermediatePosition: _math.vec3.fromSpherical(g.vec3_2, middle, center),
                color1: startColor,
                color2: endColor,
                width: width,
                numOfSegments: EveCurveLineSetItem.DEFAULT_CURVED_SEGMENTS
            });
        }

        /**
         * Creates and adds a sphered line from cartesian coordinates
         * @param {vec3} start
         * @param {vec3} end
         * @param {vec3} center
         * @param {number} [width]
         * @param {vec4} [startColor]
         * @param {vec4} [endColor]
         * @returns {EveCurveLineSetItem}
         */

    }, {
        key: 'AddSpheredLineCrt',
        value: function AddSpheredLineCrt(start, end, center, width, startColor, endColor) {
            return this.CreateItem({
                type: EveCurveLineSetItem.Type.SPHERED,
                position1: start,
                position2: end,
                intermediatePosition: center,
                color1: startColor,
                color2: endColor,
                width: width,
                numOfSegments: EveCurveLineSetItem.DEFAULT_SPHERED_SEGEMENTS
            });
        }

        /**
         * Creates and adds a sphered line from spherical coordinates
         * @param {vec3} start
         * @param {vec3} end
         * @param {vec3} center
         * @param {vec3} middle
         * @param {number} [width]
         * @param {vec4} [startColor]
         * @param {vec4} [endColor]
         * @returns {EveCurveLineSetItem}
         */

    }, {
        key: 'AddSpheredLineSph',
        value: function AddSpheredLineSph(start, end, center, middle, width, startColor, endColor) {
            var g = EveCurveLineSet.global;
            return this.CreateItem({
                type: EveCurveLineSetItem.Type.SPHERED,
                position1: _math.vec3.fromSpherical(g.vec3_0, start, center),
                position2: _math.vec3.fromSpherical(g.vec3_1, end, center),
                intermediatePosition: _math.vec3.fromSpherical(g.vec3_2, middle, center),
                color1: startColor,
                color2: endColor,
                width: width,
                numOfSegments: EveCurveLineSetItem.DEFAULT_SPHERED_SEGEMENTS
            });
        }

        /**
         * Fire on value changes
         */

    }, {
        key: 'OnValueChanged',
        value: function OnValueChanged() {
            _math.mat4.fromRotationTranslationScale(this.transform, this.rotation, this.translation, this.scaling);
            this._rebuildPending = true;
        }

        /**
         * Per frame update
         * @param {mat4} parentTransform
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData(parentTransform) {
            _math.mat4.copy(this.parentTransform, parentTransform);
        }

        /**
         * Per frame update
         */

    }, {
        key: 'Update',
        value: function Update() {
            if (this._rebuildPending) {
                this.Rebuild();
            }
        }

        /**
         * Unloads the line set's buffers
         */

    }, {
        key: 'Unload',
        value: function Unload() {
            if (this._vb) {
                _core.device.gl.deleteBuffer(this._vb);
                this._vb = null;
            }
        }

        /**
         * Rebuilds the line set
         */

    }, {
        key: 'Rebuild',
        value: function Rebuild() {
            EveCurveLineSet.RebuildItems(this);
            this._vb = null;
            this._vbSize = this.lineCount;
            this._rebuildPending = false;
            var visibleItems = this._visibleItems.length;
            if (!visibleItems) return;

            var g = EveCurveLineSet.global,
                data = new Float32Array(this._vbSize * 6 * this._vertexSize),
                startDir = g.vec3_0,
                endDir = g.vec3_1,
                startDirNrm = g.vec3_2,
                endDirNrm = g.vec3_3,
                rotationAxis = g.vec3_4,
                tangent1 = g.vec3_5,
                tangent2 = g.vec3_6,
                rotationMatrix = g.mat4_0;

            var dir1 = g.vec3_7,
                dir2 = g.vec3_8,
                pos1 = g.vec3_9,
                pos2 = g.vec3_10,
                col1 = g.vec4_0,
                col2 = g.vec4_1,
                offset = 0,
                tmp = void 0;

            for (var i = 0; i < visibleItems; ++i) {
                var item = this._visibleItems[i];
                switch (item.type) {
                    case EveCurveLineSetItem.Type.INVALID:
                        break;

                    case EveCurveLineSetItem.Type.STRAIGHT:
                        EveCurveLineSet.WriteLineVerticesToBuffer(this, item.position1, item.color1, 0, item.position2, item.color2, 1, i, data, offset);
                        offset += 6 * this._vertexSize;
                        break;

                    case EveCurveLineSetItem.Type.SPHERED:
                        _math.vec3.subtract(startDir, item.position1, item.intermediatePosition);
                        _math.vec3.subtract(endDir, item.position2, item.intermediatePosition);
                        _math.vec3.normalize(startDirNrm, startDir);
                        _math.vec3.normalize(endDirNrm, endDir);
                        _math.vec3.cross(rotationAxis, startDir, endDir);

                        var fullAngle = Math.acos(_math.vec3.dot(startDirNrm, endDirNrm)),
                            segmentAngle = fullAngle / item.numOfSegments;

                        _math.mat4.identity(rotationMatrix);
                        _math.mat4.rotate(rotationMatrix, rotationMatrix, segmentAngle, rotationAxis);
                        _math.vec3.copy(dir1, startDir);
                        _math.vec4.copy(col1, item.color1);

                        for (var j = 0; j < this.lines[i].numOfSegments; ++j) {
                            var segmentFactor = (j + 1) / item.numOfSegments;
                            _math.vec3.transformMat4(dir2, dir1, rotationMatrix);
                            col2[0] = item.color1[0] * (1 - segmentFactor) + item.color2[0] * segmentFactor;
                            col2[1] = item.color1[1] * (1 - segmentFactor) + item.color2[1] * segmentFactor;
                            col2[2] = item.color1[2] * (1 - segmentFactor) + item.color2[2] * segmentFactor;
                            col2[3] = item.color1[3] * (1 - segmentFactor) + item.color2[3] * segmentFactor;
                            _math.vec3.add(pos1, dir1, item.intermediatePosition);
                            _math.vec3.add(pos2, dir2, item.intermediatePosition);
                            EveCurveLineSet.WriteLineVerticesToBuffer(this, pos1, col1, j / item.numOfSegments, pos2, col2, segmentFactor, i, data, offset);
                            offset += 6 * this._vertexSize;

                            tmp = dir1;
                            dir1 = dir2;
                            dir2 = tmp;
                            tmp = col1;
                            col1 = col2;
                            col2 = tmp;
                        }
                        break;

                    case EveCurveLineSetItem.Type.CURVED:
                        _math.vec3.subtract(tangent1, item.intermediatePosition, item.position1);
                        _math.vec3.subtract(tangent2, item.position2, item.intermediatePosition);
                        _math.vec3.copy(pos1, item.position1);
                        _math.vec3.copy(col1, item.color1);

                        for (var _j = 0; _j < item.numOfSegments; ++_j) {
                            var _segmentFactor = (_j + 1) / item.numOfSegments;
                            _math.vec3.hermite(pos2, item.position1, tangent1, item.position2, tangent2, _segmentFactor);
                            col2[0] = item.color1[0] * (1 - _segmentFactor) + item.color2[0] * _segmentFactor;
                            col2[1] = item.color1[1] * (1 - _segmentFactor) + item.color2[1] * _segmentFactor;
                            col2[2] = item.color1[2] * (1 - _segmentFactor) + item.color2[2] * _segmentFactor;
                            col2[3] = item.color1[3] * (1 - _segmentFactor) + item.color2[3] * _segmentFactor;
                            EveCurveLineSet.WriteLineVerticesToBuffer(this, pos1, col1, _j / item.numOfSegments, pos2, col2, _segmentFactor, i, data, offset);
                            offset += 6 * this._vertexSize;

                            tmp = pos1;
                            pos1 = pos2;
                            pos2 = tmp;
                            tmp = col1;
                            col1 = col2;
                            col2 = tmp;
                        }
                }
            }

            //if (this._vb) device.gl.deleteBuffer(this._vb);
            this._vb = _core.device.gl.createBuffer();
            _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._vb);
            _core.device.gl.bufferData(_core.device.gl.ARRAY_BUFFER, data, _core.device.gl.STATIC_DRAW);
            _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, null);
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator) {
            if (!this.display || !this._vb) return;

            var effect = void 0;
            switch (mode) {
                case _core.device.RM_TRANSPARENT:
                    if (this.additive || !this.lineEffect) return;
                    effect = this.lineEffect;
                    break;

                case _core.device.RM_ADDITIVE:
                    if (!this.additive || !this.lineEffect) return;
                    effect = this.lineEffect;
                    break;

                case _core.device.RM_PICKABLE:
                    if (!this.pickable || !this.pickEffect) return;
                    effect = this.pickEffect;
            }

            var batch = new _core.Tw2ForwardingRenderBatch(),
                worldTransform = EveCurveLineSet.global.mat4_0;

            _math.mat4.multiply(worldTransform, this.transform, this.parentTransform);
            _math.mat4.transpose(this._perObjectData.perObjectVSData.Get('WorldMat'), worldTransform);
            _math.mat4.transpose(this._perObjectData.perObjectPSData.Get('WorldMat'), worldTransform);
            batch.perObjectData = this._perObjectData;
            batch.geometryProvider = this;
            batch.renderMode = mode;
            batch.effect = effect;
            accumulator.Commit(batch);
        }

        /**
         * Per frame update
         * @param {Tw2ForwardingRenderBatch} batch
         * @param {string} technique - technique name
         * @returns {boolean}
         */

    }, {
        key: 'Render',
        value: function Render(batch, technique) {
            if (!batch.effect || !batch.effect.IsGood()) return false;

            _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._vb);

            var passCount = batch.effect.GetPassCount(technique);
            for (var pass = 0; pass < passCount; ++pass) {
                batch.effect.ApplyPass(technique, pass);
                var passInput = batch.effect.GetPassInput(technique, pass);
                if (!this._decl.SetDeclaration(passInput, this._decl.stride)) return false;
                _core.device.ApplyShadowState();
                _core.device.gl.drawArrays(_core.device.gl.TRIANGLES, 0, this._vbSize * 6);
            }
            return true;
        }

        /**
         * Fills color vertices
         * @param {EveCurveLineSetItem} item
         * @param buffer
         * @param {number} offset
         * @returns {number}
         */

    }, {
        key: 'lines',
        get: function get() {
            return this.items;
        }

        /**
         * Alias for this.items
         * @param {Array} arr
         */
        ,
        set: function set(arr) {
            this.items = arr;
        }

        /**
         * Gets the current line count
         * @returns {number}
         */

    }, {
        key: 'lineCount',
        get: function get() {
            var count = 0;
            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i].type !== EveCurveLineSetItem.Type.INVALID) {
                    count += this.items[i].numOfSegments;
                }
            }
            return count;
        }
    }], [{
        key: 'FillColorVertices',
        value: function FillColorVertices(item, buffer, offset) {
            buffer[offset++] = item.multiColor[0];
            buffer[offset++] = item.multiColor[1];
            buffer[offset++] = item.multiColor[2];
            buffer[offset++] = item.multiColor[3];
            buffer[offset++] = item.overlayColor[0];
            buffer[offset++] = item.overlayColor[1];
            buffer[offset++] = item.overlayColor[2];
            buffer[offset++] = item.overlayColor[3];
            return offset;
        }

        /**
         * Writes line vertices to the vertex buffer
         * @param {EveCurveLineSet} lineSet
         * @param {vec3} start
         * @param {quat} startColor
         * @param length1
         * @param {vec3} end
         * @param {quat} endColor
         * @param length2
         * @param {Number} lineID
         * @param buffer
         * @param {Number} offset
         */

    }, {
        key: 'WriteLineVerticesToBuffer',
        value: function WriteLineVerticesToBuffer(lineSet, start, startColor, length1, end, endColor, length2, lineID, buffer, offset) {
            var item = lineSet.items[lineID];

            buffer[offset++] = start[0];
            buffer[offset++] = start[1];
            buffer[offset++] = start[2];
            buffer[offset++] = end[0] - start[0];
            buffer[offset++] = end[1] - start[1];
            buffer[offset++] = end[2] - start[2];
            buffer[offset++] = -lineSet.lineWidthFactor * item.width;
            buffer[offset++] = 0;
            buffer[offset++] = length1;
            buffer[offset++] = item.multiColorBorder;
            buffer[offset++] = length2 - length1;
            buffer[offset++] = item.animationSpeed;
            buffer[offset++] = item.animationScale;
            buffer[offset++] = lineID;
            buffer[offset++] = startColor[0];
            buffer[offset++] = startColor[1];
            buffer[offset++] = startColor[2];
            buffer[offset++] = startColor[3];
            offset = EveCurveLineSet.FillColorVertices(item, buffer, offset);

            buffer[offset++] = start[0];
            buffer[offset++] = start[1];
            buffer[offset++] = start[2];
            buffer[offset++] = end[0] - start[0];
            buffer[offset++] = end[1] - start[1];
            buffer[offset++] = end[2] - start[2];
            buffer[offset++] = lineSet.lineWidthFactor * item.width;
            buffer[offset++] = 0;
            buffer[offset++] = length1;
            buffer[offset++] = item.multiColorBorder;
            buffer[offset++] = length2 - length1;
            buffer[offset++] = item.animationSpeed;
            buffer[offset++] = item.animationScale;
            buffer[offset++] = lineID;
            buffer[offset++] = startColor[0];
            buffer[offset++] = startColor[1];
            buffer[offset++] = startColor[2];
            buffer[offset++] = startColor[3];
            offset = EveCurveLineSet.FillColorVertices(item, buffer, offset);

            buffer[offset++] = end[0];
            buffer[offset++] = end[1];
            buffer[offset++] = end[2];
            buffer[offset++] = start[0] - end[0];
            buffer[offset++] = start[1] - end[1];
            buffer[offset++] = start[2] - end[2];
            buffer[offset++] = -lineSet.lineWidthFactor * item.width;
            buffer[offset++] = 1;
            buffer[offset++] = length2;
            buffer[offset++] = item.multiColorBorder;
            buffer[offset++] = length2 - length1;
            buffer[offset++] = item.animationSpeed;
            buffer[offset++] = item.animationScale;
            buffer[offset++] = lineID;
            buffer[offset++] = endColor[0];
            buffer[offset++] = endColor[1];
            buffer[offset++] = endColor[2];
            buffer[offset++] = endColor[3];
            offset = EveCurveLineSet.FillColorVertices(item, buffer, offset);

            buffer[offset++] = start[0];
            buffer[offset++] = start[1];
            buffer[offset++] = start[2];
            buffer[offset++] = end[0] - start[0];
            buffer[offset++] = end[1] - start[1];
            buffer[offset++] = end[2] - start[2];
            buffer[offset++] = lineSet.lineWidthFactor * item.width;
            buffer[offset++] = 0;
            buffer[offset++] = length1;
            buffer[offset++] = item.multiColorBorder;
            buffer[offset++] = length2 - length1;
            buffer[offset++] = item.animationSpeed;
            buffer[offset++] = item.animationScale;
            buffer[offset++] = lineID;
            buffer[offset++] = startColor[0];
            buffer[offset++] = startColor[1];
            buffer[offset++] = startColor[2];
            buffer[offset++] = startColor[3];
            offset = EveCurveLineSet.FillColorVertices(item, buffer, offset);

            buffer[offset++] = end[0];
            buffer[offset++] = end[1];
            buffer[offset++] = end[2];
            buffer[offset++] = start[0] - end[0];
            buffer[offset++] = start[1] - end[1];
            buffer[offset++] = start[2] - end[2];
            buffer[offset++] = lineSet.lineWidthFactor * item.width;
            buffer[offset++] = 1;
            buffer[offset++] = length2;
            buffer[offset++] = item.multiColorBorder;
            buffer[offset++] = length2 - length1;
            buffer[offset++] = item.animationSpeed;
            buffer[offset++] = item.animationScale;
            buffer[offset++] = lineID;
            buffer[offset++] = endColor[0];
            buffer[offset++] = endColor[1];
            buffer[offset++] = endColor[2];
            buffer[offset++] = endColor[3];
            offset = EveCurveLineSet.FillColorVertices(item, buffer, offset);

            buffer[offset++] = end[0];
            buffer[offset++] = end[1];
            buffer[offset++] = end[2];
            buffer[offset++] = start[0] - end[0];
            buffer[offset++] = start[1] - end[1];
            buffer[offset++] = start[2] - end[2];
            buffer[offset++] = -lineSet.lineWidthFactor * item.width;
            buffer[offset++] = 1;
            buffer[offset++] = length2;
            buffer[offset++] = item.multiColorBorder;
            buffer[offset++] = length2 - length1;
            buffer[offset++] = item.animationSpeed;
            buffer[offset++] = item.animationScale;
            buffer[offset++] = lineID;
            buffer[offset++] = endColor[0];
            buffer[offset++] = endColor[1];
            buffer[offset++] = endColor[2];
            buffer[offset++] = endColor[3];
            EveCurveLineSet.FillColorVertices(item, buffer, offset);
        }

        /**
         * Initializes class global variables and scratch
         */

    }, {
        key: 'init',
        value: function init() {
            if (!EveCurveLineSet.global) {
                EveCurveLineSet.global = {
                    vec3_0: _math.vec3.create(), // start direction
                    vec3_1: _math.vec3.create(), // end direction
                    vec3_2: _math.vec3.create(), // start direction normalized
                    vec3_3: _math.vec3.create(), // end direction normalized
                    vec3_4: _math.vec3.create(), // rotationAxis
                    vec3_5: _math.vec3.create(), // direction1
                    vec3_6: _math.vec3.create(), // direction2
                    vec3_7: _math.vec3.create(), // position 1
                    vec3_8: _math.vec3.create(), // position 2
                    vec3_9: _math.vec3.create(), // tangent1
                    vec3_10: _math.vec3.create(), // tangent2
                    vec4_0: _math.vec4.create(), // color 1
                    vec4_1: _math.vec4.create(), // color 2
                    mat4_0: _math.mat4.create() // rotationMatrix
                };
            }
        }
    }]);

    return EveCurveLineSet;
}(_EveObjectSet2.EveObjectSet);

/**
 * Class global variables and scratch
 */


EveCurveLineSet.global = null;

/**
 * Line set item constructor
 * @type {EveCurveLineSetItem}
 */
EveCurveLineSet.Item = EveCurveLineSetItem;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveLocator = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _index = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Contains transform information for T3 Attachments, Boosters, Turrets and XLTurrets
 *
 * @property {string} name                  - The locator's name
 * @property {mat4} transform               - The locator's transform
 * @property {?number} atlasIndex0          - A booster locator's atlasIndex0
 * @property {?number} atlasIndex1          - A booster locator's atlasIndex1
 * @property {?Tw2Bone} bone                - A turret locator's bone
 */
var EveLocator = exports.EveLocator = function () {
    function EveLocator() {
        _classCallCheck(this, EveLocator);

        this.name = '';
        this.transform = _index.mat4.create();
        this.atlasIndex0 = null;
        this.atlasIndex1 = null;
        this.bone = null;
    }

    /**
     * Gets the locator's bone from an animation controller
     * @param {Tw2AnimationController} animationController
     * @returns {?Tw2Bone}
     */


    _createClass(EveLocator, [{
        key: 'FindBone',
        value: function FindBone(animationController) {
            this.bone = null;
            var model = animationController.FindModelForMesh(0);
            if (model) {
                for (var i = 0; i < model.bones.length; ++i) {
                    if (model.bones[i].boneRes.name === this.name) {
                        this.bone = model.bones[i];
                        break;
                    }
                }
            }
            return this.bone;
        }
    }]);

    return EveLocator;
}();

/**
 * Locator name prefixes
 * @type {{AUDIO: string, ATTACH: string, BOOSTER: string, TURRET: string, XL_TURRET: string}}
 */


EveLocator.Prefix = {
    AUDIO: 'locator_audio',
    ATTACH: 'locator_attach',
    BOOSTER: 'locator_booster',
    TURRET: 'locator_turret',
    XL_TURRET: 'locator_xl'
};

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EvePlaneSet = exports.EvePlaneSetItem = exports.EvePlaneSetBatch = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveObjectSet2 = __webpack_require__(10);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Plane set render batch
 *
 * @property {EvePlaneSet} planeSet
 * @class
 */
var EvePlaneSetBatch = exports.EvePlaneSetBatch = function (_Tw2RenderBatch) {
    _inherits(EvePlaneSetBatch, _Tw2RenderBatch);

    function EvePlaneSetBatch() {
        _classCallCheck(this, EvePlaneSetBatch);

        var _this = _possibleConstructorReturn(this, (EvePlaneSetBatch.__proto__ || Object.getPrototypeOf(EvePlaneSetBatch)).call(this));

        _this.planeSet = null;
        return _this;
    }

    /**
     * Commits the plan set
     * @param {string} technique - technique name
     */


    _createClass(EvePlaneSetBatch, [{
        key: 'Commit',
        value: function Commit(technique) {
            this.planeSet.Render(technique);
        }
    }]);

    return EvePlaneSetBatch;
}(_core.Tw2RenderBatch);

/**
 * EvePlaneSetItem
 *
 * @property {number} boneIndex
 * @property {number} groupIndex
 * @property {number} maskAtlasID
 * @property {vec3} position
 * @property {vec3} scaling
 * @property {quat} rotation
 * @property {vec4} color
 * @property {vec4} layer1Transform
 * @property {vec4} layer2Transform
 * @property {vec4} layer1Scroll
 * @property {vec4} layer2Scroll
 * @class
 */


var EvePlaneSetItem = exports.EvePlaneSetItem = function (_EveObjectSetItem) {
    _inherits(EvePlaneSetItem, _EveObjectSetItem);

    function EvePlaneSetItem() {
        _classCallCheck(this, EvePlaneSetItem);

        var _this2 = _possibleConstructorReturn(this, (EvePlaneSetItem.__proto__ || Object.getPrototypeOf(EvePlaneSetItem)).call(this));

        _this2.boneIndex = 0;
        _this2.groupIndex = -1;
        _this2.maskAtlasID = 0;
        _this2.position = _math.vec3.create();
        _this2.scaling = _math.vec3.fromValues(1, 1, 1);
        _this2.rotation = _math.quat.create();
        _this2.transform = _math.mat4.create();
        _this2.color = _math.vec4.fromValues(1, 1, 1, 1);
        _this2.layer1Transform = _math.vec4.fromValues(1, 1, 0, 0);
        _this2.layer2Transform = _math.vec4.fromValues(1, 1, 0, 0);
        _this2.layer1Scroll = _math.vec4.create();
        _this2.layer2Scroll = _math.vec4.create();
        return _this2;
    }

    /**
     * Creates a plane set item from an object
     * @param {*} opt
     * @returns {EvePlaneSetItem}
     */


    _createClass(EvePlaneSetItem, null, [{
        key: 'create',
        value: function create() {
            var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var item = new this();
            _math.util.assignIfExists(item, opt, ['name', 'display', 'boneIndex', 'groupIndex', 'maskAtlasID', 'position', 'scaling', 'rotation', 'transform', 'color', 'layer1Transform', 'layer2Transform', 'layer1Scroll', 'layer2Scroll']);
            return item;
        }
    }]);

    return EvePlaneSetItem;
}(_EveObjectSet2.EveObjectSetItem);

/**
 * EvePlaneSet
 *
 * @property {String} name
 * @property {Array.<EvePlaneSetItem>} planes
 * @property {Tw2Effect} effect
 * @property {boolean} display
 * @property {boolean} hideOnLowQuality
 * @property {number} _time
 * @property {WebGLBuffer} _vertexBuffer
 * @property {WebGLBuffer} _indexBuffer
 * @property {Tw2VertexDeclaration} _decl
 * @class
 */


var EvePlaneSet = exports.EvePlaneSet = function (_EveObjectSet) {
    _inherits(EvePlaneSet, _EveObjectSet);

    function EvePlaneSet() {
        _classCallCheck(this, EvePlaneSet);

        var _this3 = _possibleConstructorReturn(this, (EvePlaneSet.__proto__ || Object.getPrototypeOf(EvePlaneSet)).call(this));

        _this3.effect = null;
        _this3.hideOnLowQuality = false;
        _this3._time = 0;
        _this3._vertexBuffer = null;
        _this3._indexBuffer = null;

        _this3._decl = new _core.Tw2VertexDeclaration();
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 0, _core.device.gl.FLOAT, 4, 0));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 4, 16));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 2, _core.device.gl.FLOAT, 4, 32));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 0, _core.device.gl.FLOAT, 4, 48));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 3, _core.device.gl.FLOAT, 4, 64));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 4, _core.device.gl.FLOAT, 4, 80));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 5, _core.device.gl.FLOAT, 4, 96));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 6, _core.device.gl.FLOAT, 4, 112));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 7, _core.device.gl.FLOAT, 3, 128));
        _this3._decl.RebuildHash();
        return _this3;
    }

    /**
     * Alias for this.items
     * @returns {Array}
     */


    _createClass(EvePlaneSet, [{
        key: 'GetResources',


        /**
         * Gets plane set res objects
         * @param {Array} [out=[]] - Optional receiving array
         * @returns {Array} {Array.<Tw2Resource>} [out]
         */
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.effect) {
                this.effect.GetResources(out);
            }
            return out;
        }

        /**
         * Per frame update
         * @param {number} dt - Delta Time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            this._time += dt;

            if (this._rebuildPending) {
                this.Rebuild();
            }
        }

        /**
         * Unloads the set's buffers
         */

    }, {
        key: 'Unload',
        value: function Unload() {
            if (this._vertexBuffer) {
                _core.device.gl.deleteBuffer(this._vertexBuffer);
                this._vertexBuffer = null;
            }

            if (this._indexBuffer) {
                _core.device.gl.deleteBuffer(this._indexBuffer);
                this._indexBuffer = null;
            }
        }

        /**
         * Rebuilds the plane set's buffers
         */

    }, {
        key: 'Rebuild',
        value: function Rebuild() {
            this.Unload();
            EvePlaneSet.RebuildItems(this);
            this._rebuildPending = false;
            var itemCount = this._visibleItems.length;
            if (!itemCount) return;

            var vertexSize = 35,
                mat4_0 = EvePlaneSet.global.mat4_0;

            var array = new Float32Array(itemCount * 4 * vertexSize);
            for (var i = 0; i < itemCount; ++i) {
                var item = this._visibleItems[i],
                    offset = i * 4 * vertexSize;

                array[offset + vertexSize - 3] = 0;
                array[offset + vertexSize + vertexSize - 3] = 1;
                array[offset + 2 * vertexSize + vertexSize - 3] = 2;
                array[offset + 3 * vertexSize + vertexSize - 3] = 3;

                var itemTransform = _math.mat4.fromRotationTranslationScale(mat4_0, item.rotation, item.position, item.scaling);

                for (var j = 0; j < 4; ++j) {
                    var vtxOffset = offset + j * vertexSize;
                    array[vtxOffset] = itemTransform[0];
                    array[vtxOffset + 1] = itemTransform[4];
                    array[vtxOffset + 2] = itemTransform[8];
                    array[vtxOffset + 3] = itemTransform[12];
                    array[vtxOffset + 4] = itemTransform[1];
                    array[vtxOffset + 5] = itemTransform[5];
                    array[vtxOffset + 6] = itemTransform[9];
                    array[vtxOffset + 7] = itemTransform[13];
                    array[vtxOffset + 8] = itemTransform[2];
                    array[vtxOffset + 9] = itemTransform[6];
                    array[vtxOffset + 10] = itemTransform[10];
                    array[vtxOffset + 11] = itemTransform[14];

                    array[vtxOffset + 12] = item.color[0];
                    array[vtxOffset + 13] = item.color[1];
                    array[vtxOffset + 14] = item.color[2];
                    array[vtxOffset + 15] = item.color[3];

                    array[vtxOffset + 16] = item.layer1Transform[0];
                    array[vtxOffset + 17] = item.layer1Transform[1];
                    array[vtxOffset + 18] = item.layer1Transform[2];
                    array[vtxOffset + 19] = item.layer1Transform[3];

                    array[vtxOffset + 20] = item.layer2Transform[0];
                    array[vtxOffset + 21] = item.layer2Transform[1];
                    array[vtxOffset + 22] = item.layer2Transform[2];
                    array[vtxOffset + 23] = item.layer2Transform[3];

                    array[vtxOffset + 24] = item.layer1Scroll[0];
                    array[vtxOffset + 25] = item.layer1Scroll[1];
                    array[vtxOffset + 26] = item.layer1Scroll[2];
                    array[vtxOffset + 27] = item.layer1Scroll[3];

                    array[vtxOffset + 28] = item.layer2Scroll[0];
                    array[vtxOffset + 29] = item.layer2Scroll[1];
                    array[vtxOffset + 30] = item.layer2Scroll[2];
                    array[vtxOffset + 31] = item.layer2Scroll[3];

                    array[vtxOffset + 33] = item.boneIndex;
                    array[vtxOffset + 34] = item.maskAtlasID;
                }
            }

            this._vertexBuffer = _core.device.gl.createBuffer();
            _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._vertexBuffer);
            _core.device.gl.bufferData(_core.device.gl.ARRAY_BUFFER, array, _core.device.gl.STATIC_DRAW);
            _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, null);

            var indexes = new Uint16Array(itemCount * 6);
            for (var _i = 0; _i < itemCount; ++_i) {
                var _offset = _i * 6,
                    _vtxOffset = _i * 4;

                indexes[_offset] = _vtxOffset;
                indexes[_offset + 1] = _vtxOffset + 2;
                indexes[_offset + 2] = _vtxOffset + 1;
                indexes[_offset + 3] = _vtxOffset;
                indexes[_offset + 4] = _vtxOffset + 3;
                indexes[_offset + 5] = _vtxOffset + 2;
            }

            this._indexBuffer = _core.device.gl.createBuffer();
            _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            _core.device.gl.bufferData(_core.device.gl.ELEMENT_ARRAY_BUFFER, indexes, _core.device.gl.STATIC_DRAW);
            _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, null);
            this._indexBuffer.count = itemCount * 6;
        }

        /**
         * Gets the plane set's render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (this.display && mode === _core.device.RM_ADDITIVE && this._indexBuffer && this._visibleItems.length) {
                var batch = new EvePlaneSetBatch();
                batch.renderMode = _core.device.RM_ADDITIVE;
                batch.planeSet = this;
                batch.perObjectData = perObjectData;
                accumulator.Commit(batch);
            }
        }

        /**
         * Renders the plane set
         * @param {string} technique - technique name
         */

    }, {
        key: 'Render',
        value: function Render(technique) {
            if (!this.effect || !this.effect.IsGood()) return false;

            _core.device.SetStandardStates(_core.device.RM_ADDITIVE);
            _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._vertexBuffer);
            _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);

            for (var pass = 0; pass < this.effect.GetPassCount(technique); ++pass) {
                this.effect.ApplyPass(technique, pass);
                if (!this._decl.SetDeclaration(this.effect.GetPassInput(technique, pass), 140)) return false;
                _core.device.ApplyShadowState();
                _core.device.gl.drawElements(_core.device.gl.TRIANGLES, this._indexBuffer.count, _core.device.gl.UNSIGNED_SHORT, 0);
            }
            return true;
        }
    }, {
        key: 'planes',
        get: function get() {
            return this.items;
        }

        /**
         * Alias for this.items
         * @param {Array} arr
         */
        ,
        set: function set(arr) {
            this.items = arr;
        }
    }]);

    return EvePlaneSet;
}(_EveObjectSet2.EveObjectSet);

/**
 * The plane set's item constructor
 * @type {EvePlaneSetItem}
 */


EvePlaneSet.Item = EvePlaneSetItem;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveSpaceObjectDecal = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EveSpaceObjectDecal
 *
 * @property {String|number} _id
 * @property {String} name
 * @property {boolean} display
 * @property {Tw2Effect} decalEffect
 * @property {Tw2Effect} pickEffect
 * @property {Tw2GeometryRes} parentGeometry
 * @property {number} parentBoneIndex
 * @property {number} groupIndex
 * @property {boolean} pickable
 * @property {vec3} position
 * @property {quat} rotation
 * @property {vec3} scaling
 * @property {mat4} decalMatrix
 * @property {mat4} invDecalMatrix
 * @property {Array} indexBuffer
 * @property {*} _indexBuffer
 * @property {Tw2PerObjectData} _perObjectData
 * @class
 */
var EveSpaceObjectDecal = exports.EveSpaceObjectDecal = function () {
    function EveSpaceObjectDecal() {
        _classCallCheck(this, EveSpaceObjectDecal);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.decalEffect = null;
        this.pickEffect = null;
        this.parentGeometry = null;
        this.parentBoneIndex = -1;
        this.groupIndex = -1;
        this.pickable = true;
        this.position = _math.vec3.create();
        this.rotation = _math.quat.create();
        this.scaling = _math.vec3.create();
        this.decalMatrix = _math.mat4.create();
        this.invDecalMatrix = _math.mat4.create();
        this.indexBuffer = [];
        this._indexBuffer = null;

        this._perObjectData = new _core.Tw2PerObjectData();
        this._perObjectData.perObjectVSData = new _core.Tw2RawData();
        this._perObjectData.perObjectVSData.Declare('worldMatrix', 16);
        this._perObjectData.perObjectVSData.Declare('invWorldMatrix', 16);
        this._perObjectData.perObjectVSData.Declare('decalMatrix', 16);
        this._perObjectData.perObjectVSData.Declare('invDecalMatrix', 16);
        this._perObjectData.perObjectVSData.Declare('parentBoneMatrix', 16);
        this._perObjectData.perObjectVSData.Create();

        this._perObjectData.perObjectPSData = new _core.Tw2RawData();
        this._perObjectData.perObjectPSData.Declare('displayData', 4);
        this._perObjectData.perObjectPSData.Declare('shipData', 4 * 3);
        this._perObjectData.perObjectPSData.Create();

        _math.mat4.identity(this._perObjectData.perObjectVSData.Get('parentBoneMatrix'));
    }

    /**
     * Initializes the decal
     */


    _createClass(EveSpaceObjectDecal, [{
        key: 'Initialize',
        value: function Initialize() {
            this.SetIndexBuffer(this.indexBuffer);
        }

        /**
         * Fire on value changes
         */

    }, {
        key: 'OnValueChanged',
        value: function OnValueChanged() {
            if (!this._indexBuffer && this.indexBuffer) {
                var indexes = new Uint16Array(this.indexBuffer);
                this._indexBuffer = _core.device.gl.createBuffer();
                _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
                _core.device.gl.bufferData(_core.device.gl.ELEMENT_ARRAY_BUFFER, indexes, _core.device.gl.STATIC_DRAW);
            }

            _math.mat4.fromRotationTranslationScale(this.decalMatrix, this.rotation, this.position, this.scaling);
            _math.mat4.invert(this.invDecalMatrix, this.decalMatrix);
        }

        /**
         * Sets the parent geometry
         * @param {Tw2GeometryRes} geometryRes
         */

    }, {
        key: 'SetParentGeometry',
        value: function SetParentGeometry(geometryRes) {
            this.parentGeometry = geometryRes;
        }

        /**
         * Sets the decal's index buffer
         * @param {number[]} indices
         */

    }, {
        key: 'SetIndexBuffer',
        value: function SetIndexBuffer(indices) {
            this.indexBuffer = indices;
            this.Unload();
            this.OnValueChanged();
        }

        /**
         * Gets decal resources
         * @param {Array} [out=[]] - Optional receiving array
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.parentGeometry && !out.includes(this.parentGeometry)) {
                out.push(this.parentGeometry);
            }

            if (this.decalEffect) this.decalEffect.GetResources(out);
            if (this.pickEffect) this.pickEffect.GetResources(out);
            return out;
        }

        /**
         * Unloads the decal's buffers
         */

    }, {
        key: 'Unload',
        value: function Unload() {
            if (this._indexBuffer) {
                _core.device.gl.deleteBuffer(this._indexBuffer);
                this._indexBuffer = null;
            }
        }

        /**
         * Gets batches for rendering
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         * @param {number} [counter=0]
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData, counter) {
            var effect = void 0;
            switch (mode) {
                case _core.device.RM_DECAL:
                    effect = this.decalEffect;
                    break;

                case _core.device.RM_PICKABLE:
                    effect = this.pickable ? this.pickEffect : null;
                    break;
            }

            if (this.display && effect && effect.IsGood() && this.indexBuffer.length && this.parentGeometry && this.parentGeometry.IsGood()) {
                var batch = new _core.Tw2ForwardingRenderBatch();
                this._perObjectData.perObjectVSData.Set('worldMatrix', perObjectData.perObjectVSData.Get('WorldMat'));
                if (this.parentBoneIndex >= 0) {
                    var bones = perObjectData.perObjectVSData.Get('JointMat'),
                        offset = this.parentBoneIndex * 12;

                    if (bones[offset] || bones[offset + 4] || bones[offset + 8]) {
                        var bone = this._perObjectData.perObjectVSData.Get('parentBoneMatrix');
                        bone[0] = bones[offset];
                        bone[1] = bones[offset + 4];
                        bone[2] = bones[offset + 8];
                        bone[3] = 0;
                        bone[4] = bones[offset + 1];
                        bone[5] = bones[offset + 5];
                        bone[6] = bones[offset + 9];
                        bone[7] = 0;
                        bone[8] = bones[offset + 2];
                        bone[9] = bones[offset + 6];
                        bone[10] = bones[offset + 10];
                        bone[11] = 0;
                        bone[12] = bones[offset + 3];
                        bone[13] = bones[offset + 7];
                        bone[14] = bones[offset + 11];
                        bone[15] = 1;
                        _math.mat4.transpose(bone, bone);
                    }
                }

                _math.mat4.invert(this._perObjectData.perObjectVSData.Get('invWorldMatrix'), this._perObjectData.perObjectVSData.Get('worldMatrix'));
                _math.mat4.transpose(this._perObjectData.perObjectVSData.Get('decalMatrix'), this.decalMatrix);
                _math.mat4.transpose(this._perObjectData.perObjectVSData.Get('invDecalMatrix'), this.invDecalMatrix);

                this._perObjectData.perObjectPSData.Get('displayData')[0] = counter || 0;
                this._perObjectData.perObjectPSData.Set('shipData', perObjectData.perObjectPSData.data);

                batch.perObjectData = this._perObjectData;
                batch.geometryProvider = this;
                batch.renderMode = mode;
                batch.effect = effect;
                accumulator.Commit(batch);
            }
        }

        /**
         * Renders the decal
         * @param {Tw2ForwardingRenderBatch} batch
         * @param {string} technique - technique name
         */

    }, {
        key: 'Render',
        value: function Render(batch, technique) {
            var bkIB = this.parentGeometry.meshes[0].indexes,
                bkStart = this.parentGeometry.meshes[0].areas[0].start,
                bkCount = this.parentGeometry.meshes[0].areas[0].count,
                bkIndexType = this.parentGeometry.meshes[0].indexType;

            _core.store.SetVariableValue('u_DecalMatrix', this.decalMatrix);
            _core.store.SetVariableValue('u_InvDecalMatrix', this.invDecalMatrix);

            this.parentGeometry.meshes[0].indexes = this._indexBuffer;
            this.parentGeometry.meshes[0].areas[0].start = 0;
            this.parentGeometry.meshes[0].areas[0].count = this.indexBuffer.length;
            this.parentGeometry.meshes[0].indexType = _core.device.gl.UNSIGNED_SHORT;

            this.parentGeometry.RenderAreas(0, 0, 1, batch.effect, technique);
            this.parentGeometry.meshes[0].indexes = bkIB;
            this.parentGeometry.meshes[0].areas[0].start = bkStart;
            this.parentGeometry.meshes[0].areas[0].count = bkCount;
            this.parentGeometry.meshes[0].indexType = bkIndexType;
        }
    }]);

    return EveSpaceObjectDecal;
}();

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveSpotlightSet = exports.EveSpotlightSetItem = exports.EveSpotlightSetBatch = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveObjectSet2 = __webpack_require__(10);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EveSpotlightSetBatch
 *
 * @property {EveSpotlightSet} spotlightSet
 * @class
 */
var EveSpotlightSetBatch = exports.EveSpotlightSetBatch = function (_Tw2RenderBatch) {
    _inherits(EveSpotlightSetBatch, _Tw2RenderBatch);

    function EveSpotlightSetBatch() {
        _classCallCheck(this, EveSpotlightSetBatch);

        var _this = _possibleConstructorReturn(this, (EveSpotlightSetBatch.__proto__ || Object.getPrototypeOf(EveSpotlightSetBatch)).call(this));

        _this.spotlightSet = null;
        return _this;
    }

    /**
     * Commits the spotlight set for rendering
     * @param {string} technique - technique name
     */


    _createClass(EveSpotlightSetBatch, [{
        key: 'Commit',
        value: function Commit(technique) {
            this.spotlightSet.RenderCones(technique);
            this.spotlightSet.RenderGlow(technique);
        }
    }]);

    return EveSpotlightSetBatch;
}(_core.Tw2RenderBatch);

/**
 * Spotlight Item
 *
 * @property {mat4} transform               - The spotlight's transform
 * @property {vec4} coneColor               - Colour of the spotlight's cone
 * @property {vec4} spriteColor             - Colour of the spotlight's sprite texture
 * @property {vec4} flareColor              - Colour of the spotlight's flare
 * @property {vec4} spriteScale             - The size of the spotlight
 * @property {number} boosterGainInfluence  - If true, the spotlight can change size on booster gain
 * @property {number} boneIndex             - The spotlight's bone index
 * @property {number} groupIndex            - The sof faction group that the spotlight belongs to
 * @property {number} coneIntensity         - Scales the spotlight's cone colour, set by an object's sof Faction
 * @property {number} spriteIntensity       - Scales the spotlight's sprite colour, set by an object's sof Faction
 * @property {number} flareIntensity        - Scales the spotlight's flare colour, set by an object's sof Faction
 * @class
 */


var EveSpotlightSetItem = exports.EveSpotlightSetItem = function (_EveObjectSetItem) {
    _inherits(EveSpotlightSetItem, _EveObjectSetItem);

    function EveSpotlightSetItem() {
        _classCallCheck(this, EveSpotlightSetItem);

        var _this2 = _possibleConstructorReturn(this, (EveSpotlightSetItem.__proto__ || Object.getPrototypeOf(EveSpotlightSetItem)).call(this));

        _this2.transform = _math.mat4.create();
        _this2.coneColor = _math.vec4.create();
        _this2.spriteColor = _math.vec4.create();
        _this2.flareColor = _math.vec4.create();
        _this2.spriteScale = _math.vec3.fromValues(1, 1, 1);
        _this2.boosterGainInfluence = 0;
        _this2.boneIndex = 0;
        _this2.groupIndex = -1;
        _this2.coneIntensity = 0;
        _this2.spriteIntensity = 0;
        _this2.flareIntensity = 0;
        return _this2;
    }

    /**
     * Creates a spotlight set item from an object
     * @param {*} [opt={}
     * @returns {EveSpotlightSetItem}
     */


    _createClass(EveSpotlightSetItem, null, [{
        key: 'create',
        value: function create() {
            var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var item = new this();
            _math.util.assignIfExists(item, opt, ['name', 'display', 'boosterGainInfluence', 'boneIndex', 'groupIndex', 'coneIntensity', 'spriteIntensity', 'flareIntensity', 'transform', 'coneColor', 'spriteColor', 'flareColor', 'spriteScale']);
            return item;
        }
    }]);

    return EveSpotlightSetItem;
}(_EveObjectSet2.EveObjectSetItem);

/**
 * EveSpotlightSet
 *
 * @property {string} name                               - The spotlight set's name
 * @property {boolean} display                           - controls the visibility of the spotlight set, and all it's children
 * @property {Tw2Effect} coneEffect                      - The spotlight set's cone effect
 * @property {Tw2Effect} glowEffect                      - The spotlight set's glow effect
 * @property {Array.<EveSpotlightSetItem) spotlightItems - The spotlight set's children
 * @property {WebGLBuffer} _coneVertexBuffer             - Webgl buffer for the spotlight set's cone vertices
 * @property {WebGLBuffer} _spriteVertexBuffer           - Webgl buffer for the spotlight set's sprite/glow vertices
 * @property {WebGLBuffer} _indexBuffer                  - Webgl buffer for the spotlight set
 * @property {Tw2VertexDeclaration} _decl                - The spotlight set's vertex declarations
 * @class
 */


var EveSpotlightSet = exports.EveSpotlightSet = function (_EveObjectSet) {
    _inherits(EveSpotlightSet, _EveObjectSet);

    function EveSpotlightSet() {
        _classCallCheck(this, EveSpotlightSet);

        var _this3 = _possibleConstructorReturn(this, (EveSpotlightSet.__proto__ || Object.getPrototypeOf(EveSpotlightSet)).call(this));

        _this3.coneEffect = null;
        _this3.glowEffect = null;
        _this3._coneVertexBuffer = null;
        _this3._spriteVertexBuffer = null;
        _this3._indexBuffer = null;

        _this3._decl = new _core.Tw2VertexDeclaration();
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 0, _core.device.gl.FLOAT, 4, 0));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 0, _core.device.gl.FLOAT, 4, 16));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 4, 32));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 2, _core.device.gl.FLOAT, 4, 48));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 3, _core.device.gl.FLOAT, 3, 64));
        _this3._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 4, _core.device.gl.FLOAT, 3, 76));
        _this3._decl.RebuildHash();

        return _this3;
    }

    /**
     * Alias for this.items
     * @returns {Array}
     */


    _createClass(EveSpotlightSet, [{
        key: 'GetResources',


        /**
         * Gets the spotlight set's resources
         * @param {Array} [out=[]] - Optional receiving array
         * @returns {Array.<Tw2Resource>} [out]
         */
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.coneEffect) {
                this.coneEffect.GetResources(out);
            }

            if (this.glowEffect) {
                this.glowEffect.GetResources(out);
            }

            return out;
        }

        /**
         * Unloads the spotlight set's buffers
         */

    }, {
        key: 'Unload',
        value: function Unload() {
            if (this._coneVertexBuffer) {
                _core.device.gl.deleteBuffer(this._coneVertexBuffer);
                this._coneVertexBuffer = null;
            }

            if (this._spriteVertexBuffer) {
                _core.device.gl.deleteBuffer(this._spriteVertexBuffer);
                this._spriteVertexBuffer = null;
            }

            if (this._indexBuffer) {
                _core.device.gl.deleteBuffer(this._indexBuffer);
                this._indexBuffer = null;
            }
        }

        /**
         * Rebuilds the spotlight set's buffers
         */

    }, {
        key: 'Rebuild',
        value: function Rebuild() {
            this.Unload();
            EveSpotlightSet.RebuildItems(this);
            this._rebuildPending = false;
            var itemCount = this._visibleItems.length;
            if (!itemCount) return;

            var d = _core.device,
                vertCount = 4,
                coneQuadCount = 4,
                coneVertexCount = itemCount * coneQuadCount * vertCount,
                vertexSize = 22,
                coneIndices = [1, 0, 2, 3],
                coneArray = new Float32Array(coneVertexCount * vertexSize);

            for (var i = 0; i < itemCount; ++i) {
                var item = this._visibleItems[i];
                for (var q = 0; q < coneQuadCount; ++q) {
                    for (var v = 0; v < vertCount; ++v) {
                        var offset = (i * coneQuadCount * vertCount + vertCount * q + v) * vertexSize;
                        coneArray[offset] = item.coneColor[0] * item.coneIntensity;
                        coneArray[offset + 1] = item.coneColor[1] * item.coneIntensity;
                        coneArray[offset + 2] = item.coneColor[2] * item.coneIntensity;
                        coneArray[offset + 3] = item.coneColor[3];

                        coneArray[offset + 4] = item.transform[0];
                        coneArray[offset + 5] = item.transform[4];
                        coneArray[offset + 6] = item.transform[8];
                        coneArray[offset + 7] = item.transform[12];

                        coneArray[offset + 8] = item.transform[1];
                        coneArray[offset + 9] = item.transform[5];
                        coneArray[offset + 10] = item.transform[9];
                        coneArray[offset + 11] = item.transform[13];

                        coneArray[offset + 12] = item.transform[2];
                        coneArray[offset + 13] = item.transform[6];
                        coneArray[offset + 14] = item.transform[10];
                        coneArray[offset + 15] = item.transform[14];

                        coneArray[offset + 16] = 1;
                        coneArray[offset + 17] = 1;
                        coneArray[offset + 18] = 1;

                        coneArray[offset + 19] = q * vertCount + coneIndices[v];
                        coneArray[offset + 20] = item.boneIndex;
                        coneArray[offset + 21] = item.boosterGainInfluence ? 255 : 0;
                    }
                }
            }

            this._coneVertexBuffer = d.gl.createBuffer();
            d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._coneVertexBuffer);
            d.gl.bufferData(d.gl.ARRAY_BUFFER, coneArray, d.gl.STATIC_DRAW);
            this._coneVertexBuffer.count = itemCount * coneQuadCount * 6;

            var spriteQuadCount = 2,
                spriteVertexCount = itemCount * spriteQuadCount * vertCount,
                spriteArray = new Float32Array(spriteVertexCount * vertexSize),
                spriteIndexes = [1, 0, 2, 3];

            for (var _i = 0; _i < itemCount; ++_i) {
                var _item = this._visibleItems[_i];
                for (var _q = 0; _q < spriteQuadCount; ++_q) {
                    for (var _v = 0; _v < vertCount; ++_v) {
                        var _offset = (_i * spriteQuadCount * vertCount + vertCount * _q + _v) * vertexSize;
                        if (_q % 2 === 0) {
                            spriteArray[_offset] = _item.spriteColor[0] * _item.spriteIntensity;
                            spriteArray[_offset + 1] = _item.spriteColor[1] * _item.spriteIntensity;
                            spriteArray[_offset + 2] = _item.spriteColor[2] * _item.spriteIntensity;
                            spriteArray[_offset + 3] = _item.spriteColor[3];

                            spriteArray[_offset + 16] = _item.spriteScale[0];
                            spriteArray[_offset + 17] = 1;
                            spriteArray[_offset + 18] = 1;
                        } else {
                            spriteArray[_offset] = _item.flareColor[0] * _item.flareIntensity;
                            spriteArray[_offset + 1] = _item.flareColor[1] * _item.flareIntensity;
                            spriteArray[_offset + 2] = _item.flareColor[2] * _item.flareIntensity;
                            spriteArray[_offset + 3] = _item.flareColor[3];

                            spriteArray[_offset + 16] = 1;
                            spriteArray[_offset + 17] = _item.spriteScale[1];
                            spriteArray[_offset + 18] = _item.spriteScale[2];
                        }

                        spriteArray[_offset + 4] = _item.transform[0];
                        spriteArray[_offset + 5] = _item.transform[4];
                        spriteArray[_offset + 6] = _item.transform[8];
                        spriteArray[_offset + 7] = _item.transform[12];

                        spriteArray[_offset + 8] = _item.transform[1];
                        spriteArray[_offset + 9] = _item.transform[5];
                        spriteArray[_offset + 10] = _item.transform[9];
                        spriteArray[_offset + 11] = _item.transform[13];

                        spriteArray[_offset + 12] = _item.transform[2];
                        spriteArray[_offset + 13] = _item.transform[6];
                        spriteArray[_offset + 14] = _item.transform[10];
                        spriteArray[_offset + 15] = _item.transform[14];

                        spriteArray[_offset + 19] = _q * vertCount + spriteIndexes[_v];
                        spriteArray[_offset + 20] = _item.boneIndex;
                        spriteArray[_offset + 21] = _item.boosterGainInfluence ? 255 : 0;
                    }
                }
            }

            this._spriteVertexBuffer = d.gl.createBuffer();
            d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._spriteVertexBuffer);
            d.gl.bufferData(d.gl.ARRAY_BUFFER, spriteArray, d.gl.STATIC_DRAW);
            this._spriteVertexBuffer.count = itemCount * spriteQuadCount * 6;

            var indexes = new Uint16Array(itemCount * coneQuadCount * 6);
            for (var _i2 = 0; _i2 < itemCount * coneQuadCount; ++_i2) {
                var _offset2 = _i2 * 6,
                    vtxOffset = _i2 * 4;

                indexes[_offset2] = vtxOffset;
                indexes[_offset2 + 1] = vtxOffset + 1;
                indexes[_offset2 + 2] = vtxOffset + 2;
                indexes[_offset2 + 3] = vtxOffset + 2;
                indexes[_offset2 + 4] = vtxOffset + 3;
                indexes[_offset2 + 5] = vtxOffset;
            }

            this._indexBuffer = d.gl.createBuffer();
            d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            d.gl.bufferData(d.gl.ELEMENT_ARRAY_BUFFER, indexes, d.gl.STATIC_DRAW);
            d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, null);
            this._indexBuffer.count = itemCount;
        }

        /**
         * Gets the spotlight set's render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData) {
            if (this.display && mode === _core.device.RM_ADDITIVE && this._indexBuffer && this._indexBuffer.count) {
                var batch = new EveSpotlightSetBatch();
                batch.renderMode = _core.device.RM_ADDITIVE;
                batch.spotlightSet = this;
                batch.perObjectData = perObjectData;
                accumulator.Commit(batch);
            }
        }

        /**
         * Renders the spotlight set's cone effect
         * @param {string} technique - technique name
         * @returns {boolean}
         */

    }, {
        key: 'RenderCones',
        value: function RenderCones(technique) {
            return EveSpotlightSet.Render(this, this.coneEffect, technique, this._coneVertexBuffer);
        }

        /**
         * Renders the spotlight set's glow effect
         * @param {string} technique - technique name
         * @returns {boolean}
         */

    }, {
        key: 'RenderGlow',
        value: function RenderGlow(technique) {
            return EveSpotlightSet.Render(this, this.glowEffect, technique, this._spriteVertexBuffer);
        }

        /**
         * Internal render function
         * @param {EveSpotlightSet} spotlightSet
         * @param {Tw2Effect} effect   - The Tw2Effect to render
         * @param {string} technique - technique name
         * @param {WebGLBuffer} buffer - A webgl buffer (ie. cone or glow buffer)
         * @returns {boolean}
         * @private
         */

    }, {
        key: 'spotlightItems',
        get: function get() {
            return this.items;
        }

        /**
         * Alias for this.items
         * @param {Array} arr
         */
        ,
        set: function set(arr) {
            this.items = arr;
        }
    }], [{
        key: 'Render',
        value: function Render(spotlightSet, effect, technique, buffer) {
            if (!effect || !effect.IsGood() || !buffer) return false;

            var stride = 22 * 4;
            _core.device.SetStandardStates(_core.device.RM_ADDITIVE);
            _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, buffer);
            _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, spotlightSet._indexBuffer);

            for (var pass = 0; pass < effect.GetPassCount(technique); ++pass) {
                effect.ApplyPass(technique, pass);
                if (!spotlightSet._decl.SetDeclaration(effect.GetPassInput(technique, pass), stride)) return false;
                _core.device.ApplyShadowState();
                _core.device.gl.drawElements(_core.device.gl.TRIANGLES, buffer['count'], _core.device.gl.UNSIGNED_SHORT, 0);
            }
            return true;
        }
    }]);

    return EveSpotlightSet;
}(_EveObjectSet2.EveObjectSet);

/**
 * Spotlight set item constructor
 * @type {EveSpotlightSetItem}
 */


EveSpotlightSet.Item = EveSpotlightSetItem;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveSpriteSet = exports.EveSpriteSetItem = exports.EveSpriteSetBatch = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveObjectSet2 = __webpack_require__(10);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Sprite set render batch
 *
 * @property {boolean} boosterGlow
 * @property {EveSpriteSet} spriteSet
 * @property {mat4} world
 * @property {number}
 * @property {number}
 * @class
 */
var EveSpriteSetBatch = exports.EveSpriteSetBatch = function (_Tw2RenderBatch) {
    _inherits(EveSpriteSetBatch, _Tw2RenderBatch);

    function EveSpriteSetBatch() {
        _classCallCheck(this, EveSpriteSetBatch);

        var _this = _possibleConstructorReturn(this, (EveSpriteSetBatch.__proto__ || Object.getPrototypeOf(EveSpriteSetBatch)).call(this));

        _this.boosterGlow = false;
        _this.spriteSet = null;
        _this.world = null;
        _this.boosterGain = 0;
        _this.warpIntensity = 0;
        return _this;
    }

    /**
     * Commits the sprite set
     * @param {string} technique - technique name
     */


    _createClass(EveSpriteSetBatch, [{
        key: 'Commit',
        value: function Commit(technique) {
            if (this.boosterGlow) {
                this.spriteSet.RenderBoosterGlow(technique, this.world, this.boosterGain, this.warpIntensity);
            } else {
                this.spriteSet.Render(technique, this.world, this.perObjectData);
            }
        }
    }]);

    return EveSpriteSetBatch;
}(_core.Tw2RenderBatch);

/**
 * EveSpriteSetItem
 *
 * @property {vec3} position
 * @property {number} blinkRate
 * @property {number} blinkPhase
 * @property {number} minScale
 * @property {number} maxScale
 * @property {number} falloff
 * @property {vec4} color
 * @property {vec4} warpColor
 * @property {number} boneIndex
 * @property {number} groupIndex
 * @class
 */


var EveSpriteSetItem = exports.EveSpriteSetItem = function (_EveObjectSetItem) {
    _inherits(EveSpriteSetItem, _EveObjectSetItem);

    function EveSpriteSetItem() {
        _classCallCheck(this, EveSpriteSetItem);

        var _this2 = _possibleConstructorReturn(this, (EveSpriteSetItem.__proto__ || Object.getPrototypeOf(EveSpriteSetItem)).call(this));

        _this2.position = _math.vec3.create();
        _this2.blinkRate = 0;
        _this2.blinkPhase = 0;
        _this2.minScale = 1;
        _this2.maxScale = 1;
        _this2.falloff = 0;
        _this2.color = _math.vec4.create();
        _this2.warpColor = _math.vec4.create();
        _this2.boneIndex = 0;
        _this2.groupIndex = -1;
        return _this2;
    }

    /**
     * Creates a sprite set item from an object
     * @param {*} [opt={}]
     * @returns {EveSpriteSetItem}
     */


    _createClass(EveSpriteSetItem, null, [{
        key: 'create',
        value: function create() {
            var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var item = new this();
            _math.util.assignIfExists(item, opt, ['name', 'display', 'blinkRate', 'blinkPhase', 'minScale', 'maxScale', 'falloff', 'boneIndex', 'groupIndex', 'position', 'color', 'warpColor']);
            return item;
        }
    }]);

    return EveSpriteSetItem;
}(_EveObjectSet2.EveObjectSetItem);

/**
 * EveSpriteSet
 *
 * @param {boolean} [useQuads] - Use quad rendering (CPU transform)
 * @param {boolean} [isSkinned] - Use bone transforms (when useQuads is true)
 * @property {Tw2Effect} effect
 * @property {?boolean} useQuads - Use quad rendering (CPU transform)
 * @property {?boolean} isSkinned - Use bone transforms (when useQuads is true)
 * @property {number} _time
 * @property {WebGLBuffer} _vertexBuffer
 * @property {WebGLBuffer} _indexBuffer
 * @property {Tw2VertexDeclaration} _decl
 */


var EveSpriteSet = exports.EveSpriteSet = function (_EveObjectSet) {
    _inherits(EveSpriteSet, _EveObjectSet);

    function EveSpriteSet() {
        var useQuads = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var isSkinned = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        _classCallCheck(this, EveSpriteSet);

        var _this3 = _possibleConstructorReturn(this, (EveSpriteSet.__proto__ || Object.getPrototypeOf(EveSpriteSet)).call(this));

        _this3.effect = null;
        _this3.useQuads = null;
        _this3.isSkinned = null;
        _this3._time = 0;
        _this3._vertexBuffer = null;
        _this3._indexBuffer = null;
        _this3._instanceBuffer = null;
        _this3._decl = _this3._decl = new _core.Tw2VertexDeclaration();
        _this3._vdecl = new _core.Tw2VertexDeclaration();
        _this3._vdecl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 5, _core.device.gl.FLOAT, 1, 0));
        _this3._vdecl.RebuildHash();

        _this3.UseQuads(useQuads, isSkinned);
        return _this3;
    }

    /**
     * Alias for this.items
     * @returns {Array}
     */


    _createClass(EveSpriteSet, [{
        key: 'UseQuads',


        /**
         * Use instanced rendering or 'quad' rendering
         * @param {boolean} useQuads      - Use quad rendering (CPU transform)
         * @param {boolean} isSkinned     - Use bone transforms (when useQuads is true)
         */
        value: function UseQuads(useQuads, isSkinned) {
            if (this.useQuads === useQuads) return;

            this.useQuads = useQuads;
            this.isSkinned = isSkinned;

            this._decl.elements.splice(0, this._decl.elements.length);
            if (!useQuads) {
                this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 5, _core.device.gl.FLOAT, 2, 0));
                this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.POSITION, 0, _core.device.gl.FLOAT, 3, 8));
                this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 0, _core.device.gl.FLOAT, 3, 20));
                this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 0, _core.device.gl.FLOAT, 1, 32));
                this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 1, 36));
                this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 2, _core.device.gl.FLOAT, 1, 40));
                this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 3, _core.device.gl.FLOAT, 1, 44));
                this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 4, _core.device.gl.FLOAT, 1, 48));
            } else {
                this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.POSITION, 0, _core.device.gl.FLOAT, 3, 0));
                this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 0, _core.device.gl.FLOAT, 4, 12));
                this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 2, 28));
                this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 0, _core.device.gl.FLOAT, 4, 36));
                this._decl.elements.push(new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.COLOR, 1, _core.device.gl.FLOAT, 4, 52));
            }

            this._decl.RebuildHash();
            this._rebuildPending = true;
        }

        /**
         * Gets Sprite Set Resource Objects
         * @param {Array} [out=[]] - Optional receiving array
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.effect) {
                this.effect.GetResources(out);
            }
            return out;
        }

        /**
         * Per frame update
         * @param {number} dt - Delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            this._time += dt;

            if (this._rebuildPending) {
                this.Rebuild();
            }
        }

        /**
         * Unloads the sprite set's buffers
         */

    }, {
        key: 'Unload',
        value: function Unload() {
            if (this._vertexBuffer) {
                _core.device.gl.deleteBuffer(this._vertexBuffer);
                this._vertexBuffer = null;
            }

            // Standard
            if (this._indexBuffer) {
                _core.device.gl.deleteBuffer(this._indexBuffer);
                this._indexBuffer = null;
            }

            // Quad
            if (this._instanceBuffer) {
                _core.device.gl.deleteBuffer(this._instanceBuffer);
                this._instanceBuffer = null;
            }
        }

        /**
         * Rebuilds the sprite set's buffers
         */

    }, {
        key: 'Rebuild',
        value: function Rebuild() {
            this.constructor.RebuildItems(this);
            this._rebuildPending = false;
            var itemCount = this._visibleItems.length;
            if (!itemCount) return;

            var d = _core.device;

            if (this.useQuads) {
                this._vertexBuffer = d.gl.createBuffer();
                d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._vertexBuffer);
                d.gl.bufferData(d.gl.ARRAY_BUFFER, new Float32Array([0, 1, 2, 2, 3, 0]), d.gl.STATIC_DRAW);
                d.gl.bindBuffer(d.gl.ARRAY_BUFFER, null);
                this._instanceBuffer = d.gl.createBuffer();
                return;
            }

            var vertexSize = 13,
                array = new Float32Array(itemCount * 4 * vertexSize);

            for (var i = 0; i < itemCount; ++i) {
                var item = this._visibleItems[i],
                    offset = i * 4 * vertexSize;

                array[offset] = 0;
                array[offset + vertexSize] = 1;
                array[offset + 2 * vertexSize] = 2;
                array[offset + 3 * vertexSize] = 3;

                for (var j = 0; j < 4; ++j) {
                    var vtxOffset = offset + j * vertexSize;
                    array[vtxOffset + 1] = item.boneIndex;
                    array[vtxOffset + 2] = item.position[0];
                    array[vtxOffset + 3] = item.position[1];
                    array[vtxOffset + 4] = item.position[2];
                    array[vtxOffset + 5] = item.color[0];
                    array[vtxOffset + 6] = item.color[1];
                    array[vtxOffset + 7] = item.color[2];
                    array[vtxOffset + 8] = item.blinkPhase;
                    array[vtxOffset + 9] = item.blinkRate;
                    array[vtxOffset + 10] = item.minScale;
                    array[vtxOffset + 11] = item.maxScale;
                    array[vtxOffset + 12] = item.falloff;
                }
            }

            this._vertexBuffer = d.gl.createBuffer();
            d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._vertexBuffer);
            d.gl.bufferData(d.gl.ARRAY_BUFFER, array, d.gl.STATIC_DRAW);
            d.gl.bindBuffer(d.gl.ARRAY_BUFFER, null);

            var indexes = new Uint16Array(itemCount * 6);
            for (var _i = 0; _i < itemCount; ++_i) {
                var _offset = _i * 6,
                    _vtxOffset = _i * 4;

                indexes[_offset] = _vtxOffset;
                indexes[_offset + 1] = _vtxOffset + 2;
                indexes[_offset + 2] = _vtxOffset + 1;
                indexes[_offset + 3] = _vtxOffset;
                indexes[_offset + 4] = _vtxOffset + 3;
                indexes[_offset + 5] = _vtxOffset + 2;
            }

            this._indexBuffer = d.gl.createBuffer();
            d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            d.gl.bufferData(d.gl.ELEMENT_ARRAY_BUFFER, indexes, d.gl.STATIC_DRAW);
            d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, null);
            this._indexBuffer.count = itemCount * 6;
        }

        /**
         * Gets render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         * @param {mat4} world
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData, world) {
            if (this.display && mode === _core.device.RM_ADDITIVE && this._vertexBuffer && this._visibleItems.length) {
                var batch = new EveSpriteSetBatch();
                batch.world = world;
                batch.renderMode = _core.device.RM_ADDITIVE;
                batch.spriteSet = this;
                batch.perObjectData = perObjectData;
                accumulator.Commit(batch);
            }
        }

        /**
         * Gets render batches for booster glows
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         * @param {mat4} world
         * @param {Number} boosterGain
         * @param {Number} warpIntensity
         */

    }, {
        key: 'GetBoosterGlowBatches',
        value: function GetBoosterGlowBatches(mode, accumulator, perObjectData, world, boosterGain, warpIntensity) {
            if (this.display && mode === _core.device.RM_ADDITIVE && this._vertexBuffer && this._visibleItems.length) {
                var batch = new EveSpriteSetBatch();
                batch.boosterGlow = true;
                batch.world = world;
                batch.boosterGain = boosterGain;
                batch.warpIntensity = warpIntensity;
                batch.renderMode = _core.device.RM_ADDITIVE;
                batch.spriteSet = this;
                batch.perObjectData = perObjectData;
                accumulator.Commit(batch);
            }
        }

        /**
         * Renders the sprite set
         * @param {string} technique - technique name
         * @param {mat4} world
         * @param {Tw2PerObjectData} perObjectData
         * @returns {boolean}
         */

    }, {
        key: 'Render',
        value: function Render(technique, world, perObjectData) {
            if (this.useQuads) {
                return this.RenderQuads(technique, world, perObjectData);
            }

            if (!this.effect || !this.effect.IsGood() || !this._indexBuffer) return false;

            _core.device.SetStandardStates(_core.device.RM_ADDITIVE);
            _core.device.gl.bindBuffer(_core.device.gl.ARRAY_BUFFER, this._vertexBuffer);
            _core.device.gl.bindBuffer(_core.device.gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);

            for (var pass = 0; pass < this.effect.GetPassCount(technique); ++pass) {
                this.effect.ApplyPass(technique, pass);
                if (!this._decl.SetDeclaration(this.effect.GetPassInput(technique, pass), 52)) return false;
                _core.device.ApplyShadowState();
                _core.device.gl.drawElements(_core.device.gl.TRIANGLES, this._indexBuffer.count, _core.device.gl.UNSIGNED_SHORT, 0);
            }
            return true;
        }

        /**
         * Renders the sprite set as booster glow
         * @param {string} technique - technique name
         * @param {mat4} world
         * @param {Number} boosterGain
         * @param {Number} warpIntensity
         * @returns {boolean}
         */

    }, {
        key: 'RenderBoosterGlow',
        value: function RenderBoosterGlow(technique, world, boosterGain, warpIntensity) {
            if (!this.effect || !this.effect.IsGood() || !this._instanceBuffer) return false;

            var d = _core.device,
                pos = _EveObjectSet2.EveObjectSet.global.vec3_0,
                itemCount = this._visibleItems.length,
                array = new Float32Array(17 * itemCount);

            d.SetStandardStates(d.RM_ADDITIVE);

            var index = 0;
            for (var i = 0; i < itemCount; ++i) {
                var item = this._visibleItems[i];
                _math.vec3.transformMat4(pos, item.position, world);
                array[index++] = pos[0];
                array[index++] = pos[1];
                array[index++] = pos[2];
                array[index++] = world[8];
                array[index++] = item.blinkPhase;
                array[index++] = world[9];
                array[index++] = item.minScale;
                array[index++] = item.maxScale;
                array[index++] = world[10];
                array[index++] = item.color[0];
                array[index++] = item.color[1];
                array[index++] = item.color[2];
                array[index++] = boosterGain;
                array[index++] = item.warpColor[0];
                array[index++] = item.warpColor[1];
                array[index++] = item.warpColor[2];
                array[index++] = warpIntensity;
            }

            d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._instanceBuffer);
            d.gl.bufferData(d.gl.ARRAY_BUFFER, array, d.gl.DYNAMIC_DRAW);

            for (var pass = 0; pass < this.effect.GetPassCount(technique); ++pass) {
                this.effect.ApplyPass(technique, pass);
                var passInput = this.effect.GetPassInput(technique, pass);
                d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._vertexBuffer);
                this._vdecl.SetPartialDeclaration(passInput, 4);
                d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._instanceBuffer);
                var resetData = this._decl.SetPartialDeclaration(passInput, 17 * 4, 0, 1);
                d.ApplyShadowState();
                d.ext.drawArraysInstanced(d.gl.TRIANGLES, 0, 6, itemCount);
                this._decl.ResetInstanceDivisors(resetData);
            }

            return true;
        }

        /**
         * Renders the sprite set with pre-transformed quads
         * @param {string} technique - technique name
         * @param {mat4} world
         * @param {Tw2PerObjectData} perObjectData
         * @returns {boolean}
         */

    }, {
        key: 'RenderQuads',
        value: function RenderQuads(technique, world, perObjectData) {
            if (!this.effect || !this.effect.IsGood() || !this._instanceBuffer) return false;

            var d = _core.device,
                itemCount = this._visibleItems.length,
                array = new Float32Array(17 * itemCount),
                pos = _EveObjectSet2.EveObjectSet.global.vec3_0,
                bones = perObjectData.perObjectVSData.Get('JointMat');

            d.SetStandardStates(d.RM_ADDITIVE);

            var index = 0;
            for (var i = 0; i < itemCount; ++i) {
                var item = this._visibleItems[i];
                if (this.isSkinned) {
                    var offset = item.boneIndex * 12;
                    pos[0] = bones[offset] * item.position[0] + bones[offset + 1] * item.position[1] + bones[offset + 2] * item.position[2] + bones[offset + 3];
                    pos[1] = bones[offset + 4] * item.position[0] + bones[offset + 5] * item.position[1] + bones[offset + 6] * item.position[2] + bones[offset + 7];
                    pos[2] = bones[offset + 8] * item.position[0] + bones[offset + 9] * item.position[1] + bones[offset + 10] * item.position[2] + bones[offset + 11];
                    _math.vec3.transformMat4(pos, pos, world);
                } else {
                    _math.vec3.transformMat4(pos, item.position, world);
                }

                array[index++] = pos[0];
                array[index++] = pos[1];
                array[index++] = pos[2];
                array[index++] = 1;
                array[index++] = item.blinkPhase;
                array[index++] = item.blinkRate;
                array[index++] = item.minScale;
                array[index++] = item.maxScale;
                array[index++] = item.falloff;
                array[index++] = item.color[0];
                array[index++] = item.color[1];
                array[index++] = item.color[2];
                array[index++] = 1;
                array[index++] = item.warpColor[0];
                array[index++] = item.warpColor[1];
                array[index++] = item.warpColor[2];
                array[index++] = 1;
            }

            d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._instanceBuffer);
            d.gl.bufferData(d.gl.ARRAY_BUFFER, array, d.gl.DYNAMIC_DRAW);

            for (var pass = 0; pass < this.effect.GetPassCount(technique); ++pass) {
                this.effect.ApplyPass(technique, pass);
                var passInput = this.effect.GetPassInput(technique, pass);
                d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._vertexBuffer);
                this._vdecl.SetPartialDeclaration(passInput, 4);
                d.gl.bindBuffer(d.gl.ARRAY_BUFFER, this._instanceBuffer);
                var resetData = this._decl.SetPartialDeclaration(passInput, 17 * 4, 0, 1);
                d.ApplyShadowState();
                d.ext.drawArraysInstanced(d.gl.TRIANGLES, 0, 6, itemCount);
                this._decl.ResetInstanceDivisors(resetData);
            }

            return true;
        }
    }, {
        key: 'sprites',
        get: function get() {
            return this.items;
        }

        /**
         * Alias for this.items
         * @param {Array} arr
         */
        ,
        set: function set(arr) {
            this.items = arr;
        }
    }]);

    return EveSpriteSet;
}(_EveObjectSet2.EveObjectSet);

/**
 * The sprite set's item constructor
 * @type {EveSpriteSetItem}
 */


EveSpriteSet.Item = EveSpriteSetItem;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveTurretSet = exports.EveTurretSetItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _EveObjectSet2 = __webpack_require__(10);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EveTurretSetItem
 *
 * @property {?Tw2Bone} bone                - The bone the turret is on
 * @property {boolean} isJoint              - Identifies if the turret is on a joint
 * @property {?string} locatorName          - The item's locator name
 * @property {boolean} updateFromLocator    - Allows the turret to be updated from a locator's transforms
 * @property {boolean} canFireWhenHidden    - Enables firing effects when hidden
 * @property {vec3} position                - The turret's position
 * @property {quat} rotation                - The turret's rotation
 * @property {mat4} _localTransform         - The turret's local transform
 * @property {quat} _localRotation          - the turret's local rotation
 */
var EveTurretSetItem = exports.EveTurretSetItem = function (_EveObjectSetItem) {
    _inherits(EveTurretSetItem, _EveObjectSetItem);

    function EveTurretSetItem() {
        _classCallCheck(this, EveTurretSetItem);

        var _this = _possibleConstructorReturn(this, (EveTurretSetItem.__proto__ || Object.getPrototypeOf(EveTurretSetItem)).call(this));

        _this.bone = null;
        _this.locatorName = null;
        _this.updateFromLocator = false;
        _this.canFireWhenHidden = false;
        _this.position = _math.vec3.create();
        _this.rotation = _math.quat.create();
        _this._localTransform = _math.mat4.create();
        _this._localRotation = _math.quat.create();
        return _this;
    }

    /**
     * Updates the turret's transforms
     */


    _createClass(EveTurretSetItem, [{
        key: 'UpdateTransforms',
        value: function UpdateTransforms() {
            _math.mat4.fromRotationTranslation(this._localTransform, this.rotation, this.position);

            if (this.bone) {
                _math.mat4.multiply(this._localTransform, this.bone.offsetTransform, this._localTransform);
                _math.mat4.getRotation(this._localRotation, this._localTransform);
            } else {
                _math.quat.copy(this._localRotation, this.rotation);
            }
        }

        /**
         * Creates a turret item from an object
         * @param {*} [opt={}]
         * @returns {EveTurretSetItem}
         */

    }], [{
        key: 'create',
        value: function create() {
            var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var item = new this();
            _math.util.assignIfExists(item, opt, ['name', 'display', 'locatorName', 'updateFromLocator', 'position', 'rotation', 'bone', 'canFireWhenHidden']);
            item.UpdateTransforms();
            return item;
        }
    }]);

    return EveTurretSetItem;
}(_EveObjectSet2.EveObjectSetItem);

/**
 * EveTurretSet
 *
 * @property {Array.<EveTurretSetItem>} turrets
 * @property {Tw2AnimationController} activeAnimation
 * @property {Tw2AnimationController} inactiveAnimation
 * @property {string} geometryResPath
 * @property {Tw2GeometryRes} geometryResource
 * @property {number} bottomClipHeight
 * @property {string} locatorName
 * @property {Tw2Effect} turretEffect
 * @property {vec3} targetPosition
 * @property {number} sysBoneHeight
 * @property {string} firingEffectResPath
 * @property {EveTurretFiringFX} firingEffect
 * @property {number} state
 * @property {boolean} hasCyclingFiringPos
 * @property {mat4} parentMatrix
 * @property {quat} boundingSphere
 * @property {number} _activeTurret
 * @property {number} _recheckTimeLeft
 * @property {number} _currentCyclingFiresPos
 * @property {Tw2PerObjectData} _perObjectDataActive
 * @property {Tw2PerObjectData} _perObjectDataInactive
 * @property {boolean} _locatorRebuildPending
 * @class
 */


var EveTurretSet = exports.EveTurretSet = function (_EveObjectSet) {
    _inherits(EveTurretSet, _EveObjectSet);

    function EveTurretSet() {
        _classCallCheck(this, EveTurretSet);

        var _this2 = _possibleConstructorReturn(this, (EveTurretSet.__proto__ || Object.getPrototypeOf(EveTurretSet)).call(this));

        _this2.visible = {};
        _this2.visible.turrets = true;
        _this2.visible.firingEffects = true;
        _this2.activeAnimation = new _core.Tw2AnimationController();
        _this2.inactiveAnimation = new _core.Tw2AnimationController();
        _this2.geometryResPath = '';
        _this2.geometryResource = null;
        _this2.turretEffect = null;
        _this2.firingEffectResPath = '';
        _this2.firingEffect = null;
        _this2.fireCallback = null;
        _this2.fireCallbackPending = false;
        _this2.state = EveTurretSet.State.IDLE;
        _this2.bottomClipHeight = 0;
        _this2.locatorName = '';
        _this2.sysBoneHeight = 0;
        _this2.hasCyclingFiringPos = false;
        _this2.targetPosition = _math.vec3.create();
        _this2.parentMatrix = _math.mat4.create();
        _this2.boundingSphere = _math.quat.create();
        _this2._activeTurret = -1;
        _this2._recheckTimeLeft = 0;
        _this2._currentCyclingFiresPos = 0;

        _this2._perObjectDataActive = new _core.Tw2PerObjectData();
        _this2._perObjectDataActive.perObjectVSData = new _core.Tw2RawData();
        _this2._perObjectDataActive.perObjectVSData.Declare('baseCutoffData', 4);
        _this2._perObjectDataActive.perObjectVSData.Declare('turretSetData', 4);
        _this2._perObjectDataActive.perObjectVSData.Declare('shipMatrix', 16);
        _this2._perObjectDataActive.perObjectVSData.Declare('turretTranslation', 4 * 24);
        _this2._perObjectDataActive.perObjectVSData.Declare('turretRotation', 4 * 24);
        _this2._perObjectDataActive.perObjectVSData.Declare('turretPoseTransAndRot', 2 * 4 * 72);
        _this2._perObjectDataActive.perObjectVSData.Create();

        _this2._perObjectDataInactive = new _core.Tw2PerObjectData();
        _this2._perObjectDataInactive.perObjectVSData = new _core.Tw2RawData();
        _this2._perObjectDataInactive.perObjectVSData.Declare('baseCutoffData', 4);
        _this2._perObjectDataInactive.perObjectVSData.Declare('turretSetData', 4);
        _this2._perObjectDataInactive.perObjectVSData.Declare('shipMatrix', 16);
        _this2._perObjectDataInactive.perObjectVSData.Declare('turretTranslation', 4 * 24);
        _this2._perObjectDataInactive.perObjectVSData.Declare('turretRotation', 4 * 24);
        _this2._perObjectDataInactive.perObjectVSData.Declare('turretPoseTransAndRot', 2 * 4 * 72);
        _this2._perObjectDataInactive.perObjectVSData.Create();

        _this2._locatorRebuildPending = true;
        return _this2;
    }

    /**
     * Alias for this.items
     * @returns {Array}
     */


    _createClass(EveTurretSet, [{
        key: 'Initialize',


        /**
         * Initializes the Turret Set
         */
        value: function Initialize() {
            var _this3 = this;

            if (this.turretEffect && this.geometryResPath !== '') {
                this.geometryResource = _core.resMan.GetResource(this.geometryResPath);
                this.activeAnimation.SetGeometryResource(this.geometryResource);
                this.inactiveAnimation.SetGeometryResource(this.geometryResource);
                if (this.geometryResource) this.geometryResource.RegisterNotification(this);
            }

            if (this.firingEffectResPath !== '') {
                _core.resMan.GetObject(this.firingEffectResPath, function (object) {
                    return _this3.firingEffect = object;
                });
            }

            this.Rebuild();
        }

        /**
         * Initializes turret set's firing effect
         */

    }, {
        key: 'InitializeFiringEffect',
        value: function InitializeFiringEffect() {
            if (!this.firingEffect) return;

            if (this.geometryResource && this.geometryResource.models.length) {
                var model = this.geometryResource.models[0];
                for (var i = 0; i < this.firingEffect.GetPerMuzzleEffectCount(); ++i) {
                    this.firingEffect.SetMuzzleBoneID(i, model.FindBoneByName(EveTurretSet.positionBoneSkeletonNames[i]));
                }
            }
        }

        /**
         * Helper function for finding out what turret should be firing
         * @returns {number}
         */

    }, {
        key: 'GetClosestTurret',
        value: function GetClosestTurret() {
            var closestTurret = -1,
                closestAngle = -2;

            var g = EveTurretSet.global,
                nrmToTarget = g.vec3_0,
                nrmUp = g.vec4_0,
                turretPosition = g.vec4_1;

            for (var i = 0; i < this.items.length; ++i) {
                var item = this.items[i];
                if (!item.display && !item.canFireWhenHidden) continue;

                turretPosition[0] = item._localTransform[12];
                turretPosition[1] = item._localTransform[13];
                turretPosition[2] = item._localTransform[14];
                turretPosition[3] = 1;
                _math.vec4.transformMat4(turretPosition, turretPosition, this.parentMatrix);
                _math.vec3.subtract(nrmToTarget, this.targetPosition, turretPosition);
                _math.vec3.normalize(nrmToTarget, nrmToTarget);
                _math.vec4.set(nrmUp, 0, 1, 0, 0);
                _math.vec4.transformMat4(nrmUp, nrmUp, item._localTransform);
                _math.vec4.transformMat4(nrmUp, nrmUp, this.parentMatrix);
                var angle = _math.vec3.dot(nrmUp, nrmToTarget);
                if (angle > closestAngle) {
                    closestTurret = this.items.indexOf(item);
                    closestAngle = angle;
                }
            }

            return closestTurret;
        }

        /**
         * Animation helper function for deactivating a turret set
         */

    }, {
        key: 'EnterStateDeactive',
        value: function EnterStateDeactive() {
            var _this4 = this;

            if (this.state === EveTurretSet.State.INACTIVE || this.state === EveTurretSet.State.PACKING) return;

            if (this.turretEffect) {
                this.activeAnimation.StopAllAnimations();
                this.inactiveAnimation.StopAllAnimations();

                this.activeAnimation.PlayAnimation('Pack', false, function () {
                    _this4.state = EveTurretSet.State.INACTIVE;
                    _this4.activeAnimation.PlayAnimation('Inactive', true);
                });

                this.inactiveAnimation.PlayAnimation('Pack', false, function () {
                    _this4.state = EveTurretSet.State.INACTIVE;
                    _this4.inactiveAnimation.PlayAnimation('Inactive', true);
                });

                this.state = EveTurretSet.State.PACKING;
            } else {
                this.state = EveTurretSet.State.INACTIVE;
            }

            this._activeTurret = -1;

            if (this.firingEffect) {
                this.firingEffect.StopFiring();
            }
        }

        /**
         * Animation helper function for putting a turret set into idle state
         */

    }, {
        key: 'EnterStateIdle',
        value: function EnterStateIdle() {
            var _this5 = this;

            if (this.state === EveTurretSet.State.IDLE || this.state === EveTurretSet.State.UNPACKING) return;

            if (this.turretEffect) {
                this.activeAnimation.StopAllAnimations();
                this.inactiveAnimation.StopAllAnimations();

                if (this.state === EveTurretSet.State.FIRING) {
                    this.activeAnimation.PlayAnimation('Active', true);
                    this.inactiveAnimation.PlayAnimation('Active', true);
                } else {
                    this.activeAnimation.PlayAnimation('Deploy', false, function () {
                        _this5.state = EveTurretSet.State.IDLE;
                        _this5.activeAnimation.PlayAnimation('Active', true);
                    });

                    this.inactiveAnimation.PlayAnimation('Deploy', false, function () {
                        _this5.state = EveTurretSet.State.IDLE;
                        _this5.inactiveAnimation.PlayAnimation('Active', true);
                    });
                }

                this.state = EveTurretSet.State.UNPACKING;
            } else {
                this.state = EveTurretSet.State.IDLE;
            }

            this._activeTurret = -1;

            if (this.firingEffect) {
                this.firingEffect.StopFiring();
            }
        }

        /**
         * Animation helper function for putting a turret set into a firing state
         */

    }, {
        key: 'EnterStateFiring',
        value: function EnterStateFiring() {
            var _this6 = this;

            if (!this.turretEffect || this.state === EveTurretSet.State.FIRING) {
                EveTurretSet.DoStartFiring(this);
                if (this.turretEffect) {
                    this.activeAnimation.PlayAnimation('Fire', false, function () {
                        _this6.activeAnimation.PlayAnimation('Active', true);
                    });
                }
                return;
            }

            this.activeAnimation.StopAllAnimations();
            this.inactiveAnimation.StopAllAnimations();
            if (this.state === EveTurretSet.State.INACTIVE) {
                this.activeAnimation.PlayAnimation('Deploy', false, function () {
                    EveTurretSet.DoStartFiring(_this6);
                    _this6.activeAnimation.PlayAnimation('Fire', false, function () {
                        _this6.activeAnimation.PlayAnimation('Active', true);
                    });
                });

                this.inactiveAnimation.PlayAnimation('Deploy', false, function () {
                    _this6.inactiveAnimation.PlayAnimation('Active', true);
                });
                this.state = EveTurretSet.State.UNPACKING;
            } else {
                EveTurretSet.DoStartFiring(this);
                this.activeAnimation.PlayAnimation('Fire', false, function () {
                    _this6.activeAnimation.PlayAnimation('Active', true);
                });

                this.inactiveAnimation.PlayAnimation('Active', true);
            }
        }

        /**
         * Rebuilds the turret sets cached data
         */

    }, {
        key: 'RebuildCachedData',
        value: function RebuildCachedData() {
            var instancedElement = new _core.Tw2VertexElement(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1, _core.device.gl.FLOAT, 2),
                meshes = this.geometryResource.meshes,
                active = this.activeAnimation,
                inactive = this.inactiveAnimation;

            for (var i = 0; i < meshes.length; ++i) {
                meshes[i].declaration.elements.push(instancedElement);
                meshes[i].declaration.RebuildHash();
            }

            switch (this.state) {
                case EveTurretSet.State.INACTIVE:
                    active.PlayAnimation('Inactive', true);
                    inactive.PlayAnimation('Inactive', true);
                    break;

                case EveTurretSet.State.IDLE:
                    active.PlayAnimation('Active', true);
                    inactive.PlayAnimation('Active', true);
                    break;

                case EveTurretSet.State.FIRING:
                    active.PlayAnimation('Fire', false, function () {
                        return active.PlayAnimation('Active', true);
                    });
                    inactive.PlayAnimation('Active', true);
                    break;

                case EveTurretSet.State.PACKING:
                    this.EnterStateIdle();
                    break;

                case EveTurretSet.State.UNPACKING:
                    this.EnterStateDeactive();
                    break;
            }
        }

        /**
         * Finds a turret item by name
         * @param {string} name
         * @returns {?EveTurretSetItem}
         */

    }, {
        key: 'FindItemByLocatorName',
        value: function FindItemByLocatorName(name) {
            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i].locatorName === name) {
                    return this.items[i];
                }
            }
            return null;
        }

        /**
         * Updates the turret set's items that were created from locators
         * - Turrets without locator names are ignored
         * @param {Array<EveLocator>} locators
         */

    }, {
        key: 'UpdateItemsFromLocators',
        value: function UpdateItemsFromLocators(locators) {
            var g = EveTurretSet.global,
                toRemove = Array.from(this.items),
                norm = g.mat4_0;

            for (var i = 0; i < locators.length; i++) {
                var _locators$i = locators[i],
                    name = _locators$i.name,
                    transform = _locators$i.transform,
                    _locators$i$bone = _locators$i.bone,
                    bone = _locators$i$bone === undefined ? null : _locators$i$bone;


                var item = this.FindItemByLocatorName(name);
                if (!item) {
                    item = this.CreateItem({
                        name: name,
                        locatorName: name,
                        updateFromLocator: true
                    });
                } else {
                    toRemove.splice(toRemove.indexOf(item), 1);
                }

                if (item.updateFromLocator) {
                    item.bone = bone;
                    _math.mat4.copy(norm, transform);
                    _math.vec3.normalize(norm.subarray(0, 3), norm.subarray(0, 3));
                    _math.vec3.normalize(norm.subarray(4, 7), norm.subarray(4, 7));
                    _math.vec3.normalize(norm.subarray(8, 11), norm.subarray(8, 11));
                    _math.mat4.getRotation(item.rotation, norm);
                    _math.mat4.getTranslation(item.position, norm);
                    item.OnValueChanged();
                }
            }

            for (var _i = 0; _i < toRemove.length; _i++) {
                if (toRemove[_i].locatorName) {
                    this.RemoveItem(toRemove[_i]);
                    _i--;
                }
            }

            this._locatorRebuildPending = false;
            if (this._rebuildPending) this.Rebuild();
        }

        /**
         * Rebuilds the turret set's items from it's parent's locators
         */

    }, {
        key: 'RebuildItemsFromLocators',
        value: function RebuildItemsFromLocators() {
            this._locatorRebuildPending = true;
        }

        /**
         * Gets turret set res objects
         * @param {Array} [out=[]] - Optional receiving array
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

            if (this.geometryResource && !out.includes(this.geometryResource)) {
                out.push(this.geometryResource);
            }

            if (this.turretEffect) {
                this.turretEffect.GetResources(out);
            }

            if (this.firingEffect) {
                this.firingEffect.GetResources(out);
            }

            return out;
        }

        /**
         * Updates view dependent data
         */

    }, {
        key: 'UpdateViewDependentData',
        value: function UpdateViewDependentData() {
            if (this.firingEffect) {
                this.firingEffect.UpdateViewDependentData();
            }
        }

        /**
         * Per frame update
         * @param {number} dt - Delta Time
         * @param {mat4} parentMatrix
         */

    }, {
        key: 'Update',
        value: function Update(dt, parentMatrix) {
            if (this._rebuildPending) {
                this.Rebuild();
            }

            if (this.turretEffect) {
                this.activeAnimation.Update(dt);
                this.inactiveAnimation.Update(dt);
            }

            _math.mat4.copy(this.parentMatrix, parentMatrix);

            if (this.firingEffect && this._visibleItems.length) {
                if (this._activeTurret !== -1) {
                    if (this.firingEffect.isLoopFiring) {
                        if (this.state === EveTurretSet.State.FIRING) {
                            this._recheckTimeLeft -= dt;
                            if (this._recheckTimeLeft <= 0) {
                                EveTurretSet.DoStartFiring(this);
                            }
                        }
                    }

                    var activeItem = this.items[this._activeTurret];

                    if (this.activeAnimation.models.length) {
                        var bones = this.activeAnimation.models[0].bonesByName;
                        for (var i = 0; i < this.firingEffect.GetPerMuzzleEffectCount(); ++i) {
                            var transform = bones[EveTurretSet.positionBoneSkeletonNames[i]].worldTransform,
                                out = this.firingEffect.GetMuzzleTransform(i);

                            _math.mat4.multiply(out, activeItem._localTransform, transform);
                            _math.mat4.multiply(out, out, parentMatrix);
                        }
                    } else {
                        for (var _i2 = 0; _i2 < this.firingEffect.GetPerMuzzleEffectCount(); ++_i2) {
                            _math.mat4.multiply(this.firingEffect.GetMuzzleTransform(_i2), parentMatrix, activeItem._localTransform);
                        }
                    }

                    if (this.fireCallbackPending) {
                        if (this.fireCallback) {
                            var cbTransforms = [];
                            for (var _i3 = 0; _i3 < this.firingEffect.GetPerMuzzleEffectCount(); ++_i3) {
                                cbTransforms.push(this.firingEffect.GetMuzzleTransform(_i3));
                            }
                            this.fireCallback(this, cbTransforms);
                        }
                        this.fireCallbackPending = false;
                    }
                }

                _math.vec3.copy(this.firingEffect.endPosition, this.targetPosition);
                this.firingEffect.Update(dt);
            }
        }

        /**
         * Gets turret set render batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         * @param {boolean} [hideFiringEffect]
         */

    }, {
        key: 'GetBatches',
        value: function GetBatches(mode, accumulator, perObjectData, hideFiringEffect) {
            if (!this.turretEffect || !this.geometryResource || !this.display || !this._visibleItems.length) return;

            if (mode === _core.device.RM_OPAQUE && this.visible.turrets) {
                var transforms = this.inactiveAnimation.GetBoneMatrices(0);
                if (transforms.length !== 0) {
                    EveTurretSet.UpdatePerObjectData(this, this._perObjectDataInactive.perObjectVSData, transforms);
                    this._perObjectDataInactive.perObjectPSData = perObjectData.perObjectPSData;

                    var batch = new _core.Tw2ForwardingRenderBatch();
                    batch.renderMode = mode;
                    batch.renderActive = false;
                    batch.perObjectData = this._perObjectDataInactive;
                    batch.geometryProvider = this;
                    accumulator.Commit(batch);

                    if (this.state === EveTurretSet.State.FIRING) {
                        var _transforms = this.activeAnimation.GetBoneMatrices(0);
                        if (_transforms.length !== 0) {
                            EveTurretSet.UpdatePerObjectData(this, this._perObjectDataActive.perObjectVSData, _transforms, true);
                            this._perObjectDataActive.perObjectPSData = perObjectData.perObjectPSData;

                            var _batch = new _core.Tw2ForwardingRenderBatch();
                            _batch.renderActive = true;
                            _batch.perObjectData = this._perObjectDataActive;
                            _batch.geometryProvider = this;
                            accumulator.Commit(_batch);
                        }
                    }
                }
            }

            this.GetFiringEffectBatches(mode, accumulator, perObjectData, hideFiringEffect);
        }

        /**
         * Gets turret firing effect batches
         * @param {number} mode
         * @param {Tw2BatchAccumulator} accumulator
         * @param {Tw2PerObjectData} perObjectData
         * @param {boolean} [hideFiringEffect]
         */

    }, {
        key: 'GetFiringEffectBatches',
        value: function GetFiringEffectBatches(mode, accumulator, perObjectData, hideFiringEffect) {
            if (this.firingEffect && this.display && this._visibleItems.length && this.visible.firingEffects && !hideFiringEffect) {
                this.firingEffect.GetBatches(mode, accumulator, perObjectData);
            }
        }

        /**
         * Renders the turret set
         * @param batch
         * @param {string} technique - technique name
         * @returns {boolean}
         */

    }, {
        key: 'Render',
        value: function Render(batch, technique) {
            if (!this.turretEffect || !this.turretEffect.IsGood() || !this._visibleItems.length) return false;

            var index = 0;
            var customSetter = function customSetter(el) {
                _core.device.gl.disableVertexAttribArray(el.location);
                _core.device.gl.vertexAttrib2f(el.location, index, index);
            };

            for (var i = 0; i < this.geometryResource.meshes.length; ++i) {
                var decl = this.geometryResource.meshes[i].declaration;
                decl.FindUsage(_core.Tw2VertexDeclaration.Type.TEXCOORD, 1).customSetter = customSetter;
            }

            var rendered = 0;
            for (; index < this.items.length; ++index) {
                if (this.items[index].display) {
                    var isActive = this.state === EveTurretSet.State.FIRING && index === this._activeTurret;
                    if (batch.renderActive === isActive) {
                        this.geometryResource.RenderAreas(0, 0, 1, this.turretEffect, technique);
                        rendered++;
                    }
                }
            }

            return !!rendered;
        }

        /**
         * Rebuilds the set's items
         *
         * @param {EveTurretSet} turretSet
         */

    }, {
        key: 'turrets',
        get: function get() {
            return this.items;
        }

        /**
         * Alias for this.items
         * @param {Array} arr
         */
        ,
        set: function set(arr) {
            this.items = arr;
        }
    }], [{
        key: 'RebuildItems',
        value: function RebuildItems(turretSet) {
            turretSet._visibleItems = [];

            for (var i = 0; i < turretSet.items.length; i++) {
                var item = turretSet.items[i];
                item._onModified = turretSet._onChildModified;

                if (item.display) {
                    turretSet._visibleItems.push(item);
                    if (item._rebuildPending) {
                        item.UpdateTransforms();
                        item._rebuildPending = false;
                    }
                }
            }
        }

        /**
         * Updates per object data
         * @param {EveTurretSet} turretSet
         * @param {Tw2RawData} perObjectData
         * @param transforms
         * @param {boolean} [skipBoneCalculations]
         */

    }, {
        key: 'UpdatePerObjectData',
        value: function UpdatePerObjectData(turretSet, perObjectData, transforms, skipBoneCalculations) {
            _math.mat4.transpose(perObjectData.Get('shipMatrix'), turretSet.parentMatrix);
            var transformCount = transforms.length / 12;
            perObjectData.Get('turretSetData')[0] = transformCount;
            perObjectData.Get('baseCutoffData')[0] = turretSet.bottomClipHeight;

            var translation = perObjectData.Get('turretTranslation'),
                rotation = perObjectData.Get('turretRotation'),
                pose = perObjectData.Get('turretPoseTransAndRot');

            for (var i = 0; i < turretSet._visibleItems.length; ++i) {
                var item = turretSet._visibleItems[i];

                for (var j = 0; j < transformCount; ++j) {
                    pose[(i * transformCount + j) * 2 * 4] = transforms[j * 12 + 3];
                    pose[(i * transformCount + j) * 2 * 4 + 1] = transforms[j * 12 + 7];
                    pose[(i * transformCount + j) * 2 * 4 + 2] = transforms[j * 12 + 11];
                    pose[(i * transformCount + j) * 2 * 4 + 3] = 1;
                    EveTurretSet.mat3x4toquat(transforms, j, pose, (i * transformCount + j) * 2 + 1);
                }

                if (item.bone && !skipBoneCalculations) {
                    item.UpdateTransforms();
                }

                translation[i * 4] = item._localTransform[12];
                translation[i * 4 + 1] = item._localTransform[13];
                translation[i * 4 + 2] = item._localTransform[14];
                translation[i * 4 + 3] = 1;

                rotation[i * 4] = item.rotation[0];
                rotation[i * 4 + 1] = item.rotation[1];
                rotation[i * 4 + 2] = item.rotation[2];
                rotation[i * 4 + 3] = item.rotation[3];
            }
        }

        /**
         * Animation helper function for turret firing
         * @param {EveTurretSet} turretSet
         * @returns {EveTurretSetItem} the closest turret
         */

    }, {
        key: 'DoStartFiring',
        value: function DoStartFiring(turretSet) {
            if (turretSet.hasCyclingFiringPos) {
                turretSet._currentCyclingFiresPos = 1 - turretSet._currentCyclingFiresPos;
            }

            if (turretSet.firingEffect) {
                turretSet.firingEffect.PrepareFiring(0, turretSet.hasCyclingFiringPos ? turretSet._currentCyclingFiresPos : -1);
            }

            turretSet._activeTurret = turretSet.GetClosestTurret();
            turretSet.state = EveTurretSet.State.FIRING;
            turretSet._recheckTimeLeft = 2;

            if (turretSet.fireCallback) {
                turretSet.fireCallbackPending = true;
            }
        }
    }]);

    return EveTurretSet;
}(_EveObjectSet2.EveObjectSet);

/**
 * mat3x4 to quat
 */


EveTurretSet.mat3x4toquat = function () {
    var m = void 0,
        q = void 0;

    return function mat3x4toquat(mm, index, out, outIndex) {
        if (!m) {
            m = _math.mat4.create();
            q = _math.quat.create();
        }

        index *= 12;
        outIndex *= 4;

        m[0] = mm[index];
        m[1] = mm[index + 4];
        m[2] = mm[index + 8];
        m[3] = 0;
        m[4] = mm[index + 1];
        m[5] = mm[index + 5];
        m[6] = mm[index + 9];
        m[7] = 0;
        m[8] = mm[index + 2];
        m[9] = mm[index + 6];
        m[10] = mm[index + 10];
        m[11] = 0;
        m[12] = mm[index + 3];
        m[13] = mm[index + 7];
        m[14] = mm[index + 11];
        m[15] = 1;

        _math.mat4.getRotation(q, m);
        out[outIndex] = q[0];
        out[outIndex + 1] = q[1];
        out[outIndex + 2] = q[2];
        out[outIndex + 3] = q[3];
    };
}();

/**
 * The eve turret set's item constructor
 * @type {EveTurretSetItem}
 */
EveTurretSet.Item = EveTurretSetItem;

/**
 * Turret states
 * @type {{INACTIVE: number, IDLE: number, FIRING: number, PACKING: number, UNPACKING: number}}
 */
EveTurretSet.State = {
    INACTIVE: 0,
    IDLE: 1,
    FIRING: 2,
    PACKING: 2,
    UNPACKING: 4
};

/**
 * World turret bone names
 * @type {string[]}
 */
EveTurretSet.worldNames = ['turretWorld0', 'turretWorld1', 'turretWorld2'];

/**
 * Bone Skeleton Names
 * @type {string[]}
 */
EveTurretSet.positionBoneSkeletonNames = ['Pos_Fire01', 'Pos_Fire02', 'Pos_Fire03', 'Pos_Fire04', 'Pos_Fire05', 'Pos_Fire06', 'Pos_Fire07', 'Pos_Fire08'];

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveSpaceScene = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * EveSpaceScene
 *
 * @property {number|string} _id
 * @property {string} name
 * @property {boolean} display
 * @property {{}} visible
 * @property {boolean} visible.lensflare
 * @property {boolean} visible.objects
 * @property {boolean} visible.planets
 * @property {boolean} visible.fog
 * @property {boolean} visible.clearColor
 * @property {boolean} visible.nebula
 * @property {Array.<EveLensflare>} lensflares - Scene lensflares
 * @property {Array.<*>} objects - Scene objects
 * @property {Array.<EvePlanet>} planets - Scene planets
 * @property {number} nebulaIntensity - controls nebula intensity on scene objects
 * @property {vec4} ambientColor - unused
 * @property {null|Tw2Effect} backgroundEffect
 * @property {number} backgroundRenderingEnabled - Toggles background effect visibility
 * @property {vec3} endMapScaling - controls the scale of the environment maps
 * @property {quat} envMapRotation - controls the rotation of the environment maps
 * @property {boolean} logEnabled - toggles LOD
 * @property {number} fogStart - fog start distance
 * @property {number} fogEnd - fog end distance
 * @property {number} fogMax - fog maximum opacity
 * @property {number} fogType - fog blend type
 * @property {number} fogBlur - fog blur mode
 * @property {vec4} fogColor - fog color
 * @property {vec3} sunDirection - the direction of the scene sun
 * @property {vec4} sunDiffuseColor - the colour of the light from the sun
 * @property {String} envMapResPath - nebula reflection map path
 * @property {String} envMap1ResPath - nebula diffuse map path
 * @property {String} envMap2ResPath - nebular blur map path
 * @property {String} envMap3ResPath - unused
 * @property {null|Tw2TextureRes} envMapRes
 * @property {null|Tw2TextureRes} envMap1Res
 * @property {null|Tw2TextureRes} envMap2Res
 * @property {null} envMap3Res - unused
 * @property {Tw2BatchAccumulator} _batches - Scene batch accumulator
 * @property {Tw2RawData} _perFrameVS
 * @property {Tw2RawData} _perFramePS
 * @property {boolean} renderDebugInfo
 * @property {*} _debugHelper
 * @class
 */
var EveSpaceScene = exports.EveSpaceScene = function () {
    function EveSpaceScene() {
        var _this = this;

        _classCallCheck(this, EveSpaceScene);

        this._id = _math.util.generateID();
        this.name = '';
        this.display = true;
        this.visible = {};
        this.visible.lensflares = true;
        this.visible.objects = true;
        this.visible.planets = true;
        this.visible.fog = true;
        this.visible.clearColor = true;
        this.visible.environmentReflection = true;
        this.visible.environmentDiffuse = true;
        this.visible.environmentBlur = true;

        Object.defineProperty(this.visible, 'environment', {
            get: function get() {
                return _this.backgroundRenderingEnabled;
            },
            set: function set(bool) {
                _this.backgroundRenderingEnabled = bool ? 1 : 0;
            }
        });

        this.lensflares = [];
        this.objects = [];
        this.planets = [];
        this.nebulaIntensity = 1;
        this.ambientColor = _math.quat.fromValues(0.25, 0.25, 0.25, 1);
        this.backgroundEffect = null;
        this.backgroundRenderingEnabled = 1;
        this.clearColor = _math.vec4.fromValues(0, 0, 0, 0);
        this.lodEnabled = false;
        this.fogStart = 0;
        this.fogEnd = 0;
        this.fogMax = 0;
        this.fogType = 0;
        this.fogBlur = 0;
        this.fogColor = _math.vec4.fromValues(0.25, 0.25, 0.25, 1);
        this.sunDirection = _math.vec3.fromValues(1, -1, 1);
        this.sunDiffuseColor = _math.vec4.fromValues(1, 1, 1, 1);
        this.envMapScaling = _math.vec3.fromValues(1, 1, 1);
        this.envMapRotation = _math.quat.create();
        this.envMapResPath = '';
        this.envMap1ResPath = '';
        this.envMap2ResPath = '';
        this.envMap3ResPath = '';
        this.envMapRes = null;
        this.envMap1Res = null;
        this.envMap2Res = null;
        this.envMap3Res = null;
        this.renderDebugInfo = false;
        this._debugHelper = null;

        this._batches = new _core.Tw2BatchAccumulator();
        this._perFrameVS = new _core.Tw2RawData();
        this._perFrameVS.Declare('ViewInverseTransposeMat', 16);
        this._perFrameVS.Declare('ViewProjectionMat', 16);
        this._perFrameVS.Declare('ViewMat', 16);
        this._perFrameVS.Declare('ProjectionMat', 16);
        this._perFrameVS.Declare('ShadowViewMat', 16);
        this._perFrameVS.Declare('ShadowViewProjectionMat', 16);
        this._perFrameVS.Declare('EnvMapRotationMat', 16);
        this._perFrameVS.Declare('SunData.DirWorld', 4);
        this._perFrameVS.Declare('SunData.DiffuseColor', 4);
        this._perFrameVS.Declare('FogFactors', 4);
        this._perFrameVS.Declare('TargetResolution', 4);
        this._perFrameVS.Declare('ViewportAdjustment', 4);
        this._perFrameVS.Declare('MiscSettings', 4);
        this._perFrameVS.Create();

        this._perFramePS = new _core.Tw2RawData();
        this._perFramePS.Declare('ViewInverseTransposeMat', 16);
        this._perFramePS.Declare('ViewMat', 16);
        this._perFramePS.Declare('EnvMapRotationMat', 16);
        this._perFramePS.Declare('SunData.DirWorld', 4);
        this._perFramePS.Declare('SunData.DiffuseColor', 4);
        this._perFramePS.Declare('SceneData.AmbientColor', 3);
        this._perFramePS.Declare('SceneData.NebulaIntensity', 1);
        this._perFramePS.Declare('SceneData.FogColor', 4);
        this._perFramePS.Declare('ViewportOffset', 2);
        this._perFramePS.Declare('ViewportSize', 2);
        this._perFramePS.Declare('TargetResolution', 4);
        this._perFramePS.Declare('ShadowMapSettings', 4);
        this._perFramePS.Declare('ShadowCameraRange', 4);
        this._perFramePS.Declare('ProjectionToView', 2);
        this._perFramePS.Declare('FovXY', 2);
        this._perFramePS.Declare('MiscSettings', 4);
        this._perFramePS.Create();

        EveSpaceScene.init();
    }

    /**
     * Initializes the space scene
     */


    _createClass(EveSpaceScene, [{
        key: 'Initialize',
        value: function Initialize() {
            this.SetEnvMapPath(0, this.envMapResPath);
            this.SetEnvMapPath(1, this.envMap1ResPath);
            this.SetEnvMapPath(2, this.envMap2ResPath);
            this.SetEnvMapPath(3, this.envMap3ResPath);
        }

        /**
         * Sets the environment's reflection map
         * @param {String} path
         */

    }, {
        key: 'SetEnvMapReflection',
        value: function SetEnvMapReflection(path) {
            this.SetEnvMapPath(0, path);
        }

        /**
         * Sets the environment's diffuse map
         * @param {string} path
         */

    }, {
        key: 'SetEnvMapDiffuse',
        value: function SetEnvMapDiffuse(path) {
            this.SetEnvMapPath(1, path);
        }

        /**
         * Sets the environment's blur map (used for fog)
         * @param {string} path
         */

    }, {
        key: 'SetEnvMapBlur',
        value: function SetEnvMapBlur(path) {
            this.SetEnvMapPath(2, path);
        }

        /**
         * Sets an environment map
         * @param {number} index
         * @param {String} path
         */

    }, {
        key: 'SetEnvMapPath',
        value: function SetEnvMapPath(index, path) {
            var _this2 = this;

            var _setEnvPath = function _setEnvPath(path, pathTarget, resTarget) {
                path = path.toLowerCase();
                _this2[pathTarget] = path;
                _this2[resTarget] = path === '' ? null : _core.resMan.GetResource(path);
                return true;
            };

            switch (index) {
                case 0:
                    // Reflection
                    return _setEnvPath(path, 'envMapResPath', 'envMapRes');

                case 1:
                    // Diffuse
                    return _setEnvPath(path, 'envMap1ResPath', 'envMap1Res');

                case 2:
                    // Blur
                    return _setEnvPath(path, 'envMap2ResPath', 'envMap2Res');

                case 3:
                    // Unused
                    return _setEnvPath(path, 'envMap3ResPath', 'envMap3Res');
            }

            return false;
        }

        /**
         * Enables LOD
         * @param {boolean} enable
         */

    }, {
        key: 'EnableLod',
        value: function EnableLod(enable) {
            this.lodEnabled = enable;

            if (!enable) {
                for (var i = 0; i < this.objects.length; ++i) {
                    if (this.objects[i].ResetLod) {
                        this.objects[i].ResetLod();
                    }
                }
            }
        }

        /**
         * Keeps the scene and it's object's resources alive
         */

    }, {
        key: 'KeepAlive',
        value: function KeepAlive() {
            var res = this.GetResources();
            for (var i = 0; i < res.length; i++) {
                res[i].KeepAlive();
            }
        }

        /**
         * Gets scene's resources
         * @param {Array} [out=[]] - Optional receiving array
         * @param {boolean} [excludeChildren]
         * @returns {Array.<Tw2Resource>} [out]
         */

    }, {
        key: 'GetResources',
        value: function GetResources() {
            var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var excludeChildren = arguments[1];

            for (var i = 0; i < this.lensflares.length; i++) {
                this.lensflares[i].GetResources(out);
            }

            if (this.backgroundEffect) {
                this.backgroundEffect.GetResources(out);
            }

            if (this.envMapRes && !out.includes(this.envMapRes)) out.push(this.envMapRes);
            if (this.envMap1Res && !out.includes(this.envMap1Res)) out.push(this.envMapRes);
            if (this.envMap2Res && !out.includes(this.envMap2Res)) out.push(this.envMapRes);
            if (this.envMap3Res && !out.includes(this.envMap3Res)) out.push(this.envMapRes);

            if (!excludeChildren) {
                for (var _i = 0; _i < this.planets.length; _i++) {
                    this.planets[_i].GetResources(out);
                }

                for (var _i2 = 0; _i2 < this.objects.length; _i2++) {
                    if ('GetResources' in this.objects[_i2]) {
                        this.objects[_i2].GetResources(out);
                    }
                }
            }

            return out;
        }

        /**
         * Per frame update that is called per frame
         * @param {number} dt - delta time
         */

    }, {
        key: 'Update',
        value: function Update(dt) {
            for (var i = 0; i < this.planets.length; ++i) {
                if ('Update' in this.planets[i]) {
                    this.planets[i].Update(dt);
                }
            }

            for (var _i3 = 0; _i3 < this.objects.length; ++_i3) {
                if ('Update' in this.objects[_i3]) {
                    this.objects[_i3].Update(dt);
                }
            }
        }

        /**
         * Gets batches for rendering
         * @param {number} mode
         * @param {Array.<EveObject>} objectArray
         * @param {Tw2BatchAccumulator} accumulator
         */

    }, {
        key: 'RenderBatches',
        value: function RenderBatches(mode, objectArray) {
            var accumulator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._batches;

            for (var i = 0; i < objectArray.length; ++i) {
                if ('GetBatches' in objectArray[i]) {
                    objectArray[i].GetBatches(mode, accumulator);
                }
            }
        }

        /**
         * Updates children's view dependent data and renders them
         */

    }, {
        key: 'Render',
        value: function Render() {
            this.ApplyPerFrameData();

            var d = _core.device,
                g = EveSpaceScene.global,
                id = _math.mat4.identity(g.mat4_ID),
                show = this.visible;

            if (show['environment'] && this.backgroundEffect) {
                d.SetStandardStates(d.RM_FULLSCREEN);
                d.RenderCameraSpaceQuad(this.backgroundEffect);
            }

            if (show.planets && this.planets.length) {
                var tempProj = _math.mat4.copy(g.mat4_0, d.projection),
                    newProj = _math.mat4.copy(g.mat4_1, d.projection),
                    zn = 10000,
                    zf = 1e11;

                newProj[10] = zf / (zn - zf);
                newProj[14] = zf * zn / (zn - zf);
                d.SetProjection(newProj, true);
                this.ApplyPerFrameData();

                for (var i = 0; i < this.planets.length; ++i) {
                    if (this.planets[i].UpdateViewDependentData) {
                        this.planets[i].UpdateViewDependentData(id);
                    }
                }

                this._batches.Clear();
                d.gl.depthRange(0.9, 1);
                this.RenderBatches(d.RM_OPAQUE, this.planets);
                this.RenderBatches(d.RM_DECAL, this.planets);
                this.RenderBatches(d.RM_TRANSPARENT, this.planets);
                this.RenderBatches(d.RM_ADDITIVE, this.planets);
                this._batches.Render();
                d.SetProjection(tempProj, true);
                this.ApplyPerFrameData();
                d.gl.depthRange(0, 0.9);
            }

            if (this.lodEnabled) {
                g.frustum.Initialize(d.view, d.projection, d.viewportWidth, d.viewInverse, d.viewProjection);
                for (var _i4 = 0; _i4 < this.objects.length; ++_i4) {
                    if (this.objects[_i4].UpdateLod) {
                        this.objects[_i4].UpdateLod(g.frustum);
                    }
                }
            }

            if (show.objects) {
                for (var _i5 = 0; _i5 < this.objects.length; ++_i5) {
                    if (this.objects[_i5].UpdateViewDependentData) {
                        this.objects[_i5].UpdateViewDependentData(id);
                    }
                }
            }

            if (show.lensflares) {
                for (var _i6 = 0; _i6 < this.lensflares.length; ++_i6) {
                    this.lensflares[_i6].PrepareRender();
                }
            }

            this._batches.Clear();

            if (show.planets) {
                for (var _i7 = 0; _i7 < this.planets.length; ++_i7) {
                    this.planets[_i7].GetZOnlyBatches(d.RM_OPAQUE, this._batches);
                }
            }

            if (show.objects) {
                this.RenderBatches(d.RM_OPAQUE, this.objects);
                this.RenderBatches(d.RM_DECAL, this.objects);
                this.RenderBatches(d.RM_TRANSPARENT, this.objects);
                this.RenderBatches(d.RM_ADDITIVE, this.objects);
            }

            if (show.lensflares) {
                for (var _i8 = 0; _i8 < this.lensflares.length; ++_i8) {
                    this.lensflares[_i8].GetBatches(d.RM_ADDITIVE, this._batches);
                }
            }

            this._batches.Render();

            if (show.lensflares) {
                for (var _i9 = 0; _i9 < this.lensflares.length; ++_i9) {
                    this.lensflares[_i9].UpdateOccluders();
                }
            }

            if (this.renderDebugInfo) {
                if (EveSpaceScene.DebugRenderer) {
                    if (!this._debugHelper) {
                        this._debugHelper = new EveSpaceScene.DebugRenderer();
                    }

                    for (var _i10 = 0; _i10 < this.objects.length; ++_i10) {
                        if (this.objects[_i10].RenderDebugInfo) {
                            this.objects[_i10].RenderDebugInfo(this._debugHelper);
                        }
                    }

                    this._debugHelper.Render();
                }
            }
        }

        /**
         * Applies per frame data
         */

    }, {
        key: 'ApplyPerFrameData',
        value: function ApplyPerFrameData() {
            var d = _core.device,
                g = EveSpaceScene.global,
                envMapTransform = g.mat4_2,
                sunDir = g.vec3_0,
                show = this.visible;

            _math.mat4.fromQuat(envMapTransform, this.envMapRotation);
            _math.mat4.scale(envMapTransform, envMapTransform, this.envMapScaling);
            _math.mat4.transpose(envMapTransform, envMapTransform);
            _math.vec3.negate(sunDir, this.sunDirection);
            _math.vec3.normalize(sunDir, sunDir);

            var distance = this.fogEnd - this.fogStart;
            if (Math.abs(distance) < 1e-5) distance = 1e-5;
            var f = 1.0 / distance;

            var VSData = this._perFrameVS;
            VSData.Set('FogFactors', [this.fogEnd * f, f, this.visible.fog ? this.fogMax : 0, 1]);
            VSData.Set('ViewportAdjustment', [1, 1, 1, 1]);
            VSData.Set('MiscSettings', [d.currentTime, 0, d.viewportWidth, d.viewportHeight]);
            VSData.Set('SunData.DirWorld', sunDir);
            VSData.Set('SunData.DiffuseColor', this.sunDiffuseColor);
            VSData.Set('TargetResolution', d.targetResolution);
            VSData.Set('ViewInverseTransposeMat', d.viewInverse);
            VSData.Set('ViewProjectionMat', d.viewProjectionTranspose);
            VSData.Set('ViewMat', d.viewTranspose);
            VSData.Set('ProjectionMat', d.projectionTranspose);
            VSData.Set('EnvMapRotationMat', envMapTransform);
            d.perFrameVSData = VSData;

            var PSData = this._perFramePS;
            PSData.Set('ViewInverseTransposeMat', d.viewInverse);
            PSData.Set('ViewMat', d.viewTranspose);
            PSData.Set('EnvMapRotationMat', envMapTransform);
            PSData.Set('SunData.DirWorld', sunDir);
            PSData.Set('SunData.DiffuseColor', this.sunDiffuseColor);
            PSData.Set('SceneData.AmbientColor', this.ambientColor);
            PSData.Set('MiscSettings', [d.currentTime, this.fogType, this.fogBlur, 1]);
            PSData.Set('SceneData.FogColor', this.fogColor);
            PSData.Set('FovXY', [d.targetResolution[3], d.targetResolution[2]]);
            PSData.Set('ShadowMapSettings', [1, 1, 0, 0]);
            PSData.Set('TargetResolution', d.targetResolution);
            PSData.Get('SceneData.NebulaIntensity')[0] = this.nebulaIntensity;
            PSData.Get('ViewportSize')[0] = d.viewportWidth;
            PSData.Get('ViewportSize')[1] = d.viewportHeight;
            PSData.Get('ShadowCameraRange')[0] = 1;
            PSData.Get('ProjectionToView')[0] = -d.projection[14];
            PSData.Get('ProjectionToView')[1] = -d.projection[10] - 1;
            d.perFramePSData = PSData;

            var envMap = this.envMapRes && show.environmentReflection ? this.envMapRes : g.emptyTexture,
                envMap1 = this.envMap1Res && show.environmentDiffuse ? this.envMap1Res : g.emptyTexture,
                envMap2 = this.envMap2Res && show.environmentBlur ? this.envMap2Res : g.emptyTexture,
                envMap3 = this.envMap3Res ? this.envMap3Res : g.emptyTexture;

            _core.store.GetVariable('EveSpaceSceneEnvMap').SetTextureRes(envMap);
            _core.store.GetVariable('EnvMap1').SetTextureRes(envMap1);
            _core.store.GetVariable('EnvMap2').SetTextureRes(envMap2);
            _core.store.GetVariable('EnvMap3').SetTextureRes(envMap3);
        }

        /**
         * Initializes class global and scratch variables
         */

    }], [{
        key: 'init',
        value: function init() {
            if (!EveSpaceScene.global) {
                EveSpaceScene.global = {
                    vec3_0: _math.vec3.create(),
                    vec4_0: _math.vec4.create(),
                    mat4_0: _math.mat4.create(),
                    mat4_1: _math.mat4.create(),
                    mat4_2: _math.mat4.create(),
                    mat4_ID: _math.mat4.create(),
                    frustum: new _core.Tw2Frustum(),
                    emptyTexture: _core.resMan.GetResource('res:/texture/global/black.dds.0.png')
                };
            }
        }
    }]);

    return EveSpaceScene;
}();

/**
 * Class global and scratch variables
 * @type {{string:*}}
 */


EveSpaceScene.global = null;

/**
 * Debug renderer
 * @type {?Function}
 */
EveSpaceScene.DebugRenderer = 'Tw2DebugRenderer' in window ? window['Tw2DebugRenderer'] : null;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EveSOF = EveSOF;

var _math = __webpack_require__(0);

var _core = __webpack_require__(1);

var _curve = __webpack_require__(57);

var _item = __webpack_require__(63);

var _child = __webpack_require__(58);

var _object = __webpack_require__(60);

function EveSOF() {
    var data = null;
    var spriteEffect = null;

    function _get(obj, property, defaultValue) {
        if (property in obj) {
            return obj[property];
        }
        return defaultValue;
    }

    /**
     * @return {string}
     */
    function GetShaderPrefix(isAnimated) {
        return isAnimated ? _get(data['generic'], 'shaderPrefixAnimated', '') : _get(data['generic'], 'shaderPrefix', '');
    }

    function ModifyTextureResPath(path, name, area, faction, commands) {
        var pathInsert = null;
        if (_get(faction, 'resPathInsert', '').length) {
            pathInsert = faction.resPathInsert;
        }
        if ('respathinsert' in commands && commands.respathinsert.length === 1) {
            if (commands.respathinsert[0] === 'none') {
                return path;
            } else {
                pathInsert = commands.respathinsert[0];
            }
        }
        if (name === 'MaterialMap' || name === 'PaintMaskMap' || name === 'PmdgMap') {
            var index = path.lastIndexOf('/');
            var pathCopy = path;
            if (index >= 0) {
                pathCopy = path.substr(0, index + 1) + pathInsert + '/' + path.substr(index + 1);
            }
            index = pathCopy.lastIndexOf('_');
            if (index >= 0) {
                pathCopy = pathCopy.substr(0, index) + '_' + pathInsert + pathCopy.substr(index);
                var textureOverrides = _get(area, 'textureOverrides', {});
                if (name in textureOverrides && faction.name in textureOverrides[name]) {
                    return pathCopy;
                }
            }
        }
        return path;
    }

    /**
     * @return {string}
     */
    function ModifyShaderPath(shader, isSkinned) {
        var prefix = GetShaderPrefix(isSkinned);
        shader = '/' + shader;
        var index = shader.lastIndexOf('/');
        return shader.substr(0, index + 1) + prefix + shader.substr(index + 1);
    }

    function FindPrefix(prefixes, name) {
        for (var m = 0; m < prefixes.length; ++m) {
            if (name.substr(0, prefixes[m].length) === prefixes[m]) {
                return m;
            }
        }
        return null;
    }

    function GetOverridenParameter(name, area, commands, race) {
        var prefixes, materialIndex, materialData, shortName;
        if ('mesh' in commands) {
            prefixes = data.generic.materialPrefixes;
            materialIndex = FindPrefix(prefixes, name);
            if (materialIndex !== null && materialIndex < commands.mesh.length && (_get(area, 'blockedMaterials', 0) & 1 << materialIndex) === 0) {
                materialData = _get(data.material, commands.mesh[materialIndex], null);
                if (materialData) {
                    shortName = name.substr(prefixes[materialIndex].length);
                    return _get(materialData.parameters, shortName, undefined);
                }
            }
        }
        prefixes = data.generic.patternMaterialPrefixes;
        materialIndex = FindPrefix(prefixes, name);
        if ('pattern' in commands) {
            if (materialIndex !== null && 1 + materialIndex < commands.pattern.length) {
                materialData = _get(data.material, commands.pattern[1 + materialIndex], null);
                if (materialData) {
                    shortName = name.substr(prefixes[materialIndex].length);
                    return _get(materialData.parameters, shortName, undefined);
                }
            }
        }

        if (materialIndex !== null) {
            materialData = _get(data.material, race.defaultPatternLayer1MaterialName, null);
            if (materialData) {
                shortName = name.substr(prefixes[materialIndex].length);
                return _get(materialData.parameters, shortName, undefined);
            }
        }
    }

    function GetAddressMode(projectionType) {
        switch (projectionType) {
            case 2:
                return 4;
            case 1:
                return 3;
            default:
                return 1;
        }
    }

    function FillMeshAreas(areas, areasName, hull, faction, race, pattern, commands, shaderOverride) {
        var hullAreas = _get(hull, areasName, []);
        for (var i = 0; i < hullAreas.length; ++i) {
            var area = hullAreas[i];
            var effect = new _core.Tw2Effect();
            effect.effectFilePath = data['generic']['areaShaderLocation'] + ModifyShaderPath(shaderOverride ? shaderOverride : area.shader, hull['isSkinned']);
            var names = _get(_get(data['generic']['areaShaders'], area.shader, {}), 'parameters', []);
            for (var j = 0; j < names.length; ++j) {
                var name = names[j];
                var param = GetOverridenParameter(name, area, commands, race);
                param = param || _get(_get(_get(data.generic.hullAreas, area.name, {}), 'parameters', {}), name);
                param = param || _get(_get(_get(race.hullAreas, area.name, {}), 'parameters', {}), name);
                param = param || _get(_get(_get(faction.areas, area.name, {}), 'parameters', {}), name);
                param = param || _get(_get(area, 'parameters', {}), name);
                if (param) {
                    effect.parameters[name] = new _core.Tw2Vector4Parameter(name, param);
                }
            }

            var hullTextures = _get(area, 'textures', []);
            for (j in hullTextures) {
                if (hullTextures.hasOwnProperty(j)) {
                    var path = hullTextures[j];
                    path = ModifyTextureResPath(path, j, area, faction, commands);
                    effect.parameters[j] = new _core.Tw2TextureParameter(j, path);
                }
            }

            for (j = 0; j < pattern.layers.length; ++j) {
                if (pattern.layers[j] && !(pattern.layers[j].textureName in effect.parameters)) {
                    var patternTex = new _core.Tw2TextureParameter(pattern.layers[j].textureName);
                    patternTex.resourcePath = pattern.layers[j].textureResFilePath;
                    patternTex.useAllOverrides = true;
                    patternTex.addressUMode = GetAddressMode(_get(pattern.layers[j], 'projectionTypeU', 0));
                    patternTex.addressVMode = GetAddressMode(_get(pattern.layers[j], 'projectionTypeV', 0));
                    patternTex.Initialize();
                    effect.parameters[pattern.layers[j].textureName] = patternTex;
                }
            }

            var defaultTextures = _get(_get(data['generic']['areaShaders'], area.shader, {}), 'defaultTextures', {});
            for (var texName in defaultTextures) {
                if (defaultTextures.hasOwnProperty(texName)) {
                    if (!(texName in effect.parameters)) {
                        effect.parameters[texName] = new _core.Tw2TextureParameter(texName, defaultTextures[texName]);
                    }
                }
            }

            effect.Initialize();

            var newArea = new _core.Tw2MeshArea();
            newArea.name = area.name;
            newArea.effect = effect;
            newArea.index = _get(area, 'index', 0);
            newArea.count = _get(area, 'count', 1);
            areas.push(newArea);
        }
    }

    function SetupMesh(ship, hull, faction, race, commands, pattern) {
        var mesh = new _core.Tw2Mesh();
        mesh.geometryResPath = hull['geometryResFilePath'];
        ship.boundingSphereCenter[0] = hull.boundingSphere[0];
        ship.boundingSphereCenter[1] = hull.boundingSphere[1];
        ship.boundingSphereCenter[2] = hull.boundingSphere[2];
        ship.boundingSphereRadius = hull.boundingSphere[3];
        FillMeshAreas(_get(mesh, 'opaqueAreas', []), 'opaqueAreas', hull, faction, race, pattern, commands);
        FillMeshAreas(_get(mesh, 'transparentAreas', []), 'transparentAreas', hull, faction, race, pattern, commands);
        FillMeshAreas(_get(mesh, 'additiveAreas', []), 'additiveAreas', hull, faction, race, pattern, commands);
        FillMeshAreas(_get(mesh, 'decalAreas', []), 'decalAreas', hull, faction, race, pattern, commands);
        FillMeshAreas(_get(mesh, 'depthAreas', []), 'depthAreas', hull, faction, race, pattern, commands);
        mesh.Initialize();
        ship.mesh = mesh;
        if ('shapeEllipsoidCenter' in hull) {
            ship.shapeEllipsoidCenter = hull.shapeEllipsoidCenter;
        }
        if ('shapeEllipsoidRadius' in hull) {
            ship.shapeEllipsoidRadius = hull.shapeEllipsoidRadius;
        }
    }

    function SetupPattern(hull, race, commands) {
        var pattern = {
            patterns: [],
            layers: []
        };
        if ('pattern' in commands) {
            var p = {};
            for (var k = 0; k < data.pattern.length; ++k) {
                if (data.pattern[k].name === commands.pattern[0]) {
                    p = data.pattern[k];
                    break;
                }
            }
            var layer = _get(p, 'layer1', null);
            if (layer) {
                pattern.layers.push(layer);
            }
            layer = _get(p, 'layer2', null);
            if (layer) {
                pattern.layers.push(layer);
            }
            var projections = _get(p, 'projections', []);
            for (var i = 0; i < projections.length; ++i) {
                if (projections[i].name === hull.name) {
                    p = projections[i];
                    layer = _get(p, 'transformLayer1', null);
                    if (layer) {
                        pattern.patterns.push(layer);
                    }
                    layer = _get(p, 'transformLayer2', null);
                    if (layer) {
                        pattern.patterns.push(layer);
                    }
                }
            }
        } else if (_get(hull, 'defaultPattern')) {
            p = _get(hull, 'defaultPattern', {});
            layer = _get(p, 'transformLayer1', null);
            if (layer) {
                pattern.patterns.push(layer);
            }
            layer = _get(p, 'transformLayer2', null);
            if (layer) {
                pattern.patterns.push(layer);
            }
            p = _get(race, 'defaultPattern', {});
            layer = _get(p, 'layer1', null);
            if (layer) {
                pattern.layers.push(layer);
            }
            layer = _get(p, 'layer2', null);
            if (layer) {
                pattern.layers.push(layer);
            }
        }
        return pattern;
    }

    function SetupCustomMasks(ship, pattern) {
        for (var i = 0; i < pattern.patterns.length; ++i) {
            if (pattern.patterns[i] && pattern.layers[i]) {
                var p = pattern.patterns[i];
                var l = pattern.layers[i];
                ship.AddCustomMask(_get(p, 'position', _math.vec3.create()), _get(p, 'scaling', _math.vec3.fromValues(1, 1, 1)), _get(p, 'rotation', _math.quat.create()), _get(p, 'isMirrored', false), _get(l, 'materialSource', 0), _math.vec4.fromValues(_get(l, 'isTargetMtl1', true) ? 1 : 0, _get(l, 'isTargetMtl2', true) ? 1 : 0, _get(l, 'isTargetMtl3', true) ? 1 : 0, _get(l, 'isTargetMtl4', true) ? 1 : 0));
            }
        }
    }

    function SetupDecals(ship, hull, faction) {
        var hullDecals = _get(hull, 'hullDecals', []);
        for (var i = 0; i < hullDecals.length; ++i) {
            var hullDecal = hullDecals[i];
            var factionDecal = null;
            var factionIndex = 'group' + _get(hullDecal, 'groupIndex', -1);
            if (faction.decals && factionIndex in faction.decals) {
                factionDecal = faction.decals[factionIndex];
            }
            if (factionDecal && !factionDecal['isVisible']) {
                continue;
            }
            var effect = new _core.Tw2Effect();
            if (factionDecal && factionDecal.shader && factionDecal.shader.length) {
                effect.effectFilePath = data['generic']['decalShaderLocation'] + '/' + GetShaderPrefix(false) + factionDecal.shader;
            } else if (hullDecal.shader && hullDecal.shader.length) {
                effect.effectFilePath = data['generic']['decalShaderLocation'] + '/' + GetShaderPrefix(false) + hullDecal.shader;
            } else {
                continue;
            }
            var hullParameters = _get(hullDecal, 'parameters', {});
            for (var j in hullParameters) {
                if (hullParameters.hasOwnProperty(j)) {
                    effect.parameters[j] = new _core.Tw2Vector4Parameter(j, hullParameters[j]);
                }
            }
            var hullTextures = _get(hullDecal, 'textures', {});
            for (j in hullTextures) {
                if (hullTextures.hasOwnProperty(j)) {
                    effect.parameters[j] = new _core.Tw2TextureParameter(j, hullTextures[j]);
                }
            }
            if (factionDecal) {
                var factionParameters = _get(factionDecal, 'parameters', {});
                for (j in factionParameters) {
                    if (factionParameters.hasOwnProperty(j)) {
                        effect.parameters[j] = new _core.Tw2Vector4Parameter(j, factionParameters[j]);
                    }
                }
                var factionTextures = _get(factionDecal, 'textures', {});
                for (j in factionTextures) {
                    if (factionTextures.hasOwnProperty(j) && !(j in effect.parameters)) {
                        effect.parameters[j] = new _core.Tw2TextureParameter(j, factionTextures[j]);
                    }
                }
            }

            var defaultTextures = _get(_get(data['generic']['decalShaders'], hullDecal.shader, {}), 'defaultTextures', {});
            for (var texName in defaultTextures) {
                if (defaultTextures.hasOwnProperty(texName)) {
                    if (!(texName in effect.parameters)) {
                        effect.parameters[texName] = new _core.Tw2TextureParameter(texName, defaultTextures[texName]);
                    }
                }
            }

            effect.Initialize();

            var decal = new _item.EveSpaceObjectDecal();
            _math.vec3.copy(decal.position, _get(hullDecal, 'position', [0, 0, 0]));
            _math.quat.copy(decal.rotation, _get(hullDecal, 'rotation', [0, 0, 0, 1]));
            _math.vec3.copy(decal.scaling, _get(hullDecal, 'scaling', [1, 1, 1]));
            decal.parentBoneIndex = _get(hullDecal, 'boneIndex', -1);
            decal.indexBuffer = new Uint16Array(hullDecal.indexBuffer);
            decal.decalEffect = effect;
            decal.name = _get(hullDecals[i], 'name', '');
            if ('groupIndex' in hullDecals[i]) {
                decal.groupIndex = hullDecals[i].groupIndex;
            }
            decal.Initialize();
            ship.decals.push(decal);
        }
    }

    function SetupInstancedMeshes(ship, hull, faction, race, commands, pattern) {
        var instancedMeshes = _get(hull, 'instancedMeshes', []);
        for (var i = 0; i < instancedMeshes.length; ++i) {
            var him = instancedMeshes[i];
            var mesh = new _core.Tw2InstancedMesh();
            mesh.instanceGeometryResPath = him.instanceGeometryResPath;
            mesh.geometryResPath = him.geometryResPath;
            mesh.Initialize();

            FillMeshAreas(_get(mesh, 'opaqueAreas', []), 'opaqueAreas', hull, faction, race, pattern, commands, him.shader);

            var child = new _child.EveChildMesh();
            child.mesh = mesh;
            ship.effectChildren.push(child);
        }
    }

    function SetupSpriteSets(ship, hull, faction) {
        var hullSets = _get(hull, 'spriteSets', []);
        var factionSets = _get(faction, 'spriteSets', {});
        for (var i = 0; i < hullSets.length; ++i) {
            var spriteSet = new _item.EveSpriteSet(true, !!(hull['isSkinned'] && hullSets[i]['skinned']));
            spriteSet.name = _get(hullSets[i], 'name', '');
            spriteSet.effect = spriteEffect;
            var hullData = _get(hullSets[i], 'items', []);
            for (var j = 0; j < hullData.length; ++j) {
                if (!('group' + _get(hullData[j], 'groupIndex', -1) in factionSets)) continue;
                var item = new _item.EveSpriteSetItem();
                item.blinkPhase = _get(hullData[j], 'blinkPhase', 0);
                item.blinkRate = _get(hullData[j], 'blinkRate', 0.1);
                item.boneIndex = _get(hullData[j], 'boneIndex', 0);
                item.falloff = _get(hullData[j], 'falloff', 0);
                item.maxScale = _get(hullData[j], 'maxScale', 10);
                item.minScale = _get(hullData[j], 'minScale', 1);
                item.name = _get(hullData[j], 'name', '');
                item.groupIndex = _get(hullData[j], 'groupIndex', -1);
                _math.vec3.copy(item.position, _get(hullData[j], 'position', [0, 0, 0]));

                var factionSet = factionSets['group' + item.groupIndex];
                if (factionSet) {
                    item.groupName = factionSet.name;
                    if ('color' in factionSet) _math.vec4.copy(item.color, factionSet.color);
                }
                spriteSet.sprites.push(item);
            }
            spriteSet.Initialize();
            ship.spriteSets.push(spriteSet);
        }
    }

    function SetupSpotlightSets(ship, hull, faction) {
        var hullSets = _get(hull, 'spotlightSets', []);
        var factionSets = _get(faction, 'spotlightSets', {});
        for (var i = 0; i < hullSets.length; ++i) {
            var spotlightSet = new _item.EveSpotlightSet();
            spotlightSet.name = _get(hullSets[i], 'name', '');
            spotlightSet.coneEffect = new _core.Tw2Effect();
            spotlightSet.glowEffect = new _core.Tw2Effect();
            if (hullSets[i]['skinned']) {
                spotlightSet.coneEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/skinned_spotlightcone.fx';
                spotlightSet.glowEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/skinned_spotlightglow.fx';
            } else {
                spotlightSet.coneEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/spotlightcone.fx';
                spotlightSet.glowEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/spotlightglow.fx';
            }
            spotlightSet.coneEffect.parameters['TextureMap'] = new _core.Tw2TextureParameter('TextureMap', hullSets[i]['coneTextureResPath']);
            spotlightSet.glowEffect.parameters['TextureMap'] = new _core.Tw2TextureParameter('TextureMap', hullSets[i]['glowTextureResPath']);
            spotlightSet.coneEffect.parameters['zOffset'] = new _core.Tw2FloatParameter('zOffset', _get(hullSets[i], 'zOffset', 0));
            spotlightSet.coneEffect.Initialize();
            spotlightSet.glowEffect.Initialize();

            var hullData = _get(hullSets[i], 'items', []);
            for (var j = 0; j < hullData.length; ++j) {
                var item = new _item.EveSpotlightSetItem();
                item.name = _get(hullData[j], 'name', '');
                item.groupIndex = _get(hullData[j], 'groupIndex', -1);
                item.boneIndex = _get(hullData[j], 'boneIndex', 0);
                item.boosterGainInfluence = _get(hullData[j], 'boosterGainInfluence', 0);

                item.coneIntensity = _get(hullData[j], 'coneIntensity', 0);
                item.spriteIntensity = _get(hullData[j], 'spriteIntensity', 0);
                item.flareIntensity = _get(hullData[j], 'flareIntensity', 0);

                var factionSet = factionSets['group' + item.groupIndex];
                if (factionSet) {
                    _math.vec4.copy(item.coneColor, _get(factionSet, 'coneColor', [0, 0, 0, 0]));
                    _math.vec4.copy(item.spriteColor, _get(factionSet, 'spriteColor', [0, 0, 0, 0]));
                    _math.vec4.copy(item.flareColor, _get(factionSet, 'flareColor', [0, 0, 0, 0]));
                }
                _math.vec3.copy(item.spriteScale, _get(hullData[j], 'spriteScale', [1, 1, 1]));

                if ('transform' in hullData[j]) {
                    _math.mat4.copy(item.transform, hullData[j].transform);
                } else {
                    _math.mat4.identity(item.transform);
                }

                spotlightSet.spotlightItems.push(item);
            }
            spotlightSet.Initialize();
            ship.spotlightSets.push(spotlightSet);
        }
    }

    function _assignIfExists(dest, src, attr) {
        if (attr in src) {
            dest[attr] = src[attr];
        }
    }

    function SetupPlaneSets(ship, hull, faction) {
        var hullSets = _get(hull, 'planeSets', []);
        var factionSets = _get(faction, 'planeSets', {});
        for (var i = 0; i < hullSets.length; ++i) {
            var planeSet = new _item.EvePlaneSet();
            planeSet.name = _get(hullSets[i], 'name', '');
            planeSet.effect = new _core.Tw2Effect();
            if (hullSets[i]['skinned']) {
                planeSet.effect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/skinned_planeglow.fx';
            } else {
                planeSet.effect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/planeglow.fx';
            }
            planeSet.effect.parameters['Layer1Map'] = new _core.Tw2TextureParameter('Layer1Map', hullSets[i]['layer1MapResPath']);
            planeSet.effect.parameters['Layer2Map'] = new _core.Tw2TextureParameter('Layer2Map', hullSets[i]['layer2MapResPath']);
            planeSet.effect.parameters['MaskMap'] = new _core.Tw2TextureParameter('MaskMap', hullSets[i]['maskMapResPath']);
            planeSet.effect.parameters['PlaneData'] = new _core.Tw2Vector4Parameter('PlaneData', _get(hullSets[i], 'planeData', [1, 0, 0, 0]));
            planeSet.effect.Initialize();

            var hullData = _get(hullSets[i], 'items', []);
            for (var j = 0; j < hullData.length; ++j) {
                var item = new _item.EvePlaneSetItem();
                _assignIfExists(item, hullData[j], 'groupIndex');
                _assignIfExists(item, hullData[j], 'name');
                item.boneIndex = _get(hullData[j], 'boneIndex', -1);
                item.maskAtlasID = _get(hullData[j], 'maskMapAtlasIndex', 0);
                // Do not copy reference!
                _math.vec3.copy(item.position, _get(hullData[j], 'position', [0, 0, 0]));
                _math.quat.copy(item.rotation, _get(hullData[j], 'rotation', [0, 0, 0, 1]));
                _math.vec3.copy(item.scaling, _get(hullData[j], 'scaling', [1, 1, 1]));
                _math.vec4.copy(item.color, _get(hullData[j], 'color', [0, 0, 0, 0]));
                _math.vec4.copy(item.layer1Transform, _get(hullData[j], 'layer1Transform', [0, 0, 0, 0]));
                _math.vec4.copy(item.layer1Scroll, _get(hullData[j], 'layer1Scroll', [0, 0, 0, 0]));
                _math.vec4.copy(item.layer2Transform, _get(hullData[j], 'layer2Transform', [0, 0, 0, 0]));
                _math.vec4.copy(item.layer2Scroll, _get(hullData[j], 'layer2Scroll', [0, 0, 0, 0]));

                var factionSet = factionSets['group' + _get(hullData[j], 'groupIndex', -1)];
                if (factionSet) _math.vec4.copy(item.color, _get(factionSet, 'color', [0, 0, 0, 0]));
                planeSet.planes.push(item);
            }
            planeSet.Initialize();
            ship.planeSets.push(planeSet);
        }
    }

    function SetupBoosters(ship, hull, race) {
        if (!('booster' in hull)) {
            return;
        }
        var booster = new _item.EveBoosterSet();
        var hullBooster = hull['booster'];
        var raceBooster = _get(race, 'booster', {});
        _assignIfExists(booster, raceBooster, 'glowScale');
        _assignIfExists(booster, raceBooster, 'symHaloScale');
        _assignIfExists(booster, raceBooster, 'haloScaleX');
        _assignIfExists(booster, raceBooster, 'haloScaleY');
        _assignIfExists(booster, raceBooster, 'haloColor');
        _math.vec4.copy(booster.glowColor, _get(raceBooster, 'glowColor', [0, 0, 0, 0]));
        _math.vec4.copy(booster.warpGlowColor, _get(raceBooster, 'warpGlowColor', [0, 0, 0, 0]));
        _math.vec4.copy(booster.warpHaloColor, _get(raceBooster, 'warpHalpColor', [0, 0, 0, 0]));
        _math.vec4.copy(booster.trailColor, _get(raceBooster, 'trailColor', [0, 0, 0, 0]));
        _math.vec4.copy(booster.trailSize, _get(raceBooster, 'trailSize', [0, 0, 0, 0]));

        booster.effect = new _core.Tw2Effect();
        booster.effect.effectFilePath = 'res:/Graphics/Effect/Managed/Space/Booster/BoosterVolumetric.fx';
        booster.effect.parameters['NoiseFunction0'] = new _core.Tw2FloatParameter('NoiseFunction0', _get(raceBooster.shape0, 'noiseFunction', 0));
        booster.effect.parameters['NoiseSpeed0'] = new _core.Tw2FloatParameter('NoiseSpeed0', _get(raceBooster.shape0, 'noiseSpeed', 0));
        booster.effect.parameters['NoiseAmplitudeStart0'] = new _core.Tw2Vector4Parameter('NoiseAmplitudeStart0', _get(raceBooster.shape0, 'noiseAmplitureStart', [0, 0, 0, 0]));
        booster.effect.parameters['NoiseAmplitudeEnd0'] = new _core.Tw2Vector4Parameter('NoiseAmplitudeEnd0', _get(raceBooster.shape0, 'noiseAmplitureEnd', [0, 0, 0, 0]));
        booster.effect.parameters['NoiseFrequency0'] = new _core.Tw2Vector4Parameter('NoiseFrequency0', _get(raceBooster.shape0, 'noiseFrequency', [0, 0, 0, 0]));
        booster.effect.parameters['Color0'] = new _core.Tw2Vector4Parameter('Color0', _get(raceBooster.shape0, 'color', [0, 0, 0, 0]));

        booster.effect.parameters['NoiseFunction1'] = new _core.Tw2FloatParameter('NoiseFunction1', _get(raceBooster.shape1, 'noiseFunction', 0));
        booster.effect.parameters['NoiseSpeed1'] = new _core.Tw2FloatParameter('NoiseSpeed1', _get(raceBooster.shape1, 'noiseSpeed', 0));
        booster.effect.parameters['NoiseAmplitudeStart1'] = new _core.Tw2Vector4Parameter('NoiseAmplitudeStart1', _get(raceBooster.shape1, 'noiseAmplitureStart', [0, 0, 0, 0]));
        booster.effect.parameters['NoiseAmplitudeEnd1'] = new _core.Tw2Vector4Parameter('NoiseAmplitudeEnd1', _get(raceBooster.shape1, 'noiseAmplitureEnd', [0, 0, 0, 0]));
        booster.effect.parameters['NoiseFrequency1'] = new _core.Tw2Vector4Parameter('NoiseFrequency1', _get(raceBooster.shape1, 'noiseFrequency', [0, 0, 0, 0]));
        booster.effect.parameters['Color1'] = new _core.Tw2Vector4Parameter('Color1', _get(raceBooster.shape1, 'color', [0, 0, 0, 0]));

        booster.effect.parameters['WarpNoiseFunction0'] = new _core.Tw2FloatParameter('WarpNoiseFunction0', _get(raceBooster.warpShape0, 'noiseFunction', 0));
        booster.effect.parameters['WarpNoiseSpeed0'] = new _core.Tw2FloatParameter('WarpNoiseSpeed0', _get(raceBooster.warpShape0, 'noiseSpeed', 0));
        booster.effect.parameters['WarpNoiseAmplitudeStart0'] = new _core.Tw2Vector4Parameter('WarpNoiseAmplitudeStart0', _get(raceBooster.warpShape0, 'noiseAmplitureStart', [0, 0, 0, 0]));
        booster.effect.parameters['WarpNoiseAmplitudeEnd0'] = new _core.Tw2Vector4Parameter('WarpNoiseAmplitudeEnd0', _get(raceBooster.warpShape0, 'noiseAmplitureEnd', [0, 0, 0, 0]));
        booster.effect.parameters['WarpNoiseFrequency0'] = new _core.Tw2Vector4Parameter('WarpNoiseFrequency0', _get(raceBooster.warpShape0, 'noiseFrequency', [0, 0, 0, 0]));
        booster.effect.parameters['WarpColor0'] = new _core.Tw2Vector4Parameter('WarpColor0', _get(raceBooster.warpShape0, 'color', [0, 0, 0, 0]));

        booster.effect.parameters['WarpNoiseFunction1'] = new _core.Tw2FloatParameter('WarpNoiseFunction1', _get(raceBooster.warpShape1, 'noiseFunction', 0));
        booster.effect.parameters['WarpNoiseSpeed1'] = new _core.Tw2FloatParameter('WarpNoiseSpeed1', _get(raceBooster.warpShape1, 'noiseSpeed', 0));
        booster.effect.parameters['WarpNoiseAmplitudeStart1'] = new _core.Tw2Vector4Parameter('WarpNoiseAmplitudeStart1', _get(raceBooster.warpShape1, 'noiseAmplitureStart', [0, 0, 0, 0]));
        booster.effect.parameters['WarpNoiseAmplitudeEnd1'] = new _core.Tw2Vector4Parameter('WarpNoiseAmplitudeEnd1', _get(raceBooster.warpShape1, 'noiseAmplitureEnd', [0, 0, 0, 0]));
        booster.effect.parameters['WarpNoiseFrequency1'] = new _core.Tw2Vector4Parameter('WarpNoiseFrequency1', _get(raceBooster.warpShape1, 'noiseFrequency', [0, 0, 0, 0]));
        booster.effect.parameters['WarpColor1'] = new _core.Tw2Vector4Parameter('WarpColor1', _get(raceBooster.warpShape1, 'color', [0, 0, 0, 0]));

        booster.effect.parameters['ShapeAtlasSize'] = new _core.Tw2Vector4Parameter('ShapeAtlasSize', [_get(raceBooster, 'shapeAtlasHeight', 0), _get(raceBooster, 'shapeAtlasCount', 0), 0, 0]);
        booster.effect.parameters['BoosterScale'] = new _core.Tw2Vector4Parameter('BoosterScale', _get(raceBooster, 'scale', [1, 1, 1, 1]));

        booster.effect.parameters['ShapeMap'] = new _core.Tw2TextureParameter('ShapeMap', raceBooster.shapeAtlasResPath);
        booster.effect.parameters['GradientMap0'] = new _core.Tw2TextureParameter('GradientMap0', raceBooster.gradient0ResPath);
        booster.effect.parameters['GradientMap1'] = new _core.Tw2TextureParameter('GradientMap1', raceBooster.gradient1ResPath);
        booster.effect.parameters['NoiseMap'] = new _core.Tw2TextureParameter('ShapeMap', 'res:/Texture/Global/noise32cube_volume.dds.0.png');

        booster.effect.Initialize();

        booster.glows = new _item.EveSpriteSet(true);
        booster.glows.effect = new _core.Tw2Effect();
        booster.glows.effect.effectFilePath = 'res:/Graphics/Effect/Managed/Space/Booster/BoosterGlowAnimated.fx';
        booster.glows.effect.parameters['DiffuseMap'] = new _core.Tw2TextureParameter('DiffuseMap', 'res:/Texture/Particle/whitesharp.dds.0.png');
        booster.glows.effect.parameters['NoiseMap'] = new _core.Tw2TextureParameter('NoiseMap', 'res:/Texture/global/noise.dds.0.png');
        booster.glows.effect.Initialize();

        var items = _get(hullBooster, 'items', []);
        for (var i = 0; i < items.length; ++i) {
            var locator = new _item.EveLocator();
            locator.name = 'locator_booster_' + (i + 1);
            if ('transform' in items[i]) {
                _math.mat4.copy(locator.transform, items[i].transform);
            } else {
                _math.mat4.identity(locator.transform);
            }
            locator.atlasIndex0 = _get(items[i], 'atlasIndex0', 0);
            locator.atlasIndex1 = _get(items[i], 'atlasIndex1', 0);
            ship.locators.push(locator);
        }
        booster.Initialize();
        ship.boosters = booster;
    }

    function SetupLocators(ship, hull) {
        var hullLocators = _get(hull, 'locatorTurrets', []);
        for (var i = 0; i < hullLocators.length; ++i) {
            var locator = new _item.EveLocator();
            locator.name = hullLocators[i].name;
            if ('transform' in hullLocators[i]) {
                _math.mat4.copy(locator.transform, hullLocators[i].transform);
            } else {
                _math.mat4.identity(locator.transform);
            }
            ship.locators.push(locator);
        }
    }

    function BindParticleEmitters(obj, curveSet, curve) {
        for (var i = 0; i < obj.particleEmitters.length; ++i) {
            if ('rate' in obj.particleEmitters[i]) {
                var binding = new _core.Tw2ValueBinding();
                binding.sourceObject = curve;
                binding.sourceAttribute = 'currentValue';
                binding.destinationObject = obj.particleEmitters[i];
                binding.destinationAttribute = 'rate';
                binding.Initialize();
                curveSet.bindings.push(binding);
            }
        }
        for (i = 0; i < obj.children.length; ++i) {
            BindParticleEmitters(obj.children[i], curveSet, curve);
        }
    }

    function SetupChildren(ship, hull, curveSet, curves) {
        function onChildLoaded(child) {
            return function (obj) {
                if (obj.isEffectChild) {
                    ship.effectChildren.push(obj);
                } else {
                    ship.children.push(obj);
                }
                _math.vec3.copy(obj.translation, _get(child, 'translation', [0, 0, 0]));
                _math.quat.copy(obj.rotation, _get(child, 'rotation', [0, 0, 0, 1]));
                _math.vec3.copy(obj.scaling, _get(child, 'scaling', [1, 1, 1]));
                var id = _get(child, 'id', -1);
                if (id !== -1 && curves[id]) {
                    BindParticleEmitters(obj, curveSet, curves[id]);
                }
            };
        }

        var children = _get(hull, 'children', []);
        for (var i = 0; i < children.length; ++i) {
            _core.resMan.GetObject(children[i]['redFilePath'], onChildLoaded(children[i]));
        }
    }

    function SetupAnimations(ship, hull) {
        var id_curves = [];
        var curveSet = null;
        var animations = _get(hull, 'animations', []);
        for (var i = 0; i < animations.length; ++i) {
            if (_get(animations[i], 'id', -1) !== -1 && _get(animations[i], 'startRate', -1) !== -1) {
                if (!curveSet) {
                    curveSet = new _core.Tw2CurveSet();
                }
                var curve = new _curve.Tw2ScalarCurve2();
                curve.keys.push(new _curve.Tw2ScalarKey2());
                curve.keys.push(new _curve.Tw2ScalarKey2());
                curve.keys[0].value = _get(animations[i], 'startRate', -1);
                curve.keys[1].time = 1;
                curve.keys[1].value = _get(animations[i], 'endRate', -1);
                curve.Initialize();
                curveSet.curves.push(curve);
                ship.curveSets.push(curveSet);
                id_curves[_get(animations[i], 'id', -1)] = curve;
            }
        }
        if (curveSet) {
            curveSet.Initialize();
        }
        return [curveSet, id_curves];
    }

    var dataLoading = false;
    var pendingLoads = [];

    function Build(dna) {
        var parts = dna.split(':');
        var commands = {};
        for (var i = 3; i < parts.length; ++i) {
            var subparts = parts[i].split('?');
            commands[subparts[0]] = subparts[1].split(';');
        }
        var hull = data['hull'][parts[0]];
        var faction = data['faction'][parts[1]];
        var race = data['race'][parts[2]];
        var ship = new (_get(hull, 'buildClass', 0) === 2 ? _object.EveSpaceObject : _object.EveShip)();
        var pattern = SetupPattern(hull, race, commands);
        SetupMesh(ship, hull, faction, race, commands, pattern);
        SetupCustomMasks(ship, pattern);
        SetupDecals(ship, hull, faction);
        SetupSpriteSets(ship, hull, faction);
        SetupSpotlightSets(ship, hull, faction);
        SetupPlaneSets(ship, hull, faction);
        SetupBoosters(ship, hull, race);
        SetupLocators(ship, hull);
        var curves = SetupAnimations(ship, hull);
        SetupChildren(ship, hull, curves[0], curves[1]);
        SetupInstancedMeshes(ship, hull, faction, race, commands, pattern);

        ship.Initialize();
        return ship;
    }

    this.LoadData = function (callback) {
        if (data === null) {
            if (callback) {
                pendingLoads.push(callback);
            }
            if (!dataLoading) {
                spriteEffect = new _core.Tw2Effect();
                spriteEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/blinkinglightspool.fx';
                spriteEffect.parameters['MainIntensity'] = new _core.Tw2FloatParameter('MainIntensity', 1);
                spriteEffect.parameters['GradientMap'] = new _core.Tw2TextureParameter('GradientMap', 'res:/texture/particle/whitesharp_gradient.dds.0.png');
                spriteEffect.Initialize();

                _core.resMan.GetObject('res:/dx9/model/spaceobjectfactory/data.red', function (obj) {
                    data = obj;
                    for (var i = 0; i < pendingLoads.length; ++i) {
                        pendingLoads[i]();
                    }
                    pendingLoads = [];
                });
                dataLoading = true;
            }
        } else {
            if (callback) {
                callback();
            }
        }
    };

    this.BuildFromDNA = function (dna, callback) {
        if (data === null) {
            this.LoadData(function () {
                var result = Build(dna);
                if (callback) {
                    callback(result);
                }
            });
        } else {
            var result = Build(dna);
            if (callback) {
                callback(result);
            }
        }
    };

    function GetTurretMaterialParameter(name, parentFaction, areaData) {
        var materialIdx = -1;
        for (var i = 0; i < data['generic']['materialPrefixes'].length; ++i) {
            if (name.substr(0, data['generic']['materialPrefixes'][i].length) === data['generic']['materialPrefixes'][i]) {
                materialIdx = i;
                name = name.substr(data['generic']['materialPrefixes'][i].length);
            }
        }
        if (materialIdx !== -1) {
            var turretMaterialIndex = _get(parentFaction, 'materialUsageMtl' + (materialIdx + 1), materialIdx);
            if (turretMaterialIndex >= 0 && turretMaterialIndex < data['generic']['materialPrefixes'].length) {
                name = data['generic']['materialPrefixes'][turretMaterialIndex] + name;
                if (name in areaData.parameters) {
                    return areaData.parameters[name];
                }
            }
        }
    }

    var zeroColor = [0, 0, 0, 0];

    function CombineTurretMaterial(name, parentValue, turretValue, overrideMethod) {
        switch (overrideMethod) {
            case 'overridable':
                return parentValue ? parentValue : turretValue ? turretValue : zeroColor;
            case 'half_overridable':
                if (name.indexOf('GlowColor') >= 0) {
                    return turretValue ? turretValue : zeroColor;
                }
                return parentValue ? parentValue : turretValue ? turretValue : zeroColor;
            case 'not_overridable':
            case 'half_overridable_2':
                return turretValue ? turretValue : zeroColor;
        }
        return zeroColor;
    }

    function SetupTurretMaterial(turretSet, parentFactionName, turretFactionName) {
        var parentFaction = data['faction'][parentFactionName];
        var turretFaction = data['faction'][turretFactionName];
        var parentArea = null;
        if (parentFaction && parentFaction.areas && 'hull' in parentFaction.areas) {
            parentArea = parentFaction.areas.hull;
        }
        var turretArea = null;
        if (turretFaction && turretFaction.areas && 'hull' in turretFaction.areas) {
            turretArea = turretFaction.areas.hull;
        }
        if (!parentArea && !turretArea) {
            return;
        }
        if (turretSet.turretEffect) {
            var params = turretSet.turretEffect.parameters;
            for (var i in params) {
                if (params.hasOwnProperty(i)) {
                    if (params[i].constructor.prototype !== _core.Tw2Vector4Parameter.prototype) {
                        continue;
                    }
                    var parentValue = null;
                    var turretValue = null;
                    if (parentArea) {
                        parentValue = GetTurretMaterialParameter(i, parentFaction, parentArea);
                    }
                    if (turretArea) {
                        turretValue = GetTurretMaterialParameter(i, parentFaction, parentArea);
                    }
                    _math.vec4.copy(params[i].value, CombineTurretMaterial(i, parentValue, turretValue, turretSet.turretEffect.name));
                }
            }
            turretSet.turretEffect.BindParameters();
        }
    }

    this.SetupTurretMaterial = function (turretSet, parentFactionName, turretFactionName, callback) {
        if (data === null) {
            this.LoadData(function () {
                SetupTurretMaterial(turretSet, parentFactionName, turretFactionName);
                if (callback) {
                    callback();
                }
            });
        } else {
            SetupTurretMaterial(turretSet, parentFactionName, turretFactionName);
            if (callback) {
                callback();
            }
        }
    };

    function getDataKeys(name) {
        if (name !== 'all') {
            var names = {};
            for (var i in data[name]) {
                if (data[name].hasOwnProperty(i)) {
                    names[i] = data[name][i].description || '';
                }
            }
            return names;
        } else {
            return data;
        }
    }

    this.GetHullNames = function (callback) {
        this.LoadData(function () {
            callback(getDataKeys('hull'));
        });
    };

    this.GetFactionNames = function (callback) {
        this.LoadData(function () {
            callback(getDataKeys('faction'));
        });
    };

    this.GetRaceNames = function (callback) {
        this.LoadData(function () {
            callback(getDataKeys('race'));
        });
    };

    this.GetSofData = function (callback) {
        this.LoadData(function () {
            callback(getDataKeys('all'));
        });
    };
}

/***/ })
/******/ ]);